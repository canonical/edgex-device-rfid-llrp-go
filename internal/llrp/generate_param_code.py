#!python3

#
#  Copyright (C) 2020 Intel Corporation
#
#  SPDX-License-Identifier: Apache-2.0

# This python script reads a YAML file
# to generate Go code that unpacks binary LLRP messages
# so that they can be marshaled into JSON.
#
# Why bother doing it this way? In short, because other ways weren't good;
# it's much easier to express the LLRP message hierarchy as YAML than as Go code,
# and it's pretty easy to use that to generate parsers that are far less error prone
# than writing it by hand.
#
# At first blush, LLRP looks easy to parse,
# but when you dig in, there are a lot of rules and required context
# around how the next bytes should be interpreted.
# I tried writing it with interfaces and with reflection code,
# but it was way, way too easy to make a mistake, and I spent a ton of time
# debugging difficult to spot errors that could only be triggered at runtime.
#
# The best version came from 'hand-crafted' byte unmarshaling,
# but 1) it's still easy to mess up and 2) it would take too long to write.
#
# As I was building up a mental model around LLRP,
# I built a spreadsheet to reference the memory layouts, types, and rules.
# Looking at it, I realized it had all the need parsing info,
# so I converted to it the messages.yaml file and cleaned it up a bit,
# then wrote this code to read it in, statically check various assumptions,
# calculate some useful constraint checks from the message graph,
# and output the unmarshaling code.

try:
    import yaml
except ImportError:
    print('error: missing yaml; try "pip install pyyaml"')
    exit(1)

import dataclasses
import re
import sys
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Dict, List, Optional, Union, Any

YML = Dict[str, Any]  # just for type checking; otherwise does nothing


class Error(Exception):
    """Base class for errors generated by this script."""


class MissingParamError(Error):
    """Message or Parameter references an unknown Parameter."""

    def __init__(self, parent: 'Container', decl: 'ParamSpec', msg: str = None):
        if msg is None:
            msg = f'{parent.name} references unknown parameters {decl.param_name}'
        super(MissingParamError, self).__init__(msg)
        self.parent = parent
        self.decl = decl


class DefinitionError(Error):
    """Problem with the YAML definition."""

    def __init__(self, y: YML, msg=None):
        if msg is None:
            if 'name' in y:
                msg = f'failed at: {y["name"]}'
            elif 'type' in y:
                msg = f'failed at: {y["type"]}'
            else:
                msg = f'failed at: {y}'
        super(DefinitionError, self).__init__(msg)
        self.yml = y


class DuplicateDefError(DefinitionError):
    def __init__(self, kind: str, name: str, first: Any, second: Any, y: YML, msg=None):
        if msg is None:
            msg = f'duplicate {kind} definition for {name}:\n'
            f'> first instance: {first}\n'
            f'> this instance:  {second}\n'
        super(DuplicateDefError, self).__init__(y, msg)
        self.kind = kind
        self.name = name
        self.first = first
        self.second = second


class MissingPropError(DefinitionError):
    def __init__(self, missing: List[str], y: YML, msg=None):
        if msg is None:
            msg = f'missing required properties {missing}'
        super(MissingPropError, self).__init__(y, msg)


class GoWriter:
    """GoWriter outputs (mostly) formatted Go code.
    By default it writes to stdout, but you can set w to any File object
    (really, anything with a 'write' function)."""

    # map of basic types to byte lengths
    typeSizes = {
        'bool':   1,
        'int8':   1,
        'int16':  2,
        'int32':  4,
        'int64':  8,
        'uint8':  1,
        'uint16': 2,
        'uint32': 4,
        'uint64': 8,
    }

    def __init__(self, w=None):
        if w is None:
            self.w = sys.stdout
        else:
            self.w = w
        self.i = 0
        self.begin = True

    def write(self, text, end='\n'):
        lines = text.split('\n')
        if self.begin:
            self.w.write(self.i * '\t')

        for line in lines[:-1]:
            self.w.write(line + end + self.i * '\t')

        if len(lines) > 0:
            line = lines[-1]
            self.w.write(line + end)

        self.begin = end == '\n'

    @staticmethod
    def lower_camel(s: str) -> str:
        """Convert ABCCamelCaseString to abcCamelCaseString.
        Useful for creating unexported type names."""
        if len(s) <= 1:
            return s.lower()
        m = re.match(r'[A-Z]+', s)
        if not m or m.end() == len(s):
            return s.lower()

        if m.end() == 1:
            return s[0].lower() + s[1:]
        if s[m.end()].isalpha():
            return s[:m.end() - 1].lower() + s[m.end() - 1:]
        else:
            return s[:m.end()].lower() + s[m.end():]

    def indent(self):
        """Increase the indentation level for all subsequent output."""
        self.i += 1
        self.begin = True

    def dedent(self):
        """Decrease the indentation level fro all subsequent output."""
        self.i = max(self.i - 1, 0)
        self.begin = True

    @contextmanager
    def paren(self, before_start: Optional[str] = None):
        """Returns a context within which writes are indented inside parentheses,
        optionally with some before_start string written before the opening paren:
            before_start (
                <output written within context>
            )

        Use like any other python context. E.g., this code:
            with writer.paren('const'):
                for i in range(3):
                    w.write(f'myNum{i} = 1<<{i}')
        has this output:
            const (
                myNum0 = 1<<0
                myNum1 = 1<<1
                myNum2 = 1<<2
            )
        """
        if before_start is not None:
            self.write(before_start, end=' ')
        self.write('(')
        self.indent()
        yield
        self.dedent()
        self.write(')\n')

    @contextmanager
    def block(self, before_start: Optional[str] = None):
        """Returns a context within which writes are indented inside curly braces.
        See paren for more information."""
        if before_start is not None:
            self.write(before_start, end=' ')
        self.write('{')
        self.indent()
        yield
        self.dedent()
        self.write('}\n')

    @contextmanager
    def condition(self, cond):
        """Returns a context within which writes are indented inside an if (cond) block.
        See paren for more information.
        See elseif
        """
        self.write(f'if {cond} {{')
        self.indent()
        yield
        self.dedent()
        self.write('}\n')

    def ifelse(self, cond: Optional[str] = None):
        """Write the '} else {' or '} else if (condition) {' in an if...else block."""
        self.dedent()
        if cond is not None:
            self.write(f'}} else if {cond} {{')
        else:
            self.write('} else {')
        self.indent()

    def err_check(self, cond, params: Optional[List[str]] = None, ret: Optional[str] = 'err'):
        """Write 'if err := (cond); err != nil {\n return err\n }.
        Optionally, set other parameters and/or change the return value:
            if params[0], params[1], err := cond; err != nil {\n return ret\n}
        """
        p_list = ['err'] if not params else params + ['err']
        with self.block(f'if {", ".join(p_list)} := {cond}; err != nil'):
            if ret is not None:
                self.write('return ' + ret)

    def reterr(self, msg: Optional[str], params: Optional[List[str]] = None, wrap: bool = False):
        """Writes code to return an error, using 'return err' or one of
        New, Errorf, Wrap, or Wrapf if there are params and/or wrap is True."""
        if not msg:
            assert params is None and wrap is False
            self.write('return err')
            return

        msg = msg.replace('\n', '" +\n"')
        if wrap and params:
            assert msg.count('%') == len(params)
            self.write(f'return errors.Wrapf(err, "{msg}", {", ".join(params)})')
        elif wrap and not params:
            self.write(f'return errors.Wrap(err, "{msg}")')
        elif params:
            assert msg.count('%') == len(params)
            self.write(f'return errors.Errorf("{msg}", {", ".join(params)})')
        else:
            self.write(f'return errors.New("{msg}")')


@dataclass
class DataType:
    """DataType backs field types, such as built-ins, flags, enumerations, and aliases."""
    name: str  # type name must be unique to the Go package
    storage: str  # underlying basic type (e.g., uint8)
    prefix: str = ''  # when generating code, prefix is attached to enum/flag names
    kind: str = 'alias'  # flag, enumeration, or alias, or external
    values: Union[List[str], Optional[Dict[str, int]]] = None  # maps name -> value, or implicitly name -> iota
    size: int = 0  # storage byte size; for arrays, the byte size of a single element

    description: Optional[str] = None  # for outputting doc comments; currently unused
    min: Optional[int] = None  # currently unused
    max: Optional[int] = None  # currently unused

    @classmethod
    def from_yaml(cls, y: YML) -> 'DataType':
        missing = [req for req in ('name', 'storage') if req not in y]
        if any(missing):
            raise MissingPropError(missing, y)
        d = cls(**y)

        if 'size' not in y:
            if d.storage.startswith('uint'):
                d.size = int(d.storage[4:]) // 8
            elif d.storage.startswith('int'):
                d.size = int(d.storage[3:]) // 8
            else:
                raise DefinitionError(y, f'the size of {d.name} ({d.storage}) isn\'t known')

        if d.kind in ('alias', 'external'):
            return d

        if d.kind not in ('flag', 'enum'):
            raise DefinitionError(y, f'unknown kind {d.kind} for type def {d.name}')

        if d.values is None:
            d.values = {}
            return d

        try:
            vals = {}
            for name, value in d.values.items():
                vals[d.prefix + name] = value
            d.values = vals
        except AttributeError:
            vals = {}
            for value, name in enumerate(d.values):
                vals[d.prefix + name] = value
            d.values = vals

        if len(d.values) > 1 << d.size * 8:
            raise DefinitionError(y, f'{d.name} has more items than can fit in {d.storage}')
        return d

    def write_type_def(self, w):
        if self.kind == 'external':
            return

        if self.kind == 'alias':
            w.write(f'type {self.name} = {self.storage}')
            return

        if not any(self.values):
            w.write(f'type {self.name} {self.storage}')
            return

        if len(self.values) == 1:
            w.write(f'type {self.name} {self.storage}')
            name, value = list(self.values.items())[0]
            if self.kind == 'flag':
                w.write(f'const {name} = {self.name}(1 << {self.size * 8 - 1})')
            else:
                w.write(f'const {name} = {self.name}({value})')
            return

        w.write(f'\ntype {self.name} {self.storage}')
        if self.kind == 'enum':
            with w.paren('const'):
                for name, value in sorted(self.values.items(), key=lambda x: x[1]):
                    w.write(f'{name} = {self.name}({value})')
            w.write('')
            return

        assert self.kind == 'flag'
        flags = sorted(self.values.items(), key=lambda x: x[1])

        with w.paren('const'):
            w.write(f'{flags[0][0]} = {self.name}(1 << ({self.size * 8 - 1} - iota))')
            for name, _ in flags[1:]:
                w.write(f'{name}')

    def is_fixed_size(self) -> bool:
        """False for array types and True for all others."""
        return self.storage[0] != '['

    def is_alias(self) -> bool:
        return self.kind == 'alias'

    def is_field(self) -> bool:
        return self.kind == 'field'

    def is_enum(self) -> bool:
        return self.kind == 'enum'

    def is_external(self) -> bool:
        return self.kind == 'external'

    def must_extract(self) -> bool:
        return self.size > 1 and not self.is_alias()


@dataclass
class FieldSpec:
    """A field spec defines a field in a parameter or message."""
    name: str  # the name to use in structs
    type: DataType  # backing type; for arrays, the type of a single element
    padding: bool = False
    is_array: bool = False
    length: int = 0  # 0 if has a length prefix, -1 if all remaining bytes, otherwise an array length

    min: Optional[int] = None  # currently unused
    max: Optional[int] = None  # currently unused
    extract: Optional[str] = None  # currently unused; TODO: should output shift
    description: Optional[str] = None  # currently unused

    @property
    def min_size(self) -> int:
        """Returns the minimum number of bytes this field needs in an LLRP message."""
        if self.type.name in ('string', 'bitArray'):
            return 2
        if self.is_array:
            if self.length == 0:
                return 2
            if self.length == -1:
                return 0
            return self.length * self.type.size
        return self.type.size

    def is_fixed_size(self) -> bool:
        """Returns True if this field has a fixed size."""
        return not self.is_array and self.type.is_fixed_size()

    @classmethod
    def from_yaml(cls, y: YML, types: Dict[str, DataType]) -> 'FieldSpec':
        if 'type' not in y:
            raise MissingPropError(['type'], y)

        y['name'] = y.get('name', y['type'])

        typ = y['type']
        if typ.startswith('[]'):
            y['is_array'] = True
            typ = typ[2:]

        try:
            y['type'] = types[typ]
        except KeyError:
            raise DefinitionError(y, f'unknown type {typ} in field spec')

        return cls(**y)

    def var_name(self, struct_name: str = '') -> str:
        """Returns the variable name used to reference this field."""
        assert not self.padding
        if struct_name.startswith('*'):
            return struct_name
        prefix = struct_name + '.' if struct_name else ''
        return f'{prefix}{self.name}'

    def struct_field(self) -> str:
        """Returns the field type as it should appear in a struct definition."""
        if self.type.name == 'bitArray':
            return f'{self.name} []byte'
        if self.type.name == 'string':
            return f'{self.name} string'
        return f'{self.name} {"[]" if self.is_array else ""}{self.type.name}'

    def value(self, begin: Union[int, str] = 0, end: Union[int, str] = '') -> str:
        """Return an expression to extract data[begin:end] and cast to this type."""
        if begin:
            from_exp = f'data[{begin}:{end}]'
        elif end:
            from_exp = f'data[:{end}]'
        else:
            from_exp = 'data'

        if self.type.size == 1:
            from_exp = f'data[{begin}]'
        elif self.type.size == 2:
            from_exp = f'binary.BigEndian.Uint16({from_exp})'
        elif self.type.size == 4:
            from_exp = f'binary.BigEndian.Uint32({from_exp})'
        elif self.type.size == 8:
            from_exp = f'binary.BigEndian.Uint64({from_exp})'

        # determine if we need to cast
        if self.type.name.startswith('uint') or \
                self.type.is_alias() and self.type.storage.startswith('uint'):
            return from_exp
        if self.type.name == 'bitArray':
            return from_exp
        if self.type.name == 'bool':
            return f'{from_exp} != 0'
        return f'{self.type.name}({from_exp})'

    def write_unmarshal_arr(self, w, reslice: bool, var: str, pos: int):
        """Writes unmarshaling code for an array type."""
        if self.length > 0 and self.type.name != 'string':
            w.write(f'{var} = make([]{self.type.name}, {self.length})')
            data = f'data[{pos + 2}:]' if pos else 'data'
            if self.type.name == 'byte':
                w.write(f'copy({var}, {data})')
            else:
                with w.block(f'for i := 0; i < {self.length}; i++'):
                    w.write(f'{var}[i] = {self.value("i")}')
            return

        typ = '[]' + self.type.name  # used in error strings
        if pos == 0:
            length = f'int(binary.BigEndian.Uint16(data))'
        else:
            length = f'int(binary.BigEndian.Uint16(data[{pos}:]))'
        data = f'data[{pos + 2}:]'

        if self.type.name == 'bitArray':
            typ = 'bit array'
            length += '&7'
        elif self.type.name == 'string':
            typ = 'string'

        sz = self.type.size
        mul = f'*{sz}' if sz != 1 else ''

        # TODO: output overflow check
        with w.condition(f'arrLen := {length}; arrLen{mul} > len({data})'):
            w.reterr(f'{self.name} ({typ}) declares it has %d bytes, '
                     f'but only %d bytes are available', [f'arrLen{mul}', f'len({data})'])
            w.ifelse('arrLen != 0')

            if self.type.name == 'string':
                w.write(f'{var} = string(data[{pos + 2}:arrLen+{pos + 2}])')
                if reslice:
                    w.write(f'data = data[arrLen+{pos + 2}:]')
                return

            if self.type.name == 'bitArray':
                w.write(f'{var} = make([]byte, arrLen)')
            else:
                w.write(f'{var} = make([]{self.type.name}, arrLen)')

            if self.type.name == 'byte':
                w.write(f'copy({var}, {data})')
            elif self.type.size == 1:
                if self.type.is_alias():
                    w.write(f'copy({var}, {data})')
                else:
                    with w.block(f'for i := 0; i < arrLen; i++'):
                        w.write(f'{var}[i] = {self.value("i")}')
            else:
                with w.block(f'for i, pos := 0, {pos + 2}; i < arrLen; i, pos = i+1, pos+{sz}'):
                    w.write(f'{var}[i] = {self.value("pos")}')

            if reslice:
                w.write(f'data = data[arrLen{mul}+{pos + 2}:]')

    def write_unmarshal(self, w, reslice: bool, prefix: str = 'pt', pos: int = 0):
        """Outputs Go code to unmarshal this fields.
        If is_last is False and this is not a fixed size type,
        it'll writes an expression to reslice the data.
        """
        if self.padding:
            if reslice:
                w.write(f'data = data[{pos + self.min_size}:]')
            return

        var = self.var_name(prefix)
        if self.is_fixed_size() and not self.is_array:
            w.write(f'{var} = {self.value(pos)}')
            if reslice:
                w.write(f'data = data[{pos + self.min_size}:]')
            return

        if self.length >= 0:
            self.write_unmarshal_arr(w, reslice, var, pos)
            return

        # consume the rest of the data
        data, d_len = 'data', 'len(data)'
        if pos > 0:
            data = f'data[{pos}:]'
            d_len = f'len(data)-{pos}'

        with w.condition(f'{d_len} == 0'):
            w.write('return nil')
        w.write(f'{var} = make([]byte, {d_len})')
        w.write(f'copy({var}, {data})\n')
        if reslice:
            w.write(f'data = data[{pos + self.min_size}:]')


@dataclass
class ParamSpec:
    """ParamSpec specifies the parameters permitted in a certain context,
    and under what conditions.

    Some ParamSpecs are groups of parameters that can be presented in arbitrary order,
    often associated with a particular Air Protocol.
    The whole group may be optional/repeatable,
    and individual elements of the group may be optional/repeatable.
    If all the elements are optional, but the group itself isn't,
    then it implies "at least one of these must be present".
    If a group is repeatable, but all it's members are required and non-repeatable,
    it means the elements can come in any order, but each must be given exactly once.
    """
    name: str  # name used for a struct; may be omitted from yaml to use the parameter name
    param_name: str  # name of an LLRP parameter type
    optional: bool = False  # parameter is "0-1" or "0-n"
    repeatable: bool = False  # parameter is "0-n" or "1-n"
    air_protocol: Optional[str] = None  # if this parameter is tied to a specific air protocol...
    p_def: 'Container' = None  # parameter definition; set after parameters are read

    def is_fixed_size(self) -> bool:
        """Returns true if this parameter is always a fixed size."""
        return not (self.optional or self.repeatable) and self.p_def.fixed_size

    @classmethod
    def from_yaml(cls, y: YML) -> 'ParamSpec':
        if 'type' not in y:
            raise MissingPropError(['type'], y)
        return ParamSpec(y.get('name', y['type']),
                         y['type'],
                         y.get('optional', False),
                         y.get('repeatable', False),
                         y.get('airProtocol'))

    def struct_field(self) -> str:
        if self.repeatable:
            return f'{self.name} []{self.p_def.type_name}'


@dataclass
class Container:
    """Container mostly represents Parameters, but Messages are nearly identical,
    so it serves double duty."""
    name: str
    type_id: int  # message or parameter number
    short: str  # string to use as method receivers

    fields: List[FieldSpec] = dataclasses.field(default_factory=list)
    parameters: List[ParamSpec] = dataclasses.field(default_factory=list)

    # derived properties
    fixed_size: bool = False  # true if no variable length fields/optional or repeatable parameters
    min_size: int = 0  # minimum required size (incl. header); absolute size if fixed_size is True
    header_size: int = 0  # only set for Parameters, not Messages
    has_required: bool = False  # true if has required parameters

    description: Optional[str] = None  # currently unused

    @classmethod
    def from_yaml(cls, y, types: Dict[str, DataType]) -> 'Container':
        missing = [req for req in ('name', 'typeID') if req not in y]
        if any(missing):
            raise ValueError(f'definition missing {missing}: {y}')

        p = cls(y['name'], y['typeID'], y.get('short', 'p'))
        if 'fields' in y:
            p.fields = [FieldSpec.from_yaml(f, types) for f in y['fields']]
        if 'parameters' in y:
            p.parameters = [ParamSpec.from_yaml(s) for s in y['parameters']]
        return p

    @property
    def type_name(self) -> str:
        """Returns the Go type name."""
        return GoWriter.lower_camel(self.name)

    def can_inline(self) -> bool:
        """Returns False if this must be a struct."""
        return (len(self.fields) == 1 and len(self.parameters) == 0
                and self.fields[0].is_fixed_size())

    def write_struct(self, w):
        """Write the Parameter as a Go struct."""
        if self.can_inline():
            f = self.fields[0]
            if f.type.name == 'bitArray':
                typ = '[]byte'
            else:
                typ = f'{"[]" if f.is_array else ""}{f.type.name}'
            w.write(f'type {self.type_name} {typ}')
            return

        if self.empty():
            w.write(f'type {self.type_name} struct {{}}\n')
            return

        with w.block(f'type {self.type_name} struct'):
            for f in self.fields:
                if f.padding:
                    continue
                w.write(f.struct_field())

            for p in self.parameters:
                if p.repeatable:
                    w.write(f'{p.name} []{p.p_def.type_name}')
                elif p.optional:
                    w.write(f'{p.name} *{p.p_def.type_name}')
                else:
                    w.write(f'{p.name} {p.p_def.type_name}')

    def should_check_leftover(self) -> bool:
        """Returns True if after unmarshaling, we should check for remaining data."""
        if self.fixed_size:
            return False
        if self.fields and not self.parameters and self.fields[-1].length >= 0:
            return True
        return False

    def write_marshal(self, w):
        with w.block(f'func ({self.short} *{self.type_name}) writeBinary(w io.Writer) error'):
            self.write_marshal_body(w)
            w.write('return nil')

    def write_marshal_body(self, w):
        pass

    def write_unmarshal(self, w):
        with w.block(f'func ({self.short} *{self.type_name}) UnmarshalBinary(data []byte) error'):
            self.write_unmarshal_body(w)

            if self.should_check_leftover():
                with w.condition('len(data) > 0'):
                    w.reterr(f'finished reading {self.name}, '
                             'but an unexpected %d bytes remain', ['len(data)'])
            w.write('return nil')

    def empty(self) -> bool:
        """Returns True if this doesn't have any fields or parameters."""
        return not (any(self.fields) or any(self.parameters))

    def write_unmarshal_body(self, w):
        sz = self.min_size - self.header_size
        szb = f'{sz} byte' if sz == 1 else f'{sz} bytes'
        assert sz > 0 or self.empty() or self.fields[-1].length <= 0, str(self)

        # byte length check
        if self.fixed_size:
            with w.condition(f'len(data) != {sz}'):
                w.reterr(f'Param{self.name} requires exactly {szb} '
                         '\nbut received %d', ['len(data)'])
        else:
            with w.condition(f'len(data) < {sz}'):
                w.reterr(f'Param{self.name} requires at least {szb} '
                         '\nbut only %d are available', ['len(data)'])

        # field unmarshaling
        pos = 0
        if self.can_inline():
            f = self.fields[0]
            w.write(f'*{self.short} = {self.type_name}({f.value()})')
        elif any(self.fields):
            for i, f in enumerate(self.fields):
                # skip reslice if this is a fixed size field,
                # or if it's the final item (i.e., last field & no params)
                reslice = ((not f.is_fixed_size()) or
                           (i == len(self.fields) - 1 and any(self.parameters)))
                f.write_unmarshal(w, reslice, self.short, pos)
                if reslice:
                    f.pos = 0
                else:
                    pos += f.min_size

        if not any(self.parameters):
            return

        # parameters/sub-parameters
        w.write('\n// sub-parameters')
        for i, p in enumerate(self.parameters):
            if p.optional and all(pp.optional for pp in self.parameters[i:]):
                if len(self.parameters) > i + 1:
                    w.write('\n// only optional parameters remain; return if no more data')
                else:
                    w.write(f'\n// {p.name} is optional')
                with w.condition('len(data) == 0'):
                    w.write('return nil')

            sub = p.p_def

            # add the header type check
            if sub.header_size == 1:  # TV parameter
                # TODO: handle optional and repeatable TV parameters
                with w.condition(f'ParamType(data[0]) != Param{sub.name}'):
                    w.reterr(f'expected Param{sub.name}, but found %v', ['ParamType(data[0])'])

            elif sub.header_size == 4:  # TLV
                if i > 0 or any(self.fields):
                    with w.condition(f'len(data) < 4'):
                        w.reterr(f'parameter Param{sub.name} needs 4 bytes for a TLV header, '
                                 f'\nbut only %d bytes remain', ['len(data)'])

                if p.optional:
                    blk = w.condition(f'subType := ParamType(binary.BigEndian.Uint16(data)); '
                                      f'subType == Param{sub.name}')
                else:
                    blk = w.condition(f'subType := ParamType(binary.BigEndian.Uint16(data)); '
                                      f'subType != Param{sub.name}')

                with blk:
                    if not p.optional:
                        w.reterr(f'expected Param{sub.name}, but found %v', ['subType'])
                        w.ifelse()

                    if p.repeatable:
                        with w.block(f'for len(data) >= 4'):
                            w.write('subType := ParamType(binary.BigEndian.Uint16(data))')
                            with w.condition(f'subType != Param{sub.name}'):
                                w.write('break')
                            w.write('subLen := binary.BigEndian.Uint16(data[2:])')
                            with w.condition('int(subLen) > len(data)'):
                                w.reterr(f'Param{sub.name} '
                                         'says it has %d bytes,\n but only %d bytes remain',
                                         ['subLen', 'len(data)'])

                            w.write(f'var tmp {sub.type_name}')
                            w.err_check(f'tmp.UnmarshalBinary(data[4:subLen])')
                            w.write(f'{self.short}.{p.name} = append({self.short}.{p.name}, tmp)')

                            w.write('data = data[subLen:]')
                    else:
                        w.write('subLen := binary.BigEndian.Uint16(data[2:])')
                        with w.condition('int(subLen) > len(data)'):
                            w.reterr(f'Param{sub.name} '
                                     'says it has %d bytes,\n but only %d bytes remain',
                                     ['subLen', 'len(data)'])

                        if p.optional:
                            w.write(f'{self.short}.{p.name} = new({sub.type_name})')

                        if sub.can_inline():
                            exp = sub.fields[0].value(4)
                            if p.optional:
                                w.write(f'*', end='')
                            w.write(f'{self.short}.{p.name} = {sub.type_name}({exp})')
                        else:
                            w.err_check(f'{self.short}.{p.name}.UnmarshalBinary(data[4:subLen])')
                        w.write('data = data[subLen:]')
            else:
                assert False


@dataclass
class Message(Container):
    """Overrides Container with things that Messages actually do differently than Parameters."""
    response_to: Optional[int] = None  # id of the message this is a response to

    @classmethod
    def from_yaml(cls, y, types: Dict[str, DataType]) -> 'Message':
        # noinspection PyTypeChecker
        m: Message = super(Message, cls).from_yaml(y, types)
        m.response_to = y.get('responseTo')
        m.short = y.get('short', 'm')  # change the name of the method receiver
        return m

    def can_inline(self) -> bool:
        return False  # never inline messages

    def write_unmarshal(self, w):
        if self.min_size != 0:
            super().write_unmarshal(w)
            return

        with w.block(f'func ({self.short} *{self.type_name}) UnmarshalBinary(data []byte) error'):
            w.write(f'// {self.name} is a header-only message')
            with w.condition('len(data) > 0'):
                w.write(f'return errors.Errorf('
                        f'"{self.name} should be empty, but has %d bytes", len(data))')
            w.write('return nil')


def load_data(definitions: YML) -> (Dict[str, DataType], Dict[str, Container], Dict[str, Message]):
    """Read the YAML definitions to build the object graph."""

    # predefine some types
    types: Dict[str, DataType] = {
        'string':   DataType('string', '[]byte', kind='external', size=1,
                             description="A series of UTF-8 values starting with uint16 byte-length header"),
        'bitArray': DataType('bitArray', '[]byte', kind='external', size=1,
                             description="A series of bits, "
                                         "starting with a uint16 indicating number of bits, "
                                         "padded with 0s (as LSBs) to an octet boundary."),
        'bool':     DataType('bool', 'bool', kind='external', size=1),
        'uint8':    DataType('uint8', 'uint8', kind='external', size=1),
        'byte':     DataType('byte', 'byte', kind='external', size=1),
        'uint16':   DataType('uint16', 'uint16', kind='external', size=2),
        'uint32':   DataType('uint32', 'uint32', kind='external', size=4),
        'uint64':   DataType('uint64', 'uint64', kind='external', size=8),
        'int8':     DataType('int8', 'int8', kind='external', size=1),
        'int16':    DataType('int16', 'int16', kind='external', size=2),
        'int32':    DataType('int32', 'int32', kind='external', size=4),
        'int64':    DataType('int64', 'int64', kind='external', size=8),
    }

    parameters: Dict[str, Container] = {}
    messages: Dict[str, Message] = {}

    for y in definitions['types']:
        dt = DataType.from_yaml(y)
        if dt.name in types:
            raise DuplicateDefError('type', dt.name, dt, types[dt.name], y)
        types[dt.name] = dt

    for y in definitions['parameters']:
        p = Container.from_yaml(y, types)
        if p.name in parameters:
            raise DuplicateDefError(f'parameter', p.name, p, parameters[p.name], y)
        parameters[p.name] = p

    for y in definitions['messages']:
        m = Message.from_yaml(y, types)
        if m.name in messages:
            raise DuplicateDefError(f'message', m.name, m, messages[m.name], y)
        messages[m.name] = m

    return types, parameters, messages


def set_param_sizes(params: Dict[str, Container]):
    """Determine the min sizes of the parameters,
    i.e., the sum of their fields' min sizes
    plus the sum of required parameters' min sizes,
    plus the parameter's header, which varies depending on its type.
    Determine if the parameter's size is in fact fixed."""
    param_sizes: Dict[str, int] = {}  # for handling parameters cycles

    def get_param_size(p: Container) -> int:
        if p.name in param_sizes:
            return param_sizes[p.name]
        p.header_size = 1 if p.type_id < 128 else 4
        param_sizes[p.name] = 0

        p.min_size = (p.header_size + sum(f.min_size for f in p.fields))
        for sp in p.parameters:
            if sp.optional:
                continue
            else:
                p.min_size += get_param_size(sp.p_def)

        # because of the get_param_size call above, sub-parameter's fixed_size is set
        p.fixed_size = not (any(f for f in p.fields if not f.is_fixed_size()) or
                            any(sub for sub in p.parameters if not sub.is_fixed_size()))

        param_sizes[p.name] = p.min_size
        return p.min_size

    for p in params.values():
        for sub in p.parameters:
            try:
                sub.p_def = params[sub.param_name]
            except KeyError:
                raise MissingParamError(p, sub)

    for p in params.values():
        get_param_size(p)
        p.has_required = any(sp for sp in p.parameters if not sp.optional)


def set_msg_sizes(msgs: Dict[str, Message], params: Dict[str, Container]):
    """Set messages min sizes to the sum of their fields' min sizes
    plus the sum of required parameters' min sizes.
    Note that this doesn't include the message header."""

    for m in msgs.values():
        for p in m.parameters:
            try:
                p.p_def = params[p.param_name]
            except KeyError:
                raise MissingParamError(m, p)

        m.min_size = (sum(f.min_size for f in m.fields) +
                      sum(p.p_def.min_size for p in m.parameters if not p.optional))
        m.has_required = any(sp for sp in m.parameters if not sp.optional)


def main():
    import sys
    import argparse

    parser = argparse.ArgumentParser(
        description='A python script to read a YAML description '
                    'of binary LLRP messages to generate Go code '
                    'to convert them into JSON'
    )
    parser.add_argument('-i', '--input', help='input file (default: STDIN)',
                        type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument('-o', '--output', help='output file (default: STDOUT)',
                        type=argparse.FileType('w'), default=sys.stdout)
    args = parser.parse_args()

    definitions = yaml.safe_load(args.input)
    types, parameters, messages = load_data(definitions)
    set_param_sizes(parameters)
    set_msg_sizes(messages, parameters)

    w = GoWriter(args.output)
    w.write(f'// Code generated by "{" ".join(sys.argv)}"; DO NOT EDIT.\n')
    w.write('package llrp\n\n')

    with w.paren('import'):
        w.write('"encoding/binary"')
        w.write('"github.com/pkg/errors"')

    for t in types.values():
        t.write_type_def(w)

    w.write('')
    for m in messages.values():
        w.write(f'// {m.type_name} is Message {m.type_id}, {m.name}.')
        m.write_struct(w)

        w.write(f'// UnmarshalBinary Message {m.type_id}, {m.name}.')
        m.write_unmarshal(w)

    for p in parameters.values():
        w.write(f'// {p.type_name} is Parameter {p.type_id}, {p.name}.')
        p.write_struct(w)

        w.write(f'// UnmarshalBinary Parameter {p.type_id}, {p.name}.')
        p.write_unmarshal(w)


if __name__ == '__main__':
    try:
        main()
    except DefinitionError as e:
        print(e.yml)
        raise
    except MissingParamError as e:
        print(e.parent)
        print(e.decl)
        raise
