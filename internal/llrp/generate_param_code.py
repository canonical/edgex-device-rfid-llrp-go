#!python3

#
#  Copyright (C) 2020 Intel Corporation
#
#  SPDX-License-Identifier: Apache-2.0

#
#
#  SPDX-License-Identifier: Apache-2.0

# This python script reads a YAML file
# to generate Go code that unpacks binary LLRP messages
# so that they can be marshaled into JSON.
#
# Why bother doing it this way? In short, because other ways weren't good;
# it's much easier to express the LLRP message hierarchy as YAML than as Go code,
# and it's pretty easy to use that to generate parsers that are far less error prone
# than writing it by hand.
#
# At first blush, LLRP looks easy to parse,
# but when you dig in, there are a lot of rules and required context
# around how the next bytes should be interpreted.
# I tried writing it with interfaces and with reflection code,
# but it was way, way too easy to make a mistake, and I spent a ton of time
# debugging difficult to spot errors that could only be triggered at runtime.
#
# The best version came from 'hand-crafted' byte unmarshaling,
# but 1) it's still easy to mess up and 2) it would take too long to write.
#
# As I was building up a mental model around LLRP,
# I built a spreadsheet to reference the memory layouts, types, and rules.
# Looking at it, I realized it had all the need parsing info,
# so I converted to it the messages.yaml file and cleaned it up a bit,
# then wrote this code to read it in, statically check various assumptions,
# calculate some useful constraint checks from the message graph,
# and output the unmarshaling code.

try:
    import yaml
except ImportError:
    print('error: missing yaml; try "pip install pyyaml"')
    exit(1)

import dataclasses
import re
import sys
from contextlib import contextmanager
from dataclasses import dataclass
from itertools import groupby
from typing import Dict, List, Optional, Union, Any, Callable

YML = Dict[str, Any]  # just for type checking; otherwise does nothing


class Error(Exception):
    """Base class for errors generated by this script."""


class MissingParamError(Error):
    """Message or Parameter references an unknown Parameter."""

    def __init__(self, parent: 'Container', decl: 'ParamSpec', msg: str = None):
        if msg is None:
            msg = f'{parent.name} references unknown parameters {decl.param_name}'
        super(MissingParamError, self).__init__(msg)
        self.parent = parent
        self.decl = decl


class DefinitionError(Error):
    """Problem with the YAML definition."""

    def __init__(self, y: YML, msg=None):
        if msg is None:
            if 'name' in y:
                msg = f'failed at: {y["name"]}'
            elif 'type' in y:
                msg = f'failed at: {y["type"]}'
            else:
                msg = f'failed at: {y}'
        super(DefinitionError, self).__init__(msg)
        self.yml = y


class DuplicateDefError(DefinitionError):
    def __init__(self, kind: str, name: str, first: Any, second: Any, y: YML, msg=None):
        if msg is None:
            msg = f'duplicate {kind} definition for {name}:\n'
            f'> first instance: {first}\n'
            f'> this instance:  {second}\n'
        super(DuplicateDefError, self).__init__(y, msg)
        self.kind = kind
        self.name = name
        self.first = first
        self.second = second


class MissingPropError(DefinitionError):
    def __init__(self, missing: List[str], y: YML, msg=None):
        if msg is None:
            msg = f'missing required properties {missing}'
        super(MissingPropError, self).__init__(y, msg)


class GoWriter:
    """GoWriter outputs (mostly) formatted Go code.
    By default it writes to stdout, but you can set w to any File object
    (really, anything with a 'write' function)."""

    # map of basic types to byte lengths
    typeSizes = {
        'bool':   1,
        'int8':   1,
        'int16':  2,
        'int32':  4,
        'int64':  8,
        'uint8':  1,
        'uint16': 2,
        'uint32': 4,
        'uint64': 8,
    }

    def __init__(self, w=None):
        if w is None:
            self.w = sys.stdout
        else:
            self.w = w
        self.i = 0
        self.begin = True

    def noindent(self, text, end='\n'):
        self.w.write(text + end)

    def write(self, text, end='\n', pre='', auto_break=False):
        lines = text.split('\n')
        if self.begin:
            self.w.write(self.i * '\t' + pre)

        if not auto_break or end != '\n':
            for line in lines[:-1]:
                self.w.write(line + end + self.i * '\t' + pre)
            if len(lines) > 0:
                line = lines[-1]
                self.w.write(line + end)
        else:
            for line in lines:
                remain = 120 - self.i * 4 - len(pre)

                for word in line.split(' '):
                    if len(word) + 1 < remain:
                        self.w.write(' ')
                        remain -= 1
                    else:
                        self.w.write('\n' + self.i * '\t' + pre + ' ')
                        remain = 120 - self.i * 4 - len(pre) - 1

                    self.w.write(word)
                    remain -= len(word)
                    if remain <= 0:
                        self.w.write('\n' + self.i * '\t' + pre)
                        remain = 120 - self.i * 4 - len(pre)
            self.w.write('\n')

        self.begin = end == '\n'

    def comment(self, text):
        self.write(text, pre='//', auto_break=True)

    @staticmethod
    def lower_camel(s: str) -> str:
        """Convert ABCCamelCaseString to abcCamelCaseString.
        Useful for creating unexported type names."""
        if len(s) <= 1:
            return s.lower()
        m = re.match(r'[A-Z]+', s)
        if not m or m.end() == len(s):
            return s.lower()

        if m.end() == 1:
            return s[0].lower() + s[1:]
        if s[m.end()].isalpha():
            return s[:m.end() - 1].lower() + s[m.end() - 1:]
        else:
            return s[:m.end()].lower() + s[m.end():]

    def indent(self):
        """Increase the indentation level for all subsequent output."""
        self.i += 1
        self.begin = True

    def dedent(self):
        """Decrease the indentation level fro all subsequent output."""
        self.i = max(self.i - 1, 0)
        self.begin = True

    @contextmanager
    def paren(self, before_start: Optional[str] = None):
        """Returns a context within which writes are indented inside parentheses,
        optionally with some before_start string written before the opening paren:
            before_start (
                <output written within context>
            )

        Use like any other python context. E.g., this code:
            with writer.paren('const'):
                for i in range(3):
                    w.write(f'myNum{i} = 1<<{i}')
        has this output:
            const (
                myNum0 = 1<<0
                myNum1 = 1<<1
                myNum2 = 1<<2
            )
        """
        if before_start:
            self.write(before_start, end=' ')
        self.write('(')
        self.indent()
        yield
        self.dedent()
        self.write(')\n')

    @contextmanager
    def block(self, before_start: Optional[str] = None):
        """Returns a context within which writes are indented inside curly braces.
        See paren for more information."""
        if before_start:
            self.write(before_start, end=' ')
        self.write('{')
        self.indent()
        yield
        self.dedent()
        self.write('}\n')

    @contextmanager
    def condition(self, cond):
        """Returns a context within which writes are indented inside an if (cond) block.
        See paren for more information.
        See elseif
        """
        self.write(f'if {cond} {{')
        self.indent()
        yield
        self.dedent()
        self.write('}')

    def ifelse(self, cond: Optional[str] = None):
        """Write the '} else {' or '} else if (condition) {' in an if...else block."""
        self.dedent()
        if cond:
            self.write(f'}} else if {cond} {{')
        else:
            self.write('} else {')
        self.indent()

    @contextmanager
    def switch(self, before_start: Optional[str] = None):
        """Returns a context for writing switch cases inside curly braces.
        See paren for more information."""
        self.write('switch', end=' ')
        if before_start is not None:
            self.write(before_start, end=' ')
        self.write('{')
        yield
        self.write('}\n')

    @contextmanager
    def case(self, case: str):
        if case == 'default':
            self.write(f'default:')
        else:
            self.write(f'case {case}:')
        self.indent()
        yield
        self.dedent()

    def err_check(self, cond, params: Optional[List[str]] = None, ret: Optional[str] = 'err'):
        """Write 'if err := (cond); err != nil {\n return err\n }.
        Optionally, set other parameters and/or change the return value:
            if params[0], params[1], err := cond; err != nil {\n return ret\n}
        """
        p_list = ['err'] if not params else params + ['err']
        with self.block(f'if {", ".join(p_list)} := {cond}; err != nil'):
            if ret is not None:
                self.write('return ' + ret)

    def reterr(self, msg: Optional[str], params: Optional[List[str]] = None, wrap: bool = False):
        """Writes code to return an error, using 'return err' or one of
        New, Errorf, Wrap, or Wrapf if there are params and/or wrap is True."""
        if msg.count('%') != (len(params) if params else 0):
            raise Error(f'got "{params}", but need {msg.count("%")} params for this error: "{msg}"')

        if not msg:
            assert params is None and wrap is False
            self.write('return err')
            return

        msg = msg.replace('\n', '" +\n"')
        if wrap and params:
            self.write(f'return errors.Wrapf(err, "{msg}", {", ".join(params)})')
        elif wrap and not params:
            self.write(f'return errors.Wrap(err, "{msg}")')
        elif params:
            self.write(f'return errors.Errorf("{msg}", {", ".join(params)})')
        else:
            self.write(f'return errors.New("{msg}")')


@dataclass
class DataType:
    """DataType backs field types, such as built-ins, flags, enumerations, and aliases."""
    name: str  # type name must be unique to the Go package
    storage: str  # underlying basic type (e.g., uint8)
    prefix: str = ''  # when generating code, prefix is attached to enum/flag names
    kind: str = 'alias'  # flag, enumeration, or alias, or external
    values: Union[List[str], Optional[Dict[str, int]]] = None  # maps name -> value, or implicitly name -> iota
    size: int = 0  # storage byte size; for arrays, the byte size of a single element

    bits: int = 8  # number of bits in the final byte; usually should be 8, but occasionally not

    description: Optional[str] = None  # for outputting doc comments
    min: Optional[int] = None  # currently unused
    max: Optional[int] = None  # currently unused

    @classmethod
    def from_yaml(cls, y: YML) -> 'DataType':
        missing = [req for req in ('name', 'storage') if req not in y]
        if any(missing):
            raise MissingPropError(missing, y)
        d = cls(**y)

        if 'size' not in y:
            if d.storage.startswith('uint'):
                d.size = int(d.storage[4:]) // 8
            elif d.storage.startswith('int'):
                d.size = int(d.storage[3:]) // 8
            else:
                raise DefinitionError(y, f'the size of {d.name} ({d.storage}) isn\'t known')

        if d.kind in ('alias', 'external'):
            return d

        if d.kind not in ('flag', 'enum'):
            raise DefinitionError(y, f'unknown kind {d.kind} for type def {d.name}')

        if d.values is None:
            d.values = {}
            return d

        try:
            vals = {}
            for name, value in d.values.items():
                vals[d.prefix + name] = value
            d.values = vals
        except AttributeError:
            vals = {}
            for value, name in enumerate(d.values):
                vals[d.prefix + name] = value
            d.values = vals

        if len(d.values) > 1 << d.size * 8:
            raise DefinitionError(y, f'{d.name} has more items than can fit in {d.storage}')
        return d

    def write_type_def(self, w):
        if self.kind == 'external':
            return

        if self.description:
            for line in self.description.splitlines():
                w.write(f'// {line.strip()}')

        if self.kind == 'alias':
            w.write(f'type {self.name} = {self.storage}')
            return

        if not any(self.values):
            w.write(f'type {self.name} {self.storage}')
            return

        if len(self.values) == 1:
            w.write(f'type {self.name} {self.storage}')
            name, value = list(self.values.items())[0]
            if self.kind == 'flag':
                w.write(f'const {name} = {self.name}(1 << {self.size * 8 - 1})')
            else:
                w.write(f'const {name} = {self.name}({value})')
            return

        if not self.description:
            w.write('')
        w.write(f'type {self.name} {self.storage}')
        if self.kind == 'enum':
            with w.paren('const'):
                for name, value in sorted(self.values.items(), key=lambda x: x[1]):
                    w.write(f'{name} = {self.name}({value})')
            w.write('')
            return

        assert self.kind == 'flag'
        flags = sorted(self.values.items(), key=lambda x: x[1])

        with w.paren('const'):
            w.write(f'{flags[0][0]} = {self.name}(1 << ({self.size * 8 - 1} - iota))')
            for name, _ in flags[1:]:
                w.write(f'{name}')

    def is_fixed_size(self) -> bool:
        """False for array types and True for all others."""
        return self.storage[0] != '['

    def is_alias(self) -> bool:
        return self.kind == 'alias'

    def is_field(self) -> bool:
        return self.kind == 'field'

    def is_enum(self) -> bool:
        return self.kind == 'enum'

    def is_external(self) -> bool:
        return self.kind == 'external'

    def must_extract(self) -> bool:
        return self.size > 1 and not self.is_alias()


@dataclass
class FieldSpec:
    """A field spec defines a field in a parameter or message."""
    name: str  # the name to use in structs
    type: DataType  # backing type; for arrays, the type of a single element
    padding: bool = False
    is_array: bool = False
    length: int = 0  # 0 if has a length prefix, -1 if all remaining bytes, otherwise an array length

    description: Optional[str] = None  # for doc comments

    min: Optional[int] = None  # currently unused; eventually might be used for validation
    max: Optional[int] = None  # currently unused

    partial: Optional[bool] = False  # if the next field shares its bits with this one
    bit: Optional[int] = 0  # starting bit position, where 0=MSB ("leftmost")

    @classmethod
    def from_yaml(cls, y: YML, types: Dict[str, DataType]) -> 'FieldSpec':
        if 'type' not in y:
            raise MissingPropError(['type'], y)

        y['name'] = y.get('name', y['type'])

        typ = y['type']
        if typ.startswith('[]'):
            y['is_array'] = True
            typ = typ[2:]

        try:
            y['type'] = types[typ]
        except KeyError:
            raise DefinitionError(y, f'unknown type {typ} in field spec')

        fs = cls(**y)
        if fs.partial and fs.type.bits == 8:
            raise DefinitionError(y, f'fields with partial widths must have fewer than 8 final bits')

        return fs

    @property
    def min_size(self) -> int:
        """Returns the minimum number of bytes this field needs in an LLRP message."""
        if self.type.name in ('string', 'bitArray'):
            return 2
        if self.is_array:
            if self.length == 0:
                return 2
            if self.length == -1:
                return 0
            return self.length * self.type.size
        return self.type.size

    def is_fixed_size(self) -> bool:
        """Returns True if this field has a fixed size."""
        return ((not self.is_array and self.type.is_fixed_size()) or
                (self.is_array and self.length > 0))

    def var_name(self, struct_name: str = '') -> str:
        """Returns the variable name used to reference this field."""
        assert not self.padding
        if struct_name.startswith('*'):
            return struct_name
        prefix = struct_name + '.' if struct_name else ''
        return f'{prefix}{self.name}'

    def struct_field(self) -> str:
        """Returns the field type as it should appear in a struct definition."""
        if self.type.name == 'bitArray':
            return f'{self.name} []byte'
        if self.type.name == 'string':
            return f'{self.name} string'
        return f'{self.name} {"[]" if self.is_array else ""}{self.type.name}'

    def value(self, begin: Union[int, str] = 0, end: Union[int, str] = '') -> str:
        """Return an expression to extract data[begin:end] and cast to this type."""
        if begin:
            from_exp = f'data[{begin}:{end}]'
        elif end:
            from_exp = f'data[:{end}]'
        else:
            from_exp = 'data'

        if self.type.size == 1:
            from_exp = f'data[{begin}]'
        elif self.type.size == 2:
            from_exp = f'binary.BigEndian.Uint16({from_exp})'
        elif self.type.size == 4:
            from_exp = f'binary.BigEndian.Uint32({from_exp})'
        elif self.type.size == 8:
            from_exp = f'binary.BigEndian.Uint64({from_exp})'

        bit_size = 8 * (self.type.size - 1) + self.type.bits
        last_bit = self.bit + bit_size
        downshift = self.type.size * 8 - last_bit
        if bit_size == 1:
            from_exp += f'& 0x{1 << ((self.type.size * 8) - self.bit - 1):02x}'
        else:
            if downshift != 0:
                from_exp += f' >> {downshift}'
            if self.bit != 0:
                from_exp += f'& {1 << bit_size - 1}'

        # determine if we need to cast
        if self.type.name.startswith('uint') or \
                self.type.is_alias() and self.type.storage.startswith('uint'):
            return from_exp
        if self.type.name == 'bitArray':
            return from_exp
        if self.type.name == 'bool':
            return f'{from_exp} != 0'
        return f'{self.type.name}({from_exp})'

    def write_unmarshal_arr(self, w, reslice: bool, var: str, pos: int):
        """Writes unmarshaling code for an array type."""
        if self.length > 0 and self.type.name != 'string':
            w.write(f'{var} = make([]{self.type.name}, {self.length})')
            data = f'data[{pos + 2}:]' if pos else 'data'
            if self.type.name == 'byte':
                w.write(f'copy({var}, {data})')
            else:
                with w.block(f'for i := 0; i < {self.length}; i++'):
                    w.write(f'{var}[i] = {self.value("i")}')
            return

        typ = '[]' + self.type.name  # used in error strings
        if pos == 0:
            length = f'int(binary.BigEndian.Uint16(data))'
        else:
            length = f'int(binary.BigEndian.Uint16(data[{pos}:]))'
        data = f'data[{pos + 2}:]'

        if self.type.name == 'bitArray':
            typ = 'bit array'
            length += '&7'
        elif self.type.name == 'string':
            typ = 'string'

        sz = self.type.size
        mul = f'*{sz}' if sz != 1 else ''

        # this check casts to int64 to prevent overflow issues
        with w.condition(f'arrLen := {length}; int64(arrLen){mul} > int64(len({data}))'):
            w.reterr(f'{self.name} ({typ}) declares it has %d{mul} bytes, '
                     f'but only %d bytes are available', ['arrLen', f'len({data})'])
            w.ifelse('arrLen != 0')

            if self.type.name == 'string':
                w.write(f'{var} = string(data[{pos + 2}:arrLen+{pos + 2}])')
                if reslice:
                    w.write(f'data = data[arrLen+{pos + 2}:]')
                return

            if self.type.name == 'bitArray':
                w.write(f'{var} = make([]byte, arrLen)')
            else:
                w.write(f'{var} = make([]{self.type.name}, arrLen)')

            if self.type.name == 'byte':
                w.write(f'copy({var}, {data})')
            elif self.type.size == 1:
                if self.type.is_alias():
                    w.write(f'copy({var}, {data})')
                else:
                    with w.block(f'for i := 0; i < arrLen; i++'):
                        w.write(f'{var}[i] = {self.value("i")}')
            else:
                with w.block(f'for i, pos := 0, {pos + 2}; i < arrLen; i, pos = i+1, pos+{sz}'):
                    w.write(f'{var}[i] = {self.value("pos")}')

            if reslice:
                w.write(f'data = data[arrLen{mul}+{pos + 2}:]')

    def write_unmarshal(self, w, reslice: bool, prefix: str = 'pt', pos: int = 0):
        """Outputs Go code to unmarshal this fields.
        If is_last is False and this is not a fixed size type,
        it'll writes an expression to reslice the data.
        """
        if self.padding:
            if reslice:
                w.write(f'data = data[{pos + self.min_size}:]')
            return

        var = self.var_name(prefix)
        if self.is_fixed_size() and not self.is_array:
            w.write(f'{var} = {self.value(pos)}')
            if reslice:
                w.write(f'data = data[{pos + self.min_size}:]')
            return

        if self.length >= 0:
            self.write_unmarshal_arr(w, reslice, var, pos)
            return

        # consume the rest of the data
        data, d_len = 'data', 'len(data)'
        if pos > 0:
            data = f'data[{pos}:]'
            d_len = f'len(data)-{pos}'

        with w.condition(f'{d_len} == 0'):
            w.write('return nil')
        w.write(f'{var} = make([]byte, {d_len})')
        w.write(f'copy({var}, {data})\n')
        if reslice:
            w.write(f'data = data[{pos + self.min_size}:]')


@dataclass
class ParamSpec:
    """ParamSpec specifies the parameters permitted in a certain context,
    and under what conditions."""
    name: str  # name used for a struct; may be omitted from yaml to use the parameter name
    param_name: str  # name of an LLRP parameter type
    optional: bool = False  # parameter is "0-1" or "0-n"
    repeatable: bool = False  # parameter is "0-n" or "1-n"
    air_protocol: Optional[str] = None  # if this parameter is tied to a specific air protocol...
    p_def: 'Container' = None  # parameter definition; set after parameters are read
    group: Optional[str] = None  # groups are mutually exclusive, unless named 'mixed'
    version: Optional[int] = 1

    def is_fixed_size(self) -> bool:
        """Returns true if this parameter is always a fixed size."""
        return self.p_def.fixed_size and not (self.optional or self.repeatable)

    @classmethod
    def from_yaml(cls, y: YML) -> 'ParamSpec':
        if 'type' not in y:
            raise MissingPropError(['type'], y)
        y['name'] = y.get('name', y['type'])
        y['param_name'] = y['type']
        if 'airProtocol' in y:
            y['air_protocol'] = y['airProtocol']
            del y['airProtocol']
        del y['type']
        return ParamSpec(**y)

    def struct_field(self) -> str:
        if self.repeatable:
            return f'{self.name} []{self.p_def.type_name}'
        return ''

    def tlv_len_check(self, w: GoWriter):
        w.write('subLen := binary.BigEndian.Uint16(data[2:])')
        with w.condition('int(subLen) > len(data)'):
            w.reterr(f'Param{self.param_name} '
                     'says it has %d bytes,\n but only %d bytes remain',
                     ['subLen', 'len(data)'])


def one_of(w: GoWriter, *params):
    tvs = [p.p_def.header_size == 1 for p in params]
    tlvs = [p.p_def.header_size == 4 for p in params]

    with w.condition(f'len(data) < 4'):
        w.reterr(f'need 4 bytes for a TLV header, but only %d bytes remain', ['len(data)'])

    w.write('subLen := int(binary.BigEndian.Uint16(data[2:])')
    w.write('switch subType := ParamType(binary.BigEndian.Uint16(data)) {')
    for p in params:
        w.write(f'case Param{p.param_name}:')
        w.indent()

        w.dedent()


@dataclass
class Container:
    """Container mostly represents Parameters, but Messages are nearly identical,
    so it serves double duty."""
    name: str
    type_id: int  # message or parameter number
    short: str  # string to use as method receivers

    fields: List[FieldSpec] = dataclasses.field(default_factory=list)
    parameters: List[ParamSpec] = dataclasses.field(default_factory=list)

    # derived properties
    fixed_size: bool = False  # true if no variable length fields/optional or repeatable parameters
    min_size: int = 0  # minimum required size (incl. header); absolute size if fixed_size is True
    header_size: int = 0  # only set for Parameters, not Messages
    has_required: bool = False  # true if has required parameters

    description: Optional[str] = None

    @classmethod
    def from_yaml(cls, y, types: Dict[str, DataType]) -> 'Container':
        missing = [req for req in ('name', 'typeID') if req not in y]
        if any(missing):
            raise ValueError(f'definition missing {missing}: {y}')

        y['short'] = y.get('short', 'p')
        y['type_id'] = y['typeID']
        del y['typeID']

        try:
            fields = [FieldSpec.from_yaml(f, types) for f in y['fields']]
            y['fields'] = fields
        except KeyError:
            y['fields'] = []
            pass

        try:
            parameters = [ParamSpec.from_yaml(s) for s in y['parameters']]
            y['parameters'] = parameters
        except KeyError:
            y['parameters'] = []
            pass

        return cls(**y)

    @property
    def type_name(self) -> str:
        """Returns the Go type name."""
        return GoWriter.lower_camel(self.name)

    def can_inline(self) -> bool:
        """Returns False if this must be a struct."""
        return (len(self.fields) == 1 and len(self.parameters) == 0
                and not self.fields[0].is_array and self.fields[0].is_fixed_size())

    def write_struct(self, w):
        """Write the Parameter as a Go struct."""
        if self.can_inline():
            f = self.fields[0]
            if f.type.name == 'bitArray':
                typ = '[]byte'
            else:
                typ = f'{"[]" if f.is_array else ""}{f.type.name}'
            w.write(f'type {self.type_name} {typ}')
            return

        if self.empty():
            w.write(f'type {self.type_name} struct {{}}\n')
            return

        with w.block(f'type {self.type_name} struct'):
            for f in self.fields:
                if f.padding:
                    continue
                if f.description:
                    w.write(f'// {f.description.strip()}')
                w.write(f.struct_field())

            for p in self.parameters:
                if p.repeatable:
                    w.write(f'{p.name} []{p.p_def.type_name}')
                elif p.optional:
                    w.write(f'{p.name} *{p.p_def.type_name}')
                else:
                    w.write(f'{p.name} {p.p_def.type_name}')

    def should_check_leftover(self) -> bool:
        """Returns True if after unmarshaling, we should check for remaining data."""
        if self.fixed_size:
            return False
        if self.fields and not self.parameters and self.fields[-1].length >= 0:
            return True
        return False

    def write_marshal(self, w):
        with w.block(f'func ({self.short} *{self.type_name}) writeBinary(w io.Writer) error'):
            self.write_marshal_body(w)
            w.write('return nil')

    def write_marshal_body(self, w):
        pass

    def write_unmarshal(self, w):
        with w.block(f'func ({self.short} *{self.type_name}) UnmarshalBinary(data []byte) error'):
            self.write_unmarshal_body(w)

            if self.should_check_leftover():
                with w.condition('len(data) > 0'):
                    w.reterr(f'finished reading {self.name}, '
                             'but an unexpected %d bytes remain', ['len(data)'])
            w.write('return nil')

    def empty(self) -> bool:
        """Returns True if this doesn't have any fields or parameters."""
        return not (any(self.fields) or any(self.parameters))

    @property
    def const_name(self) -> str:
        return f'Param{self.name}'

    def len_check(self, w) -> int:
        sz = self.min_size - self.header_size
        fx = str(self.fixed_size).lower()
        if sz == 0:
            if self.empty():
                w.err_check(f'hasEnoughBytes({self.const_name}, {sz}, len(data), {fx})')
            else:
                w.comment(f'{self.const_name} can be empty')
        else:
            w.err_check(f'hasEnoughBytes({self.const_name}, {sz}, len(data), {fx})')
        return sz

    def write_unmarshal_body(self, w):
        # byte length check
        known_data_len = self.len_check(w)

        # field unmarshaling
        pos = 0
        if self.can_inline():
            assert len(self.fields) == 1
            f = self.fields[0]
            w.write(f'*{self.short} = {self.type_name}({f.value()})')
        elif any(self.fields):
            for i, f in enumerate(self.fields):
                # skip reslice if this is a fixed size field,
                # or if it's the final item (i.e., last field & no params)
                reslice = ((not f.is_fixed_size()) or
                           (i == len(self.fields) - 1 and any(self.parameters)))
                f.write_unmarshal(w, reslice, self.short, pos)
                if reslice:
                    pos = 0
                elif not f.partial:
                    pos += f.min_size

                if not f.is_fixed_size():
                    known_data_len = 0
                elif not f.partial:
                    known_data_len -= f.min_size

        if not any(self.parameters):
            return

        # parameters/sub-parameters
        w.comment('sub-parameters')

        required = {p.name for p in self.parameters if not p.optional}

        groups = groupby(self.parameters, lambda x: (x.optional, x.repeatable, x.group))
        for i, ((optional, repeatable, g_name), p_group) in enumerate(groups):
            # w.comment(f'known data length: {known_data_len}')
            p_group: List[ParamSpec] = list(p_group)

            req_len = 0 if optional else min(p.p_def.min_size for p in p_group)
            if optional and not any(required):
                with w.condition(f'len(data) == 0'):
                    w.write('return nil')
            elif known_data_len < req_len:
                w.err_check(f'hasEnoughBytes({self.const_name}, {req_len}, len(data), false)')
                known_data_len = req_len

            required.difference_update(p.name for p in p_group)

            # simple path: there's only a single parameter, or all in p_group are required
            if len(p_group) == 1 or (g_name is None and not (optional or repeatable)):
                for p in p_group:
                    sub: 'Container' = p.p_def
                    if self.fixed_size:
                        assert sub.min_size <= known_data_len, f'{self.name}.{sub.name}: {sub.min_size} > {known_data_len}'

                    known_data_len = sub.header_len_check(w, known_data_len)

                    if sub.header_size == 1:
                        self.unmarshal_tv(w, p)
                    else:
                        self.unmarshal_tlv(w, p)

                    if sub.fixed_size:
                        known_data_len -= sub.min_size
                    else:
                        known_data_len = 0
                continue

            # otherwise, the next parameter is one of a collection of
            # repeatable, optional, intermixed, or mutually-exclusive parameters
            mut_excl = not (optional or repeatable)

            tvs = [p for p in p_group if p.p_def.header_size == 1]
            tlvs = [p for p in p_group if p.p_def.header_size == 4]
            mixed = bool(tvs and tlvs)

            blk = ''
            if not mut_excl:
                w.noindent(f'\nparamGroup{i}:')
                blk = f'for len(data) > {1 if any(tvs) else 4}'

            def default_case(w: GoWriter):
                if optional or repeatable:
                    w.write(f'break paramGroup{i}')
                else:
                    w.reterr('unexpected parameter %v when unmarshaling '
                             f'Param{self.name}', ['pt'])

            with w.block(blk):
                if mixed:
                    # special weirdness: the next param could be a single byte TV
                    # or it could be a TLV with a 4 byte header,
                    # so we have to check how much data is available
                    w.write('var pt ParamType')
                    with w.condition('data[0]&0x80 == 1'):
                        w.write('// TV parameter')
                        w.write('pt = ParamType(data[0])')
                        w.ifelse('len(data) < 4')
                        w.reterr('expecting a TLV header, but %d < 4 byte remain', ['len(data)'])
                        w.ifelse()
                        w.write('pt = ParamType(binary.BigEndian.Uint16(data))')
                elif tvs:
                    w.write('pt := ParamType(data[0])')
                else:
                    w.write(f'pt := ParamType(binary.BigEndian.Uint16(data))')
                    if not mut_excl:
                        w.write('subLen := binary.BigEndian.Uint16(data[2:])')
                        with w.condition('int(subLen) > len(data)'):
                            w.reterr(f'%v says it has %d bytes,\n but only %d bytes remain',
                                     ['pt', 'subLen', 'len(data)'])

                with w.switch('pt'):
                    self.write_cases(w, p_group, check_len=mixed, default=default_case)

                if blk == '':
                    w.write(f'data = data[{req_len}:]')
                    known_data_len -= req_len
                    continue
                if tlvs and not tvs:
                    w.write(f'data = data[subLen:]')
                    known_data_len = 0
                if tvs and not tlvs:
                    w.write(f'data = data[{req_len}:]')
                    known_data_len -= req_len

        return

    def unmarshal_tv(self, w: GoWriter, p: ParamSpec):
        sub = p.p_def
        if p.optional:
            blk = w.condition(f'subType := ParamType(data[0]); '
                              f'subType == Param{sub.name}')
        else:
            blk = w.condition(f'subType := ParamType(data[0]); '
                              f'subType != Param{sub.name}')
        with blk:
            if not p.optional:
                w.reterr(f'expected Param{sub.name}, but found %v', ['subType'])
                w.ifelse()
            self.alloc(w, p)
            self.write_unmarshal_sub(w, p)

    def unmarshal_tlv(self, w, p):
        sub = p.p_def
        if p.optional:
            blk = w.condition(f'subType := ParamType(binary.BigEndian.Uint16(data)); '
                              f'subType == Param{sub.name}')
        else:
            blk = w.condition(f'subType := ParamType(binary.BigEndian.Uint16(data)); '
                              f'subType != Param{sub.name}')
        with blk:
            if not p.optional:
                w.reterr(f'expected Param{sub.name}, but found %v', ['subType'])
                w.ifelse()
            sub.sublen_check(w)
            self.alloc(w, p)
            self.write_unmarshal_sub(w, p)
            w.write(f'data = data[subLen:]')

    def write_cases(self, w: GoWriter, p_group: List[ParamSpec], check_len: bool = False,
                    default: Optional[Callable[[GoWriter], None]] = None):
        for p in p_group:
            sub = p.p_def
            with w.case(f'Param{sub.name}'):
                if check_len:
                    sub.sublen_check(w)

                self.alloc(w, p)
                self.write_unmarshal_sub(w, p)

                if check_len:
                    if sub.header_size == 4:
                        w.write(f'data = data[subLen:]')
                    if sub.header_size == 1 and sub.fixed_size:
                        w.write(f'data = data[{sub.min_size}:]')

        if not default:
            return

        with w.case('default'):
            default(w)

    def write_unmarshal_sub(self, w: GoWriter, p: ParamSpec):
        sub = p.p_def
        if sub.fixed_size:
            sub_len = sub.min_size
        else:
            sub_len = 'subLen'
        if p.repeatable:
            w.write(f'tmp := new({sub.type_name})')
            w.err_check(f'tmp.UnmarshalBinary(data[{sub.header_size}:{sub_len}])')
            w.write(f'{self.short}.{p.name} = append({self.short}.{p.name}, *tmp)')
            return

        if sub.can_inline():
            exp = sub.fields[0].value(4)
            if p.optional:
                w.write(f'*', end='')
            w.write(f'{self.short}.{p.name} = {sub.type_name}({exp})')
        else:
            w.err_check(f'{self.short}.{p.name}.UnmarshalBinary(data[{sub.header_size}:{sub_len}])')

    def alloc(self, w: GoWriter, p: ParamSpec):
        if p.optional and not p.repeatable:
            w.write(f'{self.short}.{p.name} = new({p.p_def.type_name})')

    def len_adv(self, w: GoWriter):
        """Write the code to reslice the data array past this parameter.
        If it's a TLV, subLen must be in scope and equal to it's header's claimed length.
        If it's a TV, it must be fixed size."""
        if self.header_size == 1:
            assert self.fixed_size
            w.write(f'data = data[{self.min_size}:]')
        else:
            w.write(f'data = data[subLen:]')

    def header_len_check(self, w: GoWriter, known_len: int = 0) -> int:
        if self.fixed_size and self.min_size > known_len:
            w.err_check(f'hasEnoughBytes({self.const_name}, {self.min_size}, len(data), false)')
            return self.min_size
        elif self.header_size > known_len:
            w.err_check(f'hasEnoughBytes({self.const_name}, {self.header_size}, len(data), false)')
            return self.header_size
        return known_len

    def sublen_check(self, w: GoWriter):
        """Write a check that ensures there's at least as many bytes as the header claims.
        Only applies to TLVs; TVs simply return without writing anything."""
        if self.header_size == 1:
            return
        w.write('subLen := binary.BigEndian.Uint16(data[2:])')
        with w.condition('int(subLen) > len(data)'):
            w.reterr(f'{self.const_name} '
                     'says it has %d bytes,\n but only %d bytes remain',
                     ['subLen', 'len(data)'])


@dataclass
class Message(Container):
    """Overrides Container with things that Messages actually do differently than Parameters."""
    response_to: Optional[int] = None  # id of the message this is a response to

    @classmethod
    def from_yaml(cls, y, types: Dict[str, DataType]) -> 'Message':
        try:
            response_to = y['responseTo']
            del y['responseTo']
        except KeyError:
            response_to = None

        y['short'] = y.get('short', 'm')  # change the name of the method receiver
        # noinspection PyTypeChecker
        m: Message = super(Message, cls).from_yaml(y, types)
        m.response_to = response_to
        return m

    def can_inline(self) -> bool:
        return False  # never inline messages

    @property
    def const_name(self) -> str:
        return self.name

    def len_check(self, w) -> int:
        if self.empty():
            w.comment(f'{self.const_name} is a header-only message')
            with w.condition('len(data) > 0'):
                w.reterr(f'{self.const_name} should be empty, but has %d bytes', ['len(data)'])
            w.write('return nil')
            return 0

        if self.fixed_size:
            with w.condition(f'len(data) == {self.min_size}'):
                w.reterr(f'{self.const_name} should length should be exactly {self.min_size}, '
                         f'but is %d', ['len(data)'])
        else:
            with w.condition(f'len(data) < {self.min_size}'):
                w.reterr(f'{self.const_name} length should be at least {self.min_size}, '
                         f'but is %d', ['len(data)'])
        return self.min_size if self.min_size is not None else 0

    def write_unmarshal(self, w):
        if any(self.fields) or any(self.parameters):
            super().write_unmarshal(w)
            return

        with w.block(f'func ({self.short} *{self.type_name}) UnmarshalBinary(data []byte) error'):
            w.comment(f'{self.name} is a header-only message')
            with w.condition('len(data) > 0'):
                w.reterr(f'{self.name} should be empty, but has %d bytes', ['len(data)'])
            w.write('return nil')


def load_data(definitions: YML) -> (Dict[str, DataType], Dict[str, Container], Dict[str, Message]):
    """Read the YAML definitions to build the object graph."""

    # predefine some types
    types: Dict[str, DataType] = {
        'string':   DataType('string', '[]byte', kind='external', size=1,
                             description="strings in LLRP are UTF-8 values "
                                         "starting with uint16 byte-length header"),
        'bitArray': DataType('bitArray', '[]byte', kind='external', size=1,
                             description="bitArrays in LLRP are a series of bits, "
                                         "starting with a uint16 indicating number of bits, "
                                         "padded with 0s (as LSBs) to an octet boundary."),
        'bool':     DataType('bool', 'bool', kind='external', size=1, bits=1),
        'uint8':    DataType('uint8', 'uint8', kind='external', size=1),
        'byte':     DataType('byte', 'byte', kind='external', size=1),
        'uint16':   DataType('uint16', 'uint16', kind='external', size=2),
        'uint32':   DataType('uint32', 'uint32', kind='external', size=4),
        'uint64':   DataType('uint64', 'uint64', kind='external', size=8),
        'int8':     DataType('int8', 'int8', kind='external', size=1),
        'int16':    DataType('int16', 'int16', kind='external', size=2),
        'int32':    DataType('int32', 'int32', kind='external', size=4),
        'int64':    DataType('int64', 'int64', kind='external', size=8),
    }

    parameters: Dict[str, Container] = {}

    messages: Dict[str, Message] = {}

    for y in definitions['types']:
        dt = DataType.from_yaml(y)
        if dt.name in types:
            raise DuplicateDefError('type', dt.name, dt, types[dt.name], y)
        types[dt.name] = dt

    for y in definitions['parameters']:
        p = Container.from_yaml(y, types)
        if p.name in parameters:
            raise DuplicateDefError(f'parameter', p.name, p, parameters[p.name], y)
        parameters[p.name] = p

    for y in definitions['messages']:
        m = Message.from_yaml(y, types)
        if m.name in messages:
            raise DuplicateDefError(f'message', m.name, m, messages[m.name], y)
        messages[m.name] = m

    return types, parameters, messages


def set_param_sizes(params: Dict[str, Container]):
    """Determine the min sizes of the parameters,
    i.e., the sum of their fields' min sizes
    plus the sum of required parameters' min sizes,
    plus the parameter's header, which varies depending on its type.
    Determine if the parameter's size is in fact fixed."""
    param_sizes: Dict[str, int] = {}  # for handling parameters cycles

    def get_param_size(p: Container) -> int:
        if p.name in param_sizes:
            return param_sizes[p.name]
        param_sizes[p.name] = p.header_size

        p.min_size = (p.header_size +
                      sum(f.min_size for f in p.fields) -
                      sum(f.min_size for f in p.fields if f.partial))
        for (opt, g), p_group in groupby(p.parameters, key=lambda x: (x.optional, x.group)):
            if opt:  # skip optional groups
                for sp in p_group:
                    get_param_size(sp.p_def)
                continue
            p.min_size += min(get_param_size(sp.p_def) for sp in p_group)

        # because of the get_param_size call above, sub-parameter's fixed_size is set
        p.fixed_size = (all(f.is_fixed_size() for f in p.fields) and
                        all(sub.is_fixed_size() for sub in p.parameters))

        param_sizes[p.name] = p.min_size
        return p.min_size

    for p in params.values():
        p.header_size = 1 if p.type_id < 128 else 4
        for sub in p.parameters:
            try:
                sub.p_def = params[sub.param_name]
            except KeyError:
                raise MissingParamError(p, sub)

    for p in params.values():
        get_param_size(p)
        p.has_required = any(sp for sp in p.parameters if not sp.optional)


def set_msg_sizes(msgs: Dict[str, Message], params: Dict[str, Container]):
    """Set messages min sizes to the sum of their fields' min sizes
    plus the sum of required parameters' min sizes.
    Note that this doesn't include the message header."""

    for m in msgs.values():
        for p in m.parameters:
            try:
                p.p_def = params[p.param_name]
            except KeyError:
                raise MissingParamError(m, p)

        m.min_size = (sum(f.min_size for f in m.fields) -
                      sum(f.min_size for f in m.fields if f.partial) +
                      sum(p.p_def.min_size for p in m.parameters if not p.optional))
        m.fixed_size = (all(f.is_fixed_size() for f in m.fields) and
                        all(sub.is_fixed_size() for sub in m.parameters))
        m.has_required = any(sp.optional for sp in m.parameters)


def write_unmarshal_code(w, types, parameters, messages):
    w.write(f'// Code generated by "{" ".join(sys.argv)}"; DO NOT EDIT.\n')
    w.write('package llrp\n\n')

    with w.paren('import'):
        w.write('"encoding/binary"')
        w.write('"github.com/pkg/errors"')

    for t in types.values():
        t.write_type_def(w)

    w.comment("hasEnoughBytes returns an error if there aren't "
              "enough bytes to read the parameter.")
    with w.block('func hasEnoughBytes(pt ParamType, needed, got int, exact bool) error'):
        with w.condition('needed <= got'):
            w.write('return nil')
        with w.condition('exact && needed == 0'):
            w.reterr('%v must be empty, but received %d byte(s)', ['pt', 'got'])
            w.ifelse('exact')
            w.reterr('%v requires exactly %d byte(s), but received %d', ['pt', 'needed', 'got'])
        w.reterr('%v requires at least %d byte(s), but received %d', ['pt', 'needed', 'got'])

    w.write('')
    for m in messages.values():
        w.write(f'// {m.type_name} is Message {m.type_id}, {m.name}.')
        if m.description:
            w.write('//')
            w.comment(m.description)

        m.write_struct(w)

        w.write(f'// UnmarshalBinary Message {m.type_id}, {m.name}.')
        m.write_unmarshal(w)

    for p in parameters.values():
        if p.type_id == 0:
            continue

        w.write(f'// {p.type_name} is Parameter {p.type_id}, {p.name}.')
        if p.description:
            w.write('//')
            w.comment(p.description)

        p.write_struct(w)

        w.write(f'// UnmarshalBinary Parameter {p.type_id}, {p.name}.')
        p.write_unmarshal(w)


def main():
    import sys
    import argparse

    parser = argparse.ArgumentParser(
        description='A python script to read a YAML description '
                    'of binary LLRP messages to generate Go code '
                    'to convert them into JSON'
    )
    parser.add_argument('-i', '--input', help='input file (default: STDIN)',
                        type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument('-o', '--output', help='output file (default: STDOUT)',
                        type=argparse.FileType('w'), default=sys.stdout)

    parser.add_argument('--parameter', help='output only specific parameters',
                        action='append')

    args = parser.parse_args()

    definitions = yaml.safe_load(args.input)
    types, parameters, messages = load_data(definitions)
    set_param_sizes(parameters)
    set_msg_sizes(messages, parameters)

    w = GoWriter(args.output)

    if args.parameter:
        for p_name in args.parameter:
            parameters[p_name].write_unmarshal(w)
        return

    write_unmarshal_code(w, types, parameters, messages)


if __name__ == '__main__':
    try:
        main()
    except DefinitionError as e:
        print(e.yml)
        raise
    except MissingParamError as e:
        print(e.parent)
        print(e.decl)
        raise
