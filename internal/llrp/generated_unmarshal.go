//
// Copyright (C) 2020 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by "generate_param_code.py -i messages.yaml --test-file=binary_test.go --marshal-file=generated_marshal.go --unmarshal-file=generated_unmarshal.go --encode-file=generated_encoder.go"; DO NOT EDIT.
package llrp

import (
	"encoding/binary"
	"github.com/pkg/errors"
)

// dBm16 is a 16-bit dBm value. In LLRP, it's used for maximum receive
// sensitivity.
type dBm16 = int16

// dBm8 is a 8-bit dBm value. In LLRP, it's used to represent RSSI.
type dBm8 = int8

// dBiX100 is dBi*100, i.e., 0.01dBi or 1 millibel. In LLRP, it's used
// for fractional dBi antenna gain values.
type dBiX100 = uint16

// dBmX100 is dBm*100, i.e., 0.01dBm or 1 millibel milliwatt. In LLRP,
// it's used primarily for fractional dBm transmit power values.
type dBmX100 = uint16

// dB or decibel is 1/10 of a bel, which is the either the log10 of
// the ratio of a power quantity relative a reference, or 2*log10 of
// the ratio of an amplitude quantity relative a reference field.  In
// LLRP, it's used primarily for receive sensitivity values relative
// the device maximum sensitivity.
type dB = uint16

// microSecs64 is a 64-bit number of microseconds.  It's usually used
// to represent a time offset since a known reference, Unix Epoch or
// the reader's start.
type microSecs64 = uint64

// microSecs64 is a 32-bit number of milliseconds.  It's used to
// represent a time offset since a known reference, usually Unix Epoch
// or a message receipt time. Other times, it's used as a time period
// or timeout, in which case 0 may mean "never timeout".
type milliSecs32 = uint32

// milliSecs16 is a 16-bit number of milliseconds.  It's used to
// represent a timeouts or duration triggers.
type milliSecs16 = uint16

// nanoSecs32 is a 32-bit number of nanoseconds used for some Tari
// values.
type nanoSecs32 = uint32

// nanoSecs16 is a 16-bit number of nanoseconds used for some Tari
// values or for RF Control.
type nanoSecs16 = uint16

// kHz is kilo-Hertz, used for frequency values.
type kHz = uint32

// bps is bits per second, used in backscatter data rates.
type bps = uint32

// C1G2MemoryBankType selection.
type C1G2MemoryBankType = uint8
type C1G2BlockPermalockResultType uint8

const (
	C1G2BPLockSuccess                = C1G2BlockPermalockResultType(0)
	C1G2BPLockInsufficientPower      = C1G2BlockPermalockResultType(1)
	C1G2BPLockNonSpecificTagError    = C1G2BlockPermalockResultType(2)
	C1G2BPLockNoResponseFromTag      = C1G2BlockPermalockResultType(3)
	C1G2BPLockNonSpecificReaderError = C1G2BlockPermalockResultType(4)
	C1G2BPLockIncorrectPassword      = C1G2BlockPermalockResultType(5)
	C1G2BPLockMemoryOverrun          = C1G2BlockPermalockResultType(6)
)

// AirProtocolIDType defines the air protocols LLRP supports for
// accessing tags.  The air protocol determines how tags are sigulated
// and access operations performed, affects which parameters are
// permitted in certain contexts, and in theory can vary per antenna.
// In practice, however, there's only ever been a single one defined,
// and the standard hasn't been updated in ten years.
type AirProtocolIDType uint8

const (
	AirProtoUnspecified         = AirProtocolIDType(0)
	AirProtoEPCGlobalClass1Gen2 = AirProtocolIDType(1)
)

// CountryCodeType is an ISO-3166 country code.
type CountryCodeType uint16
type C1G2ReadOpSpecResultType uint8
type LockDataType uint8
type C1G2TagInventoryTargetType uint8
type C1G2SingulationControlSessionType uint8
type C1G2TagInventoryStateAwareFilterActionType uint8
type C1G2TagInventoryStateUnawareFilterActionType uint8
type ROSpecCurrentStateType uint8

const (
	ROSpecStateDisabled = ROSpecCurrentStateType(0)
	ROSpecStateInactive = ROSpecCurrentStateType(1)
	ROSpecStateActive   = ROSpecCurrentStateType(2)
)

type AccessSpecStopTriggerType uint8

const (
	AccessSpecStopTriggerNone           = AccessSpecStopTriggerType(0)
	AccessSpecStopTriggerOperationCount = AccessSpecStopTriggerType(1)
)

type ReaderEventType uint16
type AntennaEventType uint8
type ConnectionAttemptEventType uint16

const (
	ConnSuccess               = ConnectionAttemptEventType(0)
	ConnExistsReaderInitiated = ConnectionAttemptEventType(1)
	ConnExistsClientInitiated = ConnectionAttemptEventType(2)
	ConnFailedReasonUnknown   = ConnectionAttemptEventType(3)
	ConnAttemptedAgain        = ConnectionAttemptEventType(4)
)

type ROSpecEventType uint8
type AISpecEventType uint8
type RFSurveyEventType uint8
type KeepAliveTriggerType uint8

const (
	KATriggerNone     = KeepAliveTriggerType(0)
	KATriggerPeriodic = KeepAliveTriggerType(1)
)

type AccessReportTriggerType uint8
type ROReportTriggerType uint8
type ROSpecStartTriggerType uint8

const (
	ROStartTriggerNone      = ROSpecStartTriggerType(0)
	ROStartTriggerImmediate = ROSpecStartTriggerType(1)
	ROStartTriggerPeriodic  = ROSpecStartTriggerType(2)
	ROStartTriggerGPI       = ROSpecStartTriggerType(3)
)

type ROSpecStopTriggerType uint8

const (
	ROStopTriggerNone     = ROSpecStopTriggerType(0)
	ROStopTriggerDuration = ROSpecStopTriggerType(1)
	ROStopTriggerGPI      = ROSpecStopTriggerType(2)
)

type RFSurveySpecStopTriggerType uint8

const (
	RFSurveyStopTriggerNone       = RFSurveySpecStopTriggerType(0)
	RFSurveyStopTriggerDuration   = RFSurveySpecStopTriggerType(1)
	RFSurveyStopTriggerNIteration = RFSurveySpecStopTriggerType(2)
)

type AISpecStopTriggerType uint8

const (
	AIStopTriggerNone           = AISpecStopTriggerType(0)
	AIStopTriggerDuration       = AISpecStopTriggerType(1)
	AIStopTriggerGPI            = AISpecStopTriggerType(2)
	AIStopTriggerTagObservation = AISpecStopTriggerType(3)
)

type TagObservationTriggerType uint8

const (
	TagObsTriggerNTagObservations    = TagObservationTriggerType(0)
	TagObsTriggerNoNewAfterT         = TagObservationTriggerType(1)
	TagObsTriggerNAttempts           = TagObservationTriggerType(2)
	TagObsTriggerNUniqueObservations = TagObservationTriggerType(3)
	TagObsTriggerNoUniqueAfterT      = TagObservationTriggerType(4)
)

type SpectralMaskType uint8
type C1G2RecommissionResultType uint8
type C1G2WriteOpSpecResultType uint8
type IDType uint8

const (
	IDMAC_EUI64 = IDType(0)
	IDEPC       = IDType(1)
)

type C1G2KillResultType uint8
type C1G2LockResultType uint8
type ModulationType uint8
type C1G2BlockEraseResultType uint8
type GPIStateType uint8

const (
	GPIStateLow     = GPIStateType(0)
	GPIStateHigh    = GPIStateType(1)
	GPIStateUnknown = GPIStateType(2)
)

type ForwardLinkModulationType uint8
type LockPrivilegeType uint8
type C1G2GetBlockPermalockStatusResultType uint8
type C1G2BlockWriteResultType uint8
type C1G2FilterActionType uint8

// VersionNum corresponds to an LLRP version number.  The version
// number is 3 bits and embedded in each message sent between a Reader
// and Client.  By default, this package will attempt to establish
// connection with Readers using the higher version it knows, but you
// can explicitly override it when creating a connection. In either
// case, for versions greater than 1.0.1, the Client will negotiate
// versions with the Reader and downgrade if necessary.
type VersionNum uint8

const (
	versionUnknown = VersionNum(0)
	Version1_0_1   = VersionNum(1)
	Version1_1     = VersionNum(2)
)

// StatusCode matches LLRP's Status Codes.  These are described in
// Section 14 of the Low Level Reader Protocol v1.0.1 and in Section
// 15 of Low Level Reader Protocol v1.1.
type StatusCode uint16

const (
	StatusSuccess               = StatusCode(0)
	StatusMsgParamError         = StatusCode(100)
	StatusMsgFieldError         = StatusCode(101)
	StatusMsgParamUnexpected    = StatusCode(102)
	StatusMsgParamMissing       = StatusCode(103)
	StatusMsgParamDuplicate     = StatusCode(104)
	StatusMsgParamOverflow      = StatusCode(105)
	StatusMsgFieldOverflow      = StatusCode(106)
	StatusMsgParamUnknown       = StatusCode(107)
	StatusMsgFieldUnknown       = StatusCode(108)
	StatusMsgMsgUnsupported     = StatusCode(109)
	StatusMsgVerUnsupported     = StatusCode(110)
	StatusMsgParamUnsupported   = StatusCode(111)
	StatusMsgMsgUnexpected      = StatusCode(112)
	StatusParamParamError       = StatusCode(200)
	StatusParamFieldError       = StatusCode(201)
	StatusParamParamUnexpected  = StatusCode(202)
	StatusParamParamMissing     = StatusCode(203)
	StatusParamParamDuplicate   = StatusCode(204)
	StatusParamParamOverflow    = StatusCode(205)
	StatusParamFieldOverflow    = StatusCode(206)
	StatusParamParamUnknown     = StatusCode(207)
	StatusParamFieldUnknown     = StatusCode(208)
	StatusParamParamUnsupported = StatusCode(209)
	StatusFieldInvalid          = StatusCode(300)
	StatusFieldOutOfRange       = StatusCode(301)
	StatusDeviceError           = StatusCode(401)
)

type ReaderCapabilitiesRequestedDataType uint8

const (
	ReaderCapAll                         = ReaderCapabilitiesRequestedDataType(0)
	ReaderCapGeneralDeviceCapabilities   = ReaderCapabilitiesRequestedDataType(1)
	ReaderCapLLRPCapabilities            = ReaderCapabilitiesRequestedDataType(2)
	ReaderCapRegulatorCapabilities       = ReaderCapabilitiesRequestedDataType(3)
	ReaderCapAirProtocolLLRPCapabilities = ReaderCapabilitiesRequestedDataType(4)
)

type ReaderConfigRequestedDataType uint8

const (
	ReaderConfReqAll                  = ReaderConfigRequestedDataType(0)
	ReaderConfReqIdentification       = ReaderConfigRequestedDataType(1)
	ReaderConfReqAntennaProperties    = ReaderConfigRequestedDataType(2)
	ReaderConfReqAntennaConfig        = ReaderConfigRequestedDataType(3)
	ReaderConfReqROReportSpec         = ReaderConfigRequestedDataType(4)
	ReaderConfReqReaderEventNotifSpec = ReaderConfigRequestedDataType(5)
	ReaderConfReqAccessReportSpec     = ReaderConfigRequestedDataType(6)
	ReaderConfReqLLRPConfStateVal     = ReaderConfigRequestedDataType(7)
	ReaderConfReqKeepAliveSpec        = ReaderConfigRequestedDataType(8)
	ReaderConfReqGPIPortCurState      = ReaderConfigRequestedDataType(9)
	ReaderConfReqGPOWriteData         = ReaderConfigRequestedDataType(10)
	ReaderConfReqEventsAndReports     = ReaderConfigRequestedDataType(11)
)

type GPITriggerFlags uint8

const GPIEvent = GPITriggerFlags(1 << 7)

type GPIPortConfigFlags uint8
type GPOWriteFlags uint8

const GPOPinTargetState = GPOWriteFlags(1 << 7)

type C1G2TagInventoryStateAwareSingulationActionFlags uint8
type GPIEventFlags uint8
type AntennaPropertiesFlags uint8

const AntennaConnected = AntennaPropertiesFlags(1 << 7)

type UHFC1G2RFModeFlags uint8
type C1G2EPCMemorySelectorFlags uint8
type EventsandReportsFlags uint8
type AccessSpecFlags uint8
type TagReportContentSelectorFlags uint16
type NotificationStateFlags uint8
type C1G2CapabilitiesFlags uint8
type C1G2RecommissionFlags uint8
type C1G2InventoryCommandFlags uint8
type GeneralCapabilityFlags uint8

const (
	CanSetAntennaProperties = GeneralCapabilityFlags(1 << (7 - iota))
	HasUTCClock
)

type HoppingFlags uint8

const Hopping = HoppingFlags(1 << 7)

type LLRPCapabilitiesFlags uint8

const (
	CanDoRFSurvey = LLRPCapabilitiesFlags(1 << (7 - iota))
	CanReportBufferFillWarning
	SupportsClientRequestOpSpec
	CanDoTagInventoryStateAwareSingulation
	SupportsEventsAndReportHolding
)

// hasEnoughBytes returns an error if there aren't enough bytes to
// read the parameter.
func hasEnoughBytes(pt ParamType, needed, got int, exact bool) error {
	if needed <= got {
		return nil
	}
	if exact && needed == 0 {
		return errors.Errorf("%v must be empty, but received %d byte(s)",
			pt, got)
	} else if exact {
		return errors.Errorf("%v requires exactly %d byte(s), but received "+
			"%d", pt, needed, got)
	}
	return errors.Errorf("%v requires at least %d byte(s), but received "+
		"%d", pt, needed, got)
}

// getSupportedVersion is Message 46, GetSupportedVersion.
type getSupportedVersion struct{}

// UnmarshalBinary Message 46, GetSupportedVersion.
func (m *getSupportedVersion) UnmarshalBinary(data []byte) error {
	// GetSupportedVersion is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetSupportedVersion should be empty, but has "+
			"%d bytes", len(data))
	}
	return nil
}

// getSupportedVersionResponse is Message 56,
// GetSupportedVersionResponse.
type getSupportedVersionResponse struct {
	CurrentVersion      VersionNum
	MaxSupportedVersion VersionNum
	LLRPStatus          llrpStatus
}

// UnmarshalBinary Message 56, GetSupportedVersionResponse.
func (m *getSupportedVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("GetSupportedVersionResponse length should be "+
			"at least 10, but is %d", len(data))
	}
	m.CurrentVersion = VersionNum(data[0])
	m.MaxSupportedVersion = VersionNum(data[1])
	data = data[2:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetSupportedVersionResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// setProtocolVersion is Message 47, SetProtocolVersion.
type setProtocolVersion struct {
	TargetVersion VersionNum
}

// UnmarshalBinary Message 47, SetProtocolVersion.
func (m *setProtocolVersion) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("SetProtocolVersion should length should be "+
			"exactly 1, but is %d", len(data))
	}
	m.TargetVersion = VersionNum(data[0])
	return nil
}

// setProtocolVersionResponse is Message 57,
// SetProtocolVersionResponse.
type setProtocolVersionResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 57, SetProtocolVersionResponse.
func (m *setProtocolVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("SetProtocolVersionResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetProtocolVersionResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// getReaderCapabilities is Message 1, GetReaderCapabilities.
type getReaderCapabilities struct {
	ReaderCapabilitiesRequestedData ReaderCapabilitiesRequestedDataType
	Custom                          []custom
}

// UnmarshalBinary Message 1, GetReaderCapabilities.
func (m *getReaderCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("GetReaderCapabilities length should be at "+
			"least 1, but is %d", len(data))
	}
	m.ReaderCapabilitiesRequestedData = ReaderCapabilitiesRequestedDataType(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// getReaderCapabilitiesResponse is Message 11,
// GetReaderCapabilitiesResponse.
type getReaderCapabilitiesResponse struct {
	LLRPStatus                llrpStatus
	GeneralDeviceCapabilities *generalDeviceCapabilities
	LLRPCapabilities          *llrpCapabilities
	RegulatoryCapabilities    *regulatoryCapabilities
	C1G2LLRPCapabilities      *c1G2LLRPCapabilities
	Custom                    []custom
}

// UnmarshalBinary Message 11, GetReaderCapabilitiesResponse.
func (m *getReaderCapabilitiesResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetReaderCapabilitiesResponse length should be "+
			"at least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGeneralDeviceCapabilities:
			m.GeneralDeviceCapabilities = new(generalDeviceCapabilities)
			if err := m.GeneralDeviceCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamLLRPCapabilities:
			m.LLRPCapabilities = new(llrpCapabilities)
			if err := m.LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRegulatoryCapabilities:
			m.RegulatoryCapabilities = new(regulatoryCapabilities)
			if err := m.RegulatoryCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2LLRPCapabilities:
			m.C1G2LLRPCapabilities = new(c1G2LLRPCapabilities)
			if err := m.C1G2LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading "+
			"GetReaderCapabilitiesResponse, but an unexpected %d bytes remain",
			len(data))
	}
	return nil
}

// addROSpec is Message 20, AddROSpec.
type addROSpec struct {
	ROSpec roSpec
}

// UnmarshalBinary Message 20, AddROSpec.
func (m *addROSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 19 {
		return errors.Errorf("AddROSpec length should be at least 19, but is "+
			"%d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpec {
		return errors.Errorf("expected ParamROSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpec says it has %d bytes, but only %d "+
				"bytes remain", subLen, len(data))
		}
		if err := m.ROSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddROSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// addROSpecResponse is Message 30, AddROSpecResponse.
type addROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 30, AddROSpecResponse.
func (m *addROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("AddROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// deleteROSpec is Message 21, DeleteROSpec.
type deleteROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 21, DeleteROSpec.
func (m *deleteROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DeleteROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// deleteROSpecResponse is Message 31, DeleteROSpecResponse.
type deleteROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 31, DeleteROSpecResponse.
func (m *deleteROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DeleteROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// startROSpec is Message 22, StartROSpec.
type startROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 22, StartROSpec.
func (m *startROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("StartROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// startROSpecResponse is Message 32, StartROSpecResponse.
type startROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 32, StartROSpecResponse.
func (m *startROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("StartROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading StartROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// stopROSpec is Message 23, StopROSpec.
type stopROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 23, StopROSpec.
func (m *stopROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("StopROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// stopROSpecResponse is Message 33, StopROSpecResponse.
type stopROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 33, StopROSpecResponse.
func (m *stopROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("StopROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading StopROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// enableROSpec is Message 24, EnableROSpec.
type enableROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 24, EnableROSpec.
func (m *enableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("EnableROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// enableROSpecResponse is Message 34, EnableROSpecResponse.
type enableROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 34, EnableROSpecResponse.
func (m *enableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("EnableROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// disableROSpec is Message 25, DisableROSpec.
type disableROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 25, DisableROSpec.
func (m *disableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DisableROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// disableROSpecResponse is Message 35, DisableROSpecResponse.
type disableROSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 35, DisableROSpecResponse.
func (m *disableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DisableROSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// getROSpecs is Message 26, GetROSpecs.
type getROSpecs struct{}

// UnmarshalBinary Message 26, GetROSpecs.
func (m *getROSpecs) UnmarshalBinary(data []byte) error {
	// GetROSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetROSpecs should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// getROSpecsResponse is Message 36, GetROSpecsResponse.
type getROSpecsResponse struct {
	LLRPStatus llrpStatus
	ROSpec     []roSpec
}

// UnmarshalBinary Message 36, GetROSpecsResponse.
func (m *getROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetROSpecsResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROSpec:
			var tmp roSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.ROSpec = append(m.ROSpec, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetROSpecsResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// addAccessSpec is Message 40, AddAccessSpec.
type addAccessSpec struct {
	AccessSpec accessSpec
}

// UnmarshalBinary Message 40, AddAccessSpec.
func (m *addAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 23 {
		return errors.Errorf("AddAccessSpec length should be at least 23, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpec {
		return errors.Errorf("expected ParamAccessSpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.AccessSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddAccessSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// addAccessSpecResponse is Message 50, AddAccessSpecResponse.
type addAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 50, AddAccessSpecResponse.
func (m *addAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("AddAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddAccessSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// deleteAccessSpec is Message 41, DeleteAccessSpec.
type deleteAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 41, DeleteAccessSpec.
func (m *deleteAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DeleteAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// deleteAccessSpecResponse is Message 51, DeleteAccessSpecResponse.
type deleteAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 51, DeleteAccessSpecResponse.
func (m *deleteAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DeleteAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteAccessSpecResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// enableAccessSpec is Message 42, EnableAccessSpec.
type enableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 42, EnableAccessSpec.
func (m *enableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("EnableAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// enableAccessSpecResponse is Message 52, EnableAccessSpecResponse.
type enableAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 52, EnableAccessSpecResponse.
func (m *enableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("EnableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableAccessSpecResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// disableAccessSpec is Message 43, DisableAccessSpec.
type disableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 43, DisableAccessSpec.
func (m *disableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DisableAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// disableAccessSpecResponse is Message 53, DisableAccessSpecResponse.
type disableAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 53, DisableAccessSpecResponse.
func (m *disableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DisableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableAccessSpecResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// getAccessSpecs is Message 44, GetAccessSpecs.
type getAccessSpecs struct{}

// UnmarshalBinary Message 44, GetAccessSpecs.
func (m *getAccessSpecs) UnmarshalBinary(data []byte) error {
	// GetAccessSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetAccessSpecs should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// getAccessSpecsResponse is Message 54, GetAccessSpecsResponse.
type getAccessSpecsResponse struct {
	LLRPStatus llrpStatus
	AccessSpec []accessSpec
}

// UnmarshalBinary Message 54, GetAccessSpecsResponse.
func (m *getAccessSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetAccessSpecsResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAccessSpec:
			var tmp accessSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AccessSpec = append(m.AccessSpec, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetAccessSpecsResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// clientRequestOp is Message 45, ClientRequestOp.
type clientRequestOp struct {
	TagReportData tagReportData
}

// UnmarshalBinary Message 45, ClientRequestOp.
func (m *clientRequestOp) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ClientRequestOp length should be at least 10, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportData {
		return errors.Errorf("expected ParamTagReportData, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportData says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.TagReportData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestOp, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// clientRequestOpResponse is Message 55, ClientRequestOpResponse.
type clientRequestOpResponse struct {
	ClientRequestResponse clientRequestResponse
}

// UnmarshalBinary Message 55, ClientRequestOpResponse.
func (m *clientRequestOpResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return errors.Errorf("ClientRequestOpResponse length should be at "+
			"least 14, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamClientRequestResponse {
		return errors.Errorf("expected ParamClientRequestResponse, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamClientRequestResponse says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := m.ClientRequestResponse.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestOpResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// getReport is Message 60, GetReport.
type getReport struct{}

// UnmarshalBinary Message 60, GetReport.
func (m *getReport) UnmarshalBinary(data []byte) error {
	// GetReport is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetReport should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// roAccessReport is Message 61, ROAccessReport.
type roAccessReport struct {
	TagReportData      []tagReportData
	RFSurveyReportData []rfSurveyReportData
	Custom             []custom
}

// UnmarshalBinary Message 61, ROAccessReport.
func (m *roAccessReport) UnmarshalBinary(data []byte) error {
	if len(data) < 0 {
		return errors.Errorf("ROAccessReport length should be at least 0, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTagReportData:
			var tmp tagReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.TagReportData = append(m.TagReportData, tmp)
		case ParamRFSurveyReportData:
			var tmp rfSurveyReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.RFSurveyReportData = append(m.RFSurveyReportData, tmp)
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROAccessReport, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// keepAlive is Message 62, KeepAlive.
type keepAlive struct{}

// UnmarshalBinary Message 62, KeepAlive.
func (m *keepAlive) UnmarshalBinary(data []byte) error {
	// KeepAlive is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAlive should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// keepAliveACK is Message 72, KeepAliveACK.
type keepAliveACK struct{}

// UnmarshalBinary Message 72, KeepAliveACK.
func (m *keepAliveACK) UnmarshalBinary(data []byte) error {
	// KeepAliveACK is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAliveACK should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// readerEventNotification is Message 63, ReaderEventNotification.
type readerEventNotification struct {
	ReaderEventNotificationData readerEventNotificationData
}

// UnmarshalBinary Message 63, ReaderEventNotification.
func (m *readerEventNotification) UnmarshalBinary(data []byte) error {
	if len(data) < 16 {
		return errors.Errorf("ReaderEventNotification length should be at "+
			"least 16, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamReaderEventNotificationData {
		return errors.Errorf("expected ParamReaderEventNotificationData, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationData says it has "+
				"%d bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := m.ReaderEventNotificationData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotification, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// enableEventsAndReports is Message 64, EnableEventsAndReports.
type enableEventsAndReports struct{}

// UnmarshalBinary Message 64, EnableEventsAndReports.
func (m *enableEventsAndReports) UnmarshalBinary(data []byte) error {
	// EnableEventsAndReports is a header-only message
	if len(data) > 0 {
		return errors.Errorf("EnableEventsAndReports should be empty, but "+
			"has %d bytes", len(data))
	}
	return nil
}

// errorMessage is Message 100, ErrorMessage.
type errorMessage struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 100, ErrorMessage.
func (m *errorMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ErrorMessage length should be at least 8, but "+
			"is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ErrorMessage, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// getReaderConfig is Message 2, GetReaderConfig.
type getReaderConfig struct {
	AntennaID                 uint16
	ReaderConfigRequestedData ReaderConfigRequestedDataType
	GPIPortNum                uint16
	GPOPortNum                uint16
	Custom                    []custom
}

// UnmarshalBinary Message 2, GetReaderConfig.
func (m *getReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("GetReaderConfig length should be at least 7, "+
			"but is %d", len(data))
	}
	m.AntennaID = binary.BigEndian.Uint16(data)
	m.ReaderConfigRequestedData = ReaderConfigRequestedDataType(data[2])
	m.GPIPortNum = binary.BigEndian.Uint16(data[3:])
	m.GPOPortNum = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// getReaderConfigResponse is Message 12, GetReaderConfigResponse.
type getReaderConfigResponse struct {
	LLRPStatus                  llrpStatus
	Identification              *identification
	AntennaProperties           []antennaProperties
	AntennaConfiguration        []antennaConfiguration
	ReaderEventNotificationSpec *readerEventNotificationSpec
	ROReportSpec                *roReportSpec
	AccessReportSpec            *accessReportSpec
	LLRPConfigurationStateValue *llrpConfigurationStateValue
	KeepAliveSpec               *keepAliveSpec
	GPIPortCurrentState         []gpiPortCurrentState
	GPOWriteData                []gpoWriteData
	EventsAndReports            *eventsAndReports
	Custom                      []custom
}

// UnmarshalBinary Message 12, GetReaderConfigResponse.
func (m *getReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetReaderConfigResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamIdentification {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamIdentification says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		m.Identification = new(identification)
		if err := m.Identification.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp antennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfiguration = append(m.AntennaConfiguration, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReaderEventNotificationSpec:
			m.ReaderEventNotificationSpec = new(readerEventNotificationSpec)
			if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROReportSpec:
			m.ROReportSpec = new(roReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			*m.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		case ParamLLRPConfigurationStateValue:
			*m.LLRPConfigurationStateValue = llrpConfigurationStateValue(binary.BigEndian.Uint32(data[4:]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(keepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup4:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPIPortCurrentState:
			var tmp gpiPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentState = append(m.GPIPortCurrentState, tmp)
		case ParamGPOWriteData:
			var tmp gpoWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		default:
			break paramGroup4
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		*m.EventsAndReports = eventsAndReports(data[4]&0x80 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup6:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup6
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderConfigResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// setReaderConfig is Message 3, SetReaderConfig.
type setReaderConfig struct {
	ResetToFactoryDefaults      bool
	ReaderEventNotificationSpec *readerEventNotificationSpec
	AntennaProperties           []antennaProperties
	AntennaConfiguration        []antennaConfiguration
	ROReportSpec                *roReportSpec
	AccessReportSpec            *accessReportSpec
	KeepAliveSpec               *keepAliveSpec
	GPOWriteData                []gpoWriteData
	GPIPortCurrentState         []gpiPortCurrentState
	EventsAndReports            *eventsAndReports
	Custom                      []custom
}

// UnmarshalBinary Message 3, SetReaderConfig.
func (m *setReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("SetReaderConfig length should be at least 1, "+
			"but is %d", len(data))
	}
	m.ResetToFactoryDefaults = data[0]&0x80 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderEventNotificationSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationSpec says it has "+
				"%d bytes, but only %d bytes remain", subLen, len(data))
		}
		m.ReaderEventNotificationSpec = new(readerEventNotificationSpec)
		if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp antennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfiguration = append(m.AntennaConfiguration, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROReportSpec:
			m.ROReportSpec = new(roReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			*m.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(keepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPOWriteData:
			var tmp gpoWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		case ParamGPIPortCurrentState:
			var tmp gpiPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentState = append(m.GPIPortCurrentState, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		*m.EventsAndReports = eventsAndReports(data[4]&0x80 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup5:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup5
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// setReaderConfigResponse is Message 13, SetReaderConfigResponse.
type setReaderConfigResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 13, SetReaderConfigResponse.
func (m *setReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("SetReaderConfigResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetReaderConfigResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// closeConnection is Message 14, CloseConnection.
type closeConnection struct{}

// UnmarshalBinary Message 14, CloseConnection.
func (m *closeConnection) UnmarshalBinary(data []byte) error {
	// CloseConnection is a header-only message
	if len(data) > 0 {
		return errors.Errorf("CloseConnection should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// closeConnectionResponse is Message 4, CloseConnectionResponse.
type closeConnectionResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 4, CloseConnectionResponse.
func (m *closeConnectionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("CloseConnectionResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading CloseConnectionResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// customMessage is Message 1023, CustomMessage.
type customMessage struct {
	VendorID       uint32
	MessageSubtype uint8
	Data           []byte
}

// UnmarshalBinary Message 1023, CustomMessage.
func (m *customMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("CustomMessage length should be at least 5, but "+
			"is %d", len(data))
	}
	m.VendorID = binary.BigEndian.Uint32(data)
	m.MessageSubtype = data[4]
	if len(data)-5 == 0 {
		return nil
	}
	m.Data = make([]byte, len(data)-5)
	copy(m.Data, data[5:])
	data = data[5:]
	return nil
}

// antennaID is Parameter 1, AntennaID.
type antennaID uint16

// UnmarshalBinary Parameter 1, AntennaID.
func (p *antennaID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaID, 2, len(data), true); err != nil {
		return err
	}
	*p = antennaID(binary.BigEndian.Uint16(data))
	return nil
}

// firstSeenUTC is Parameter 2, FirstSeenUTC.
type firstSeenUTC microSecs64

// UnmarshalBinary Parameter 2, FirstSeenUTC.
func (p *firstSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = firstSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// firstSeenUptime is Parameter 3, FirstSeenUptime.
type firstSeenUptime microSecs64

// UnmarshalBinary Parameter 3, FirstSeenUptime.
func (p *firstSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = firstSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// lastSeenUTC is Parameter 4, LastSeenUTC.
type lastSeenUTC microSecs64

// UnmarshalBinary Parameter 4, LastSeenUTC.
func (p *lastSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = lastSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// lastSeenUptime is Parameter 5, LastSeenUptime.
type lastSeenUptime microSecs64

// UnmarshalBinary Parameter 5, LastSeenUptime.
func (p *lastSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = lastSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// peakRSSI is Parameter 6, PeakRSSI.
type peakRSSI dBm8

// UnmarshalBinary Parameter 6, PeakRSSI.
func (p *peakRSSI) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeakRSSI, 1, len(data), true); err != nil {
		return err
	}
	*p = peakRSSI(dBm8(data[0]))
	return nil
}

// channelIndex is Parameter 7, ChannelIndex.
type channelIndex uint16

// UnmarshalBinary Parameter 7, ChannelIndex.
func (p *channelIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamChannelIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = channelIndex(binary.BigEndian.Uint16(data))
	return nil
}

// tagSeenCount is Parameter 8, TagSeenCount.
type tagSeenCount uint16

// UnmarshalBinary Parameter 8, TagSeenCount.
func (p *tagSeenCount) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagSeenCount, 2, len(data), true); err != nil {
		return err
	}
	*p = tagSeenCount(binary.BigEndian.Uint16(data))
	return nil
}

// roSpecID is Parameter 9, ROSpecID.
type roSpecID uint32

// UnmarshalBinary Parameter 9, ROSpecID.
func (p *roSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = roSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// inventoryParameterSpecID is Parameter 10, InventoryParameterSpecID.
type inventoryParameterSpecID uint16

// UnmarshalBinary Parameter 10, InventoryParameterSpecID.
func (p *inventoryParameterSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = inventoryParameterSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2CRC is Parameter 11, C1G2CRC.
type c1G2CRC uint16

// UnmarshalBinary Parameter 11, C1G2CRC.
func (p *c1G2CRC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2CRC, 2, len(data), true); err != nil {
		return err
	}
	*p = c1G2CRC(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2PC is Parameter 12, C1G2PC.
type c1G2PC uint16

// UnmarshalBinary Parameter 12, C1G2PC.
func (p *c1G2PC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2PC, 2, len(data), true); err != nil {
		return err
	}
	*p = c1G2PC(binary.BigEndian.Uint16(data))
	return nil
}

// epc96 is Parameter 13, EPC96.
type epc96 struct {
	EPC []byte
}

// UnmarshalBinary Parameter 13, EPC96.
func (p *epc96) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPC96, 12, len(data), true); err != nil {
		return err
	}
	p.EPC = make([]byte, 12)
	copy(p.EPC, data)
	return nil
}

// specIndex is Parameter 14, SpecIndex.
type specIndex uint16

// UnmarshalBinary Parameter 14, SpecIndex.
func (p *specIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = specIndex(binary.BigEndian.Uint16(data))
	return nil
}

// clientRequestOpSpecResult is Parameter 15,
// ClientRequestOpSpecResult.
type clientRequestOpSpecResult uint16

// UnmarshalBinary Parameter 15, ClientRequestOpSpecResult.
func (p *clientRequestOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpecResult, 2, len(data), true); err != nil {
		return err
	}
	*p = clientRequestOpSpecResult(binary.BigEndian.Uint16(data))
	return nil
}

// accessSpecID is Parameter 16, AccessSpecID.
type accessSpecID uint32

// UnmarshalBinary Parameter 16, AccessSpecID.
func (p *accessSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = accessSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// opSpecID is Parameter 17, OpSpecID.
type opSpecID uint16

// UnmarshalBinary Parameter 17, OpSpecID.
func (p *opSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamOpSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = opSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2SingulationDetails is Parameter 18, C1G2SingulationDetails.
type c1G2SingulationDetails struct {
	NumCollisionSlots uint16
	NumEmptySlots     uint16
}

// UnmarshalBinary Parameter 18, C1G2SingulationDetails.
func (p *c1G2SingulationDetails) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationDetails, 4, len(data), true); err != nil {
		return err
	}
	p.NumCollisionSlots = binary.BigEndian.Uint16(data)
	p.NumEmptySlots = binary.BigEndian.Uint16(data[2:])
	return nil
}

// c1G2XPCW1 is Parameter 19, C1G2XPCW1.
type c1G2XPCW1 uint16

// UnmarshalBinary Parameter 19, C1G2XPCW1.
func (p *c1G2XPCW1) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW1, 2, len(data), true); err != nil {
		return err
	}
	*p = c1G2XPCW1(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2XPCW2 is Parameter 20, C1G2XPCW2.
type c1G2XPCW2 uint16

// UnmarshalBinary Parameter 20, C1G2XPCW2.
func (p *c1G2XPCW2) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW2, 2, len(data), true); err != nil {
		return err
	}
	*p = c1G2XPCW2(binary.BigEndian.Uint16(data))
	return nil
}

// utcTimestamp is Parameter 128, UTCTimestamp.
type utcTimestamp microSecs64

// UnmarshalBinary Parameter 128, UTCTimestamp.
func (p *utcTimestamp) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUTCTimestamp, 8, len(data), true); err != nil {
		return err
	}
	*p = utcTimestamp(binary.BigEndian.Uint64(data))
	return nil
}

// uptime is Parameter 129, Uptime.
type uptime microSecs64

// UnmarshalBinary Parameter 129, Uptime.
func (p *uptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = uptime(binary.BigEndian.Uint64(data))
	return nil
}

// generalDeviceCapabilities is Parameter 137,
// GeneralDeviceCapabilities.
type generalDeviceCapabilities struct {
	MaxSupportedAntennas               uint16
	GeneralCapabilityFlags             GeneralCapabilityFlags
	DeviceManufacturerName             uint32
	ModelName                          uint32
	ReaderFirmwareVersion              string
	ReceiveSensitivityTableEntries     []receiveSensitivityTableEntry
	PerAntennaReceiveSensitivityRanges []perAntennaReceiveSensitivityRange
	GPIOCapabilities                   gpioCapabilities
	PerAntennaAirProtocols             []perAntennaAirProtocol
	MaximumReceiveSensitivity          *maximumReceiveSensitivity
}

// UnmarshalBinary Parameter 137, GeneralDeviceCapabilities.
func (p *generalDeviceCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGeneralDeviceCapabilities, 29, len(data), false); err != nil {
		return err
	}
	p.MaxSupportedAntennas = binary.BigEndian.Uint16(data)
	p.GeneralCapabilityFlags = GeneralCapabilityFlags(data[2])
	p.DeviceManufacturerName = binary.BigEndian.Uint32(data[3:])
	p.ModelName = binary.BigEndian.Uint32(data[7:])
	if strLen := int(binary.BigEndian.Uint16(data[11:])); strLen > len(data[13:]) {
		return errors.Errorf("ReaderFirmwareVersion (string) declares it has "+
			"%d bytes, but only %d bytes are available", strLen, len(data[13:]))
	} else if strLen != 0 {
		p.ReaderFirmwareVersion = string(data[13 : strLen+13])
		data = data[strLen+13:]
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReceiveSensitivityTableEntry:
			var tmp receiveSensitivityTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.ReceiveSensitivityTableEntries = append(p.ReceiveSensitivityTableEntries, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaReceiveSensitivityRange:
			var tmp perAntennaReceiveSensitivityRange
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaReceiveSensitivityRanges = append(p.PerAntennaReceiveSensitivityRanges, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamGPIOCapabilities, 8, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamGPIOCapabilities {
		return errors.Errorf("expected ParamGPIOCapabilities, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPIOCapabilities says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.GPIOCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaAirProtocol:
			var tmp perAntennaAirProtocol
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaAirProtocols = append(p.PerAntennaAirProtocols, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamMaximumReceiveSensitivity {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamMaximumReceiveSensitivity says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		*p.MaximumReceiveSensitivity = maximumReceiveSensitivity(dBm16(binary.BigEndian.Uint16(data[4:])))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GeneralDeviceCapabilities, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// receiveSensitivityTableEntry is Parameter 139,
// ReceiveSensitivityTableEntry.
type receiveSensitivityTableEntry struct {
	TableIndex uint16
	// ReceiveSensitivity is relative the maximum.
	ReceiveSensitivity dB
}

// UnmarshalBinary Parameter 139, ReceiveSensitivityTableEntry.
func (p *receiveSensitivityTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReceiveSensitivityTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.TableIndex = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivity = binary.BigEndian.Uint16(data[2:])
	return nil
}

// perAntennaAirProtocol is Parameter 140, PerAntennaAirProtocol.
type perAntennaAirProtocol struct {
	AntennaID      uint16
	AirProtocolIDs []AirProtocolIDType
}

// UnmarshalBinary Parameter 140, PerAntennaAirProtocol.
func (p *perAntennaAirProtocol) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaAirProtocol, 4, len(data), false); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); arrLen > len(data[4:]) {
		return errors.Errorf("AirProtocolIDs ([]AirProtocolIDType) declares "+
			"it has %d bytes, but only %d bytes are available", arrLen,
			len(data[4:]))
	} else if arrLen != 0 {
		p.AirProtocolIDs = make([]AirProtocolIDType, arrLen)
		for i := 0; i < arrLen; i++ {
			p.AirProtocolIDs[i] = AirProtocolIDType(data[i])
		}
		data = data[arrLen+4:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading PerAntennaAirProtocol, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// gpioCapabilities is Parameter 141, GPIOCapabilities.
type gpioCapabilities struct {
	NumGPIs uint16
	NumGPOs uint16
}

// UnmarshalBinary Parameter 141, GPIOCapabilities.
func (p *gpioCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIOCapabilities, 4, len(data), true); err != nil {
		return err
	}
	p.NumGPIs = binary.BigEndian.Uint16(data)
	p.NumGPOs = binary.BigEndian.Uint16(data[2:])
	return nil
}

// llrpCapabilities is Parameter 142, LLRPCapabilities.
type llrpCapabilities struct {
	LLRPCapabilitiesFlags                  LLRPCapabilitiesFlags
	MaxPriorityLevelSupported              uint8
	ClientRequestedOpSpecTimeout           uint16
	MaxNumROSpecs                          uint32
	MaxNumSpecsPerROSpec                   uint32
	MaxNumInventoryParameterSpecsPerAISpec uint32
	MaxNumAccessSpecs                      uint32
	MaxNumOpSpecsPerAccessSpec             uint32
}

// UnmarshalBinary Parameter 142, LLRPCapabilities.
func (p *llrpCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPCapabilities, 24, len(data), true); err != nil {
		return err
	}
	p.LLRPCapabilitiesFlags = LLRPCapabilitiesFlags(data[0])
	p.MaxPriorityLevelSupported = data[1]
	p.ClientRequestedOpSpecTimeout = binary.BigEndian.Uint16(data[2:])
	p.MaxNumROSpecs = binary.BigEndian.Uint32(data[4:])
	p.MaxNumSpecsPerROSpec = binary.BigEndian.Uint32(data[8:])
	p.MaxNumInventoryParameterSpecsPerAISpec = binary.BigEndian.Uint32(data[12:])
	p.MaxNumAccessSpecs = binary.BigEndian.Uint32(data[16:])
	p.MaxNumOpSpecsPerAccessSpec = binary.BigEndian.Uint32(data[20:])
	return nil
}

// regulatoryCapabilities is Parameter 143, RegulatoryCapabilities.
type regulatoryCapabilities struct {
	CountryCode            CountryCodeType
	CommunicationsStandard uint16
	UHFBandCapabilities    *uhfBandCapabilities
	Custom                 []custom
}

// UnmarshalBinary Parameter 143, RegulatoryCapabilities.
func (p *regulatoryCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRegulatoryCapabilities, 4, len(data), false); err != nil {
		return err
	}
	p.CountryCode = CountryCodeType(binary.BigEndian.Uint16(data))
	p.CommunicationsStandard = binary.BigEndian.Uint16(data[2:])
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUHFBandCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUHFBandCapabilities says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.UHFBandCapabilities = new(uhfBandCapabilities)
		if err := p.UHFBandCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RegulatoryCapabilities, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// uhfBandCapabilities is Parameter 144, UHFBandCapabilities.
type uhfBandCapabilities struct {
	TransmitPowerLevelTableEntry  []transmitPowerLevelTableEntry
	FrequencyInformation          []frequencyInformation
	UHFC1G2RFModeTable            []uhfc1G2RFModeTable
	RFSurveyFrequencyCapabilities *rfSurveyFrequencyCapabilities
}

// UnmarshalBinary Parameter 144, UHFBandCapabilities.
func (p *uhfBandCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFBandCapabilities, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTransmitPowerLevelTableEntry:
			var tmp transmitPowerLevelTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.TransmitPowerLevelTableEntry = append(p.TransmitPowerLevelTableEntry, tmp)
		case ParamFrequencyInformation:
			var tmp frequencyInformation
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyInformation = append(p.FrequencyInformation, tmp)
		case ParamUHFC1G2RFModeTable:
			var tmp uhfc1G2RFModeTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.UHFC1G2RFModeTable = append(p.UHFC1G2RFModeTable, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFSurveyFrequencyCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveyFrequencyCapabilities says it "+
				"has %d bytes, but only %d bytes remain", subLen, len(data))
		}
		p.RFSurveyFrequencyCapabilities = new(rfSurveyFrequencyCapabilities)
		if err := p.RFSurveyFrequencyCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading UHFBandCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// transmitPowerLevelTableEntry is Parameter 145,
// TransmitPowerLevelTableEntry.
type transmitPowerLevelTableEntry struct {
	Index              uint16
	TransmitPowerValue dBmX100
}

// UnmarshalBinary Parameter 145, TransmitPowerLevelTableEntry.
func (p *transmitPowerLevelTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTransmitPowerLevelTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.Index = binary.BigEndian.Uint16(data)
	p.TransmitPowerValue = binary.BigEndian.Uint16(data[2:])
	return nil
}

// frequencyInformation is Parameter 146, FrequencyInformation.
type frequencyInformation struct {
	HoppingFlags        HoppingFlags
	FrequencyHopTable   []frequencyHopTable
	FixedFrequencyTable *fixedFrequencyTable
}

// UnmarshalBinary Parameter 146, FrequencyInformation.
func (p *frequencyInformation) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyInformation, 1, len(data), false); err != nil {
		return err
	}
	p.HoppingFlags = HoppingFlags(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyHopTable:
			var tmp frequencyHopTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyHopTable = append(p.FrequencyHopTable, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFixedFrequencyTable {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFixedFrequencyTable says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.FixedFrequencyTable = new(fixedFrequencyTable)
		if err := p.FixedFrequencyTable.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyInformation, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// frequencyHopTable is Parameter 147, FrequencyHopTable.
type frequencyHopTable struct {
	HopTableID  uint8
	Frequencies []kHz
}

// UnmarshalBinary Parameter 147, FrequencyHopTable.
func (p *frequencyHopTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyHopTable, 4, len(data), false); err != nil {
		return err
	}
	p.HopTableID = data[0]
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen)*4 > int64(len(data[4:])) {
		return errors.Errorf("Frequencies ([]kHz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]kHz, arrLen)
		for i, pos := 0, 4; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+4:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyHopTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// fixedFrequencyTable is Parameter 148, FixedFrequencyTable.
type fixedFrequencyTable struct {
	Frequencies []kHz
}

// UnmarshalBinary Parameter 148, FixedFrequencyTable.
func (p *fixedFrequencyTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFixedFrequencyTable, 2, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*4 > int64(len(data[2:])) {
		return errors.Errorf("Frequencies ([]kHz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]kHz, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FixedFrequencyTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// perAntennaReceiveSensitivityRange is Parameter 149,
// PerAntennaReceiveSensitivityRange.
type perAntennaReceiveSensitivityRange struct {
	AntennaID                  uint16
	ReceiveSensitivityIndexMin uint16
	ReceiveSensitivityIndexMax uint16
}

// UnmarshalBinary Parameter 149, PerAntennaReceiveSensitivityRange.
func (p *perAntennaReceiveSensitivityRange) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaReceiveSensitivityRange, 6, len(data), true); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivityIndexMin = binary.BigEndian.Uint16(data[2:])
	p.ReceiveSensitivityIndexMax = binary.BigEndian.Uint16(data[4:])
	return nil
}

// roSpec is Parameter 177, ROSpec.
type roSpec struct {
	ROSpecID           uint32
	Priority           uint8
	ROSpecCurrentState ROSpecCurrentStateType
	ROBoundarySpec     roBoundarySpec
	AISpec             []aiSpec
	RFSurveySpec       []rfSurveySpec
	Custom             []custom
	LoopSpec           *loopSpec
	ROReportSpec       *roReportSpec
}

// UnmarshalBinary Parameter 177, ROSpec.
func (p *roSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpec, 15, len(data), false); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.Priority = data[4]
	p.ROSpecCurrentState = ROSpecCurrentStateType(data[5])
	data = data[6:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROBoundarySpec {
		return errors.Errorf("expected ParamROBoundarySpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROBoundarySpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.ROBoundarySpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAISpec:
			var tmp aiSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AISpec = append(p.AISpec, tmp)
		case ParamRFSurveySpec:
			var tmp rfSurveySpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.RFSurveySpec = append(p.RFSurveySpec, tmp)
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamLoopSpec:
			*p.LoopSpec = loopSpec(binary.BigEndian.Uint32(data[4:]))
		case ParamROReportSpec:
			p.ROReportSpec = new(roReportSpec)
			if err := p.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// roBoundarySpec is Parameter 178, ROBoundarySpec.
type roBoundarySpec struct {
	ROSpecStartTrigger roSpecStartTrigger
	ROSpecStopTrigger  roSpecStopTrigger
}

// UnmarshalBinary Parameter 178, ROBoundarySpec.
func (p *roBoundarySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROBoundarySpec, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStartTrigger {
		return errors.Errorf("expected ParamROSpecStartTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStartTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.ROSpecStartTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStopTrigger {
		return errors.Errorf("expected ParamROSpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStopTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.ROSpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROBoundarySpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// roSpecStartTrigger is Parameter 179, ROSpecStartTrigger.
type roSpecStartTrigger struct {
	ROSpecStartTriggerType ROSpecStartTriggerType
	PeriodicTriggerValue   *periodicTriggerValue
	GPITriggerValue        *gpiTriggerValue
}

// UnmarshalBinary Parameter 179, ROSpecStartTrigger.
func (p *roSpecStartTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStartTrigger, 1, len(data), false); err != nil {
		return err
	}
	p.ROSpecStartTriggerType = ROSpecStartTriggerType(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPeriodicTriggerValue:
			p.PeriodicTriggerValue = new(periodicTriggerValue)
			if err := p.PeriodicTriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamGPITriggerValue:
			p.GPITriggerValue = new(gpiTriggerValue)
			if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpecStartTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// periodicTriggerValue is Parameter 180, PeriodicTriggerValue.
type periodicTriggerValue struct {
	Offset       milliSecs32
	Period       milliSecs32
	UTCTimestamp *utcTimestamp
}

// UnmarshalBinary Parameter 180, PeriodicTriggerValue.
func (p *periodicTriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeriodicTriggerValue, 8, len(data), false); err != nil {
		return err
	}
	p.Offset = binary.BigEndian.Uint32(data)
	p.Period = binary.BigEndian.Uint32(data[4:])
	data = data[8:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUTCTimestamp {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		*p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading PeriodicTriggerValue, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// gpiTriggerValue is Parameter 181, GPITriggerValue.
type gpiTriggerValue struct {
	GPIPortNum      uint16
	GPITriggerFlags GPITriggerFlags
	Timeout         milliSecs32
}

// UnmarshalBinary Parameter 181, GPITriggerValue.
func (p *gpiTriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPITriggerValue, 7, len(data), true); err != nil {
		return err
	}
	p.GPIPortNum = binary.BigEndian.Uint16(data)
	p.GPITriggerFlags = GPITriggerFlags(data[2])
	p.Timeout = binary.BigEndian.Uint32(data[3:])
	return nil
}

// roSpecStopTrigger is Parameter 182, ROSpecStopTrigger.
type roSpecStopTrigger struct {
	ROSpecStopTriggerType ROSpecStopTriggerType
	DurationTriggerValue  milliSecs32
	GPITriggerValue       *gpiTriggerValue
}

// UnmarshalBinary Parameter 182, ROSpecStopTrigger.
func (p *roSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.ROSpecStopTriggerType = ROSpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPITriggerValue says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.GPITriggerValue = new(gpiTriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// aiSpec is Parameter 183, AISpec.
type aiSpec struct {
	AntennaID              []uint16
	AISpecStopTrigger      aiSpecStopTrigger
	InventoryParameterSpec []inventoryParameterSpec
	Custom                 []custom
}

// UnmarshalBinary Parameter 183, AISpec.
func (p *aiSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpec, 9, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*2 > int64(len(data[2:])) {
		return errors.Errorf("AntennaID ([]uint16) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.AntennaID = make([]uint16, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+2 {
			p.AntennaID[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+2:]
	}
	// sub-parameters
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAISpecStopTrigger {
		return errors.Errorf("expected ParamAISpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAISpecStopTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.AISpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamInventoryParameterSpec:
			var tmp inventoryParameterSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.InventoryParameterSpec = append(p.InventoryParameterSpec, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// aiSpecStopTrigger is Parameter 184, AISpecStopTrigger.
type aiSpecStopTrigger struct {
	AISpecStopTriggerType AISpecStopTriggerType
	DurationTriggerValue  milliSecs32
	GPITriggerValue       *gpiTriggerValue
	TagObservationTrigger *tagObservationTrigger
}

// UnmarshalBinary Parameter 184, AISpecStopTrigger.
func (p *aiSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.AISpecStopTriggerType = AISpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPITriggerValue:
			p.GPITriggerValue = new(gpiTriggerValue)
			if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamTagObservationTrigger:
			p.TagObservationTrigger = new(tagObservationTrigger)
			if err := p.TagObservationTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// tagObservationTrigger is Parameter 185, TagObservationTrigger.
type tagObservationTrigger struct {
	TagObservationTriggerType TagObservationTriggerType
	NumberofTags              uint16
	NumberofAttempts          uint16
	T                         milliSecs16
	Timeout                   milliSecs32
}

// UnmarshalBinary Parameter 185, TagObservationTrigger.
func (p *tagObservationTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagObservationTrigger, 12, len(data), true); err != nil {
		return err
	}
	p.TagObservationTriggerType = TagObservationTriggerType(data[0])
	p.NumberofTags = binary.BigEndian.Uint16(data[2:])
	p.NumberofAttempts = binary.BigEndian.Uint16(data[4:])
	p.T = binary.BigEndian.Uint16(data[6:])
	p.Timeout = binary.BigEndian.Uint32(data[8:])
	return nil
}

// inventoryParameterSpec is Parameter 186, InventoryParameterSpec.
type inventoryParameterSpec struct {
	InventoryParameterSpecID uint16
	AirProtocolID            AirProtocolIDType
	AntennaConfiguration     []antennaConfiguration
	Custom                   []custom
}

// UnmarshalBinary Parameter 186, InventoryParameterSpec.
func (p *inventoryParameterSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpec, 3, len(data), false); err != nil {
		return err
	}
	p.InventoryParameterSpecID = binary.BigEndian.Uint16(data)
	p.AirProtocolID = AirProtocolIDType(data[2])
	data = data[3:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaConfiguration:
			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AntennaConfiguration = append(p.AntennaConfiguration, tmp)
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading InventoryParameterSpec, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// rfSurveySpec is Parameter 187, RFSurveySpec.
type rfSurveySpec struct {
	AntennaID               uint16
	StartFrequency          kHz
	EndFrequency            kHz
	RFSurveySpecStopTrigger rfSurveySpecStopTrigger
	Custom                  []custom
}

// UnmarshalBinary Parameter 187, RFSurveySpec.
func (p *rfSurveySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpec, 23, len(data), false); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	p.StartFrequency = binary.BigEndian.Uint32(data[2:])
	p.EndFrequency = binary.BigEndian.Uint32(data[6:])
	data = data[10:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamRFSurveySpecStopTrigger {
		return errors.Errorf("expected ParamRFSurveySpecStopTrigger, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveySpecStopTrigger says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.RFSurveySpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RFSurveySpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// rfSurveySpecStopTrigger is Parameter 188, RFSurveySpecStopTrigger.
type rfSurveySpecStopTrigger struct {
	RFSurveySpecStopTriggerType RFSurveySpecStopTriggerType
	Duration                    milliSecs32
	N                           milliSecs32
}

// UnmarshalBinary Parameter 188, RFSurveySpecStopTrigger.
func (p *rfSurveySpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpecStopTrigger, 9, len(data), true); err != nil {
		return err
	}
	p.RFSurveySpecStopTriggerType = RFSurveySpecStopTriggerType(data[0])
	p.Duration = binary.BigEndian.Uint32(data[1:])
	p.N = binary.BigEndian.Uint32(data[5:])
	return nil
}

// accessSpec is Parameter 207, AccessSpec.
type accessSpec struct {
	AccessSpecID          uint32
	AntennaID             uint16
	AirProtocolID         AirProtocolIDType
	AccessSpecFlags       AccessSpecFlags
	ROSpecID              uint32
	AccessSpecStopTrigger accessSpecStopTrigger
	AccessCommand         accessCommand
	AccessReportSpec      *accessReportSpec
	Custom                []custom
}

// UnmarshalBinary Parameter 207, AccessSpec.
func (p *accessSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpec, 19, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	p.AntennaID = binary.BigEndian.Uint16(data[4:])
	p.AirProtocolID = AirProtocolIDType(data[6])
	p.AccessSpecFlags = AccessSpecFlags(data[7])
	p.ROSpecID = binary.BigEndian.Uint32(data[8:])
	data = data[12:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpecStopTrigger {
		return errors.Errorf("expected ParamAccessSpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpecStopTrigger says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.AccessSpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamAccessCommand, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessCommand {
		return errors.Errorf("expected ParamAccessCommand, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessCommand says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.AccessCommand.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessReportSpec says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		*p.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AccessSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// accessSpecStopTrigger is Parameter 208, AccessSpecStopTrigger.
type accessSpecStopTrigger struct {
	AccessSpecStopTriggerType AccessSpecStopTriggerType
	OperationCountValue       uint16
}

// UnmarshalBinary Parameter 208, AccessSpecStopTrigger.
func (p *accessSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecStopTrigger, 3, len(data), true); err != nil {
		return err
	}
	p.AccessSpecStopTriggerType = AccessSpecStopTriggerType(data[0])
	p.OperationCountValue = binary.BigEndian.Uint16(data[1:])
	return nil
}

// accessCommand is Parameter 209, AccessCommand.
type accessCommand struct {
	C1G2TagSpec                 c1G2TagSpec
	C1G2Read                    *c1G2Read
	C1G2Write                   *c1G2Write
	C1G2Kill                    *c1G2Kill
	C1G2Recommission            *c1G2Recommission
	C1G2Lock                    *c1G2Lock
	C1G2BlockErase              *c1G2BlockErase
	C1G2BlockWrite              *c1G2BlockWrite
	C1G2BlockPermalock          *c1G2BlockPermalock
	C1G2GetBlockPermalockStatus *c1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *clientRequestOpSpec
	Custom                      []custom
}

// UnmarshalBinary Parameter 209, AccessCommand.
func (p *accessCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessCommand, 15, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagSpec {
		return errors.Errorf("expected ParamC1G2TagSpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagSpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.C1G2TagSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(c1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(c1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(c1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(c1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(c1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(c1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(c1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(c1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(c1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			*p.ClientRequestOpSpec = clientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AccessCommand, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// clientRequestOpSpec is Parameter 210, ClientRequestOpSpec.
type clientRequestOpSpec uint16

// UnmarshalBinary Parameter 210, ClientRequestOpSpec.
func (p *clientRequestOpSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpec, 2, len(data), true); err != nil {
		return err
	}
	*p = clientRequestOpSpec(binary.BigEndian.Uint16(data))
	return nil
}

// clientRequestResponse is Parameter 211, ClientRequestResponse.
type clientRequestResponse struct {
	AccessSpecID                uint32
	EPCData                     epcData
	C1G2Read                    *c1G2Read
	C1G2Write                   *c1G2Write
	C1G2Kill                    *c1G2Kill
	C1G2Recommission            *c1G2Recommission
	C1G2Lock                    *c1G2Lock
	C1G2BlockErase              *c1G2BlockErase
	C1G2BlockWrite              *c1G2BlockWrite
	C1G2BlockPermalock          *c1G2BlockPermalock
	C1G2GetBlockPermalockStatus *c1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *clientRequestOpSpec
	Custom                      *custom
}

// UnmarshalBinary Parameter 211, ClientRequestResponse.
func (p *clientRequestResponse) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestResponse, 10, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	data = data[4:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEPCData {
		return errors.Errorf("expected ParamEPCData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEPCData says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(c1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(c1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(c1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(c1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(c1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(c1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(c1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(c1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(c1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			*p.ClientRequestOpSpec = clientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		case ParamCustom:
			p.Custom = new(custom)
			if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// llrpConfigurationStateValue is Parameter 217,
// LLRPConfigurationStateValue.
type llrpConfigurationStateValue uint32

// UnmarshalBinary Parameter 217, LLRPConfigurationStateValue.
func (p *llrpConfigurationStateValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPConfigurationStateValue, 4, len(data), true); err != nil {
		return err
	}
	*p = llrpConfigurationStateValue(binary.BigEndian.Uint32(data))
	return nil
}

// identification is Parameter 218, Identification.
type identification struct {
	IDType   IDType
	ReaderID []byte
}

// UnmarshalBinary Parameter 218, Identification.
func (p *identification) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamIdentification, 3, len(data), false); err != nil {
		return err
	}
	p.IDType = IDType(data[0])
	if arrLen := int(binary.BigEndian.Uint16(data[1:])); arrLen > len(data[3:]) {
		return errors.Errorf("ReaderID ([]byte) declares it has %d bytes, "+
			"but only %d bytes are available", arrLen, len(data[3:]))
	} else if arrLen != 0 {
		p.ReaderID = make([]byte, arrLen)
		copy(p.ReaderID, data[3:])
		data = data[arrLen+3:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading Identification, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// gpoWriteData is Parameter 219, GPOWriteData.
type gpoWriteData struct {
	GPOPort uint16
	GPOData bool
}

// UnmarshalBinary Parameter 219, GPOWriteData.
func (p *gpoWriteData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPOWriteData, 3, len(data), true); err != nil {
		return err
	}
	p.GPOPort = binary.BigEndian.Uint16(data)
	p.GPOData = data[2]&0x80 != 0
	return nil
}

// keepAliveSpec is Parameter 220, KeepAliveSpec.
type keepAliveSpec struct {
	KeepAliveTriggerType KeepAliveTriggerType
	Interval             milliSecs32
}

// UnmarshalBinary Parameter 220, KeepAliveSpec.
func (p *keepAliveSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamKeepAliveSpec, 5, len(data), true); err != nil {
		return err
	}
	p.KeepAliveTriggerType = KeepAliveTriggerType(data[0])
	p.Interval = binary.BigEndian.Uint32(data[1:])
	return nil
}

// antennaProperties is Parameter 221, AntennaProperties.
type antennaProperties struct {
	AntennaConnected bool
	AntennaID        uint16
	// AntennaGain is the composite forward gain of the antenna,
	// including cable loss, relative a hypothetical isotropic antenna,
	// expressed in 1/100ths of dBi.
	AntennaGain dBiX100
}

// UnmarshalBinary Parameter 221, AntennaProperties.
func (p *antennaProperties) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaProperties, 5, len(data), true); err != nil {
		return err
	}
	p.AntennaConnected = data[0]&0x80 != 0
	p.AntennaID = binary.BigEndian.Uint16(data[1:])
	p.AntennaGain = binary.BigEndian.Uint16(data[3:])
	return nil
}

// antennaConfiguration is Parameter 222, AntennaConfiguration.
type antennaConfiguration struct {
	AntennaID            uint16
	RFReceiver           *rfReceiver
	RFTransmitter        *rfTransmitter
	C1G2InventoryCommand []c1G2InventoryCommand
	Custom               []custom
}

// UnmarshalBinary Parameter 222, AntennaConfiguration.
func (p *antennaConfiguration) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaConfiguration, 2, len(data), false); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamRFReceiver:
			*p.RFReceiver = rfReceiver(binary.BigEndian.Uint16(data[4:]))
		case ParamRFTransmitter:
			p.RFTransmitter = new(rfTransmitter)
			if err := p.RFTransmitter.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2InventoryCommand:
			var tmp c1G2InventoryCommand
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2InventoryCommand = append(p.C1G2InventoryCommand, tmp)
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AntennaConfiguration, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// rfReceiver is Parameter 223, RFReceiver.
type rfReceiver uint16

// UnmarshalBinary Parameter 223, RFReceiver.
func (p *rfReceiver) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFReceiver, 2, len(data), true); err != nil {
		return err
	}
	*p = rfReceiver(binary.BigEndian.Uint16(data))
	return nil
}

// rfTransmitter is Parameter 224, RFTransmitter.
type rfTransmitter struct {
	HopTableID                        uint16
	ChannelIndexInFixedFrequencyTable uint16
	TransmitPowerTableIndex           uint16
}

// UnmarshalBinary Parameter 224, RFTransmitter.
func (p *rfTransmitter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFTransmitter, 6, len(data), true); err != nil {
		return err
	}
	p.HopTableID = binary.BigEndian.Uint16(data)
	p.ChannelIndexInFixedFrequencyTable = binary.BigEndian.Uint16(data[2:])
	p.TransmitPowerTableIndex = binary.BigEndian.Uint16(data[4:])
	return nil
}

// gpiPortCurrentState is Parameter 225, GPIPortCurrentState.
type gpiPortCurrentState struct {
	GPIPort        uint16
	GPIPortEnabled bool
	GPIState       GPIStateType
}

// UnmarshalBinary Parameter 225, GPIPortCurrentState.
func (p *gpiPortCurrentState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIPortCurrentState, 4, len(data), true); err != nil {
		return err
	}
	p.GPIPort = binary.BigEndian.Uint16(data)
	p.GPIPortEnabled = data[2]&0x80 != 0
	p.GPIState = GPIStateType(data[3])
	return nil
}

// eventsAndReports is Parameter 226, EventsAndReports.
type eventsAndReports bool

// UnmarshalBinary Parameter 226, EventsAndReports.
func (p *eventsAndReports) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventsAndReports, 1, len(data), true); err != nil {
		return err
	}
	*p = eventsAndReports(data[0]&0x80 != 0)
	return nil
}

// roReportSpec is Parameter 237, ROReportSpec.
type roReportSpec struct {
	ROReportTriggerType      ROReportTriggerType
	N                        uint16
	TagReportContentSelector tagReportContentSelector
	Custom                   []custom
}

// UnmarshalBinary Parameter 237, ROReportSpec.
func (p *roReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROReportSpec, 9, len(data), false); err != nil {
		return err
	}
	p.ROReportTriggerType = ROReportTriggerType(data[0])
	p.N = binary.BigEndian.Uint16(data[1:])
	data = data[3:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportContentSelector {
		return errors.Errorf("expected ParamTagReportContentSelector, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportContentSelector says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.TagReportContentSelector.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROReportSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// tagReportContentSelector is Parameter 238,
// TagReportContentSelector.
type tagReportContentSelector struct {
	EnableROSpecID             bool
	EnableSpecIndex            bool
	EnableInventoryParamSpecID bool
	EnableAntennaID            bool
	EnableChannelIndex         bool
	EnablePeakRSSI             bool
	EnableFirstSeenTimestamp   bool
	EnableLastSeenTimestamp    bool
	EnableTagSeenCount         bool
	EnableAccessSpecID         bool
	C1G2EPCMemorySelector      []c1G2EPCMemorySelector
	Custom                     []custom
}

// UnmarshalBinary Parameter 238, TagReportContentSelector.
func (p *tagReportContentSelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportContentSelector, 2, len(data), false); err != nil {
		return err
	}
	p.EnableROSpecID = data[0]&0x80 != 0
	p.EnableSpecIndex = data[0]&0x40 != 0
	p.EnableInventoryParamSpecID = data[0]&0x20 != 0
	p.EnableAntennaID = data[0]&0x10 != 0
	p.EnableChannelIndex = data[0]&0x08 != 0
	p.EnablePeakRSSI = data[0]&0x04 != 0
	p.EnableFirstSeenTimestamp = data[0]&0x02 != 0
	p.EnableLastSeenTimestamp = data[0]&0x01 != 0
	p.EnableTagSeenCount = data[1]&0x80 != 0
	p.EnableAccessSpecID = data[1]&0x40 != 0
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2EPCMemorySelector:
			var tmp c1G2EPCMemorySelector
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2EPCMemorySelector = append(p.C1G2EPCMemorySelector, tmp)
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading TagReportContentSelector, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// accessReportSpec is Parameter 239, AccessReportSpec.
type accessReportSpec AccessReportTriggerType

// UnmarshalBinary Parameter 239, AccessReportSpec.
func (p *accessReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessReportSpec, 1, len(data), true); err != nil {
		return err
	}
	*p = accessReportSpec(AccessReportTriggerType(data[0]))
	return nil
}

// tagReportData is Parameter 240, TagReportData.
type tagReportData struct {
	EPCData                                 epcData
	EPC96                                   epc96
	ROSpecID                                *roSpecID
	SpecIndex                               *specIndex
	InventoryParameterSpecID                *inventoryParameterSpecID
	AntennaID                               *antennaID
	PeakRSSI                                *peakRSSI
	ChannelIndex                            *channelIndex
	FirstSeenUTC                            *firstSeenUTC
	FirstSeenUptime                         *firstSeenUptime
	LastSeenUTC                             *lastSeenUTC
	LastSeenUptime                          *lastSeenUptime
	TagSeenCount                            *tagSeenCount
	C1G2PC                                  []c1G2PC
	C1G2XPCW1                               []c1G2XPCW1
	C1G2XPCW2                               []c1G2XPCW2
	C1G2CRC                                 []c1G2CRC
	AccessSpecID                            *accessSpecID
	C1G2ReadOpSpecResult                    []c1G2ReadOpSpecResult
	C1G2WriteOpSpecResult                   []c1G2WriteOpSpecResult
	C1G2KillOpSpecResult                    []c1G2KillOpSpecResult
	C1G2LockOpSpecResult                    []c1G2LockOpSpecResult
	C1G2BlockEraseOpSpecResult              []c1G2BlockEraseOpSpecResult
	C1G2BlockWriteOpSpecResult              []c1G2BlockWriteOpSpecResult
	C1G2RecommissionOpSpecResult            []c1G2RecommissionOpSpecResult
	C1G2BlockPermalockOpSpecResult          []c1G2BlockPermalockOpSpecResult
	C1G2GetBlockPermalockStatusOpSpecResult []c1G2GetBlockPermalockStatusOpSpecResult
	ClientRequestOpSpecResult               []clientRequestOpSpecResult
	Custom                                  []custom
}

// UnmarshalBinary Parameter 240, TagReportData.
func (p *tagReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportData, 6, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		var pt ParamType
		if data[0]&0x80 == 1 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return errors.Errorf("expecting a TLV header, but %d < 4 byte "+
				"remain", len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamEPCData:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamEPCData says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamEPC96:
			if err := p.EPC96.UnmarshalBinary(data[1:13]); err != nil {
				return err
			}
			data = data[13:]
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamTagReportData", pt)
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			*p.ROSpecID = roSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			*p.SpecIndex = specIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamInventoryParameterSpecID:
			*p.InventoryParameterSpecID = inventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAntennaID:
			*p.AntennaID = antennaID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamPeakRSSI:
			*p.PeakRSSI = peakRSSI(dBm8(data[1]))
			data = data[2:]
		case ParamChannelIndex:
			*p.ChannelIndex = channelIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamFirstSeenUTC:
			*p.FirstSeenUTC = firstSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamFirstSeenUptime:
			*p.FirstSeenUptime = firstSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUTC:
			*p.LastSeenUTC = lastSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUptime:
			*p.LastSeenUptime = lastSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamTagSeenCount:
			*p.TagSeenCount = tagSeenCount(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup1
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamC1G2PC:
			var tmp c1G2PC
			if err := tmp.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			p.C1G2PC = append(p.C1G2PC, tmp)
		case ParamC1G2XPCW1:
			var tmp c1G2XPCW1
			if err := tmp.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			p.C1G2XPCW1 = append(p.C1G2XPCW1, tmp)
		case ParamC1G2XPCW2:
			var tmp c1G2XPCW2
			if err := tmp.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			p.C1G2XPCW2 = append(p.C1G2XPCW2, tmp)
		case ParamC1G2CRC:
			var tmp c1G2CRC
			if err := tmp.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			p.C1G2CRC = append(p.C1G2CRC, tmp)
		default:
			break paramGroup2
		}
		data = data[3:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(data[0] & 0x7F); subType == ParamAccessSpecID {
		*p.AccessSpecID = accessSpecID(binary.BigEndian.Uint32(data[1:]))
	}
	if len(data) == 0 {
		return nil
	}

paramGroup4:
	for len(data) > 1 {
		var pt ParamType
		if data[0]&0x80 == 1 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return errors.Errorf("expecting a TLV header, but %d < 4 byte "+
				"remain", len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamC1G2ReadOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2ReadOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2ReadOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2ReadOpSpecResult = append(p.C1G2ReadOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2WriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2WriteOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2WriteOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2WriteOpSpecResult = append(p.C1G2WriteOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2KillOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2KillOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2KillOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2KillOpSpecResult = append(p.C1G2KillOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2LockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2LockOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2LockOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2LockOpSpecResult = append(p.C1G2LockOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2BlockEraseOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockEraseOpSpecResult says it has "+
					"%d bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2BlockEraseOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2BlockEraseOpSpecResult = append(p.C1G2BlockEraseOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2BlockWriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockWriteOpSpecResult says it has "+
					"%d bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2BlockWriteOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2BlockWriteOpSpecResult = append(p.C1G2BlockWriteOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2RecommissionOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2RecommissionOpSpecResult says it "+
					"has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2RecommissionOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2RecommissionOpSpecResult = append(p.C1G2RecommissionOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2BlockPermalockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockPermalockOpSpecResult says it "+
					"has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2BlockPermalockOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2BlockPermalockOpSpecResult = append(p.C1G2BlockPermalockOpSpecResult, tmp)
			data = data[subLen:]
		case ParamC1G2GetBlockPermalockStatusOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2GetBlockPermalockStatusOpSpecResult says "+
					"it has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			var tmp c1G2GetBlockPermalockStatusOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2GetBlockPermalockStatusOpSpecResult = append(p.C1G2GetBlockPermalockStatusOpSpecResult, tmp)
			data = data[subLen:]
		case ParamClientRequestOpSpecResult:
			var tmp clientRequestOpSpecResult
			if err := tmp.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			p.ClientRequestOpSpecResult = append(p.ClientRequestOpSpecResult, tmp)
			data = data[3:]
		case ParamCustom:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		default:
			break paramGroup4
		}
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading TagReportData, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// epcData is Parameter 241, EPCData.
type epcData struct {
	EPCNumBits uint16
	EPC        []byte
}

// UnmarshalBinary Parameter 241, EPCData.
func (p *epcData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPCData, 2, len(data), false); err != nil {
		return err
	}
	p.EPCNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.EPCNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return errors.Errorf("EPC (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.EPCNumBits, nBytes,
			len(data[2:]))
	} else if nBytes != 0 {
		p.EPC = make([]byte, 1+((int(p.EPCNumBits)-1)>>3))
		copy(p.EPC, data[2:])
		data = data[nBytes+2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EPCData, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// rfSurveyReportData is Parameter 242, RFSurveyReportData.
type rfSurveyReportData struct {
	ROSpecID                *roSpecID
	SpecIndex               *specIndex
	FrequencyRSSILevelEntry []frequencyRSSILevelEntry
	Custom                  []custom
}

// UnmarshalBinary Parameter 242, RFSurveyReportData.
func (p *rfSurveyReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyReportData, 26, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			*p.ROSpecID = roSpecID(binary.BigEndian.Uint32(data[1:]))
		case ParamSpecIndex:
			*p.SpecIndex = specIndex(binary.BigEndian.Uint16(data[1:]))
		default:
			break paramGroup0
		}
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyRSSILevelEntry:
			var tmp frequencyRSSILevelEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyRSSILevelEntry = append(p.FrequencyRSSILevelEntry, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RFSurveyReportData, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// frequencyRSSILevelEntry is Parameter 243, FrequencyRSSILevelEntry.
type frequencyRSSILevelEntry struct {
	Frequency    kHz
	Bandwidth    kHz
	AverageRSSI  dBm8
	PeakRSSI     dBm8
	UTCTimestamp utcTimestamp
	Uptime       uptime
}

// UnmarshalBinary Parameter 243, FrequencyRSSILevelEntry.
func (p *frequencyRSSILevelEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyRSSILevelEntry, 22, len(data), true); err != nil {
		return err
	}
	p.Frequency = binary.BigEndian.Uint32(data)
	p.Bandwidth = binary.BigEndian.Uint32(data[4:])
	p.AverageRSSI = dBm8(data[8])
	p.PeakRSSI = dBm8(data[9])
	data = data[10:]
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUptime says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			p.Uptime = uptime(binary.BigEndian.Uint64(data[4:]))
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamFrequencyRSSILevelEntry", pt)
		}
	}
	return nil
}

// readerEventNotificationSpec is Parameter 244,
// ReaderEventNotificationSpec.
type readerEventNotificationSpec struct {
	EventNotificationState []eventNotificationState
}

// UnmarshalBinary Parameter 244, ReaderEventNotificationSpec.
func (p *readerEventNotificationSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationSpec, 7, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamEventNotificationState:
			var tmp eventNotificationState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.EventNotificationState = append(p.EventNotificationState, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotificationSpec, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// eventNotificationState is Parameter 245, EventNotificationState.
type eventNotificationState struct {
	ReaderEventType     ReaderEventType
	NotificationEnabled bool
}

// UnmarshalBinary Parameter 245, EventNotificationState.
func (p *eventNotificationState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventNotificationState, 3, len(data), true); err != nil {
		return err
	}
	p.ReaderEventType = ReaderEventType(binary.BigEndian.Uint16(data))
	p.NotificationEnabled = data[2]&0x80 != 0
	return nil
}

// readerEventNotificationData is Parameter 246,
// ReaderEventNotificationData.
type readerEventNotificationData struct {
	UTCTimestamp                   utcTimestamp
	Uptime                         uptime
	HoppingEvent                   *hoppingEvent
	GPIEvent                       *gpiEvent
	ROSpecEvent                    *roSpecEvent
	ReportBufferLevelWarningEvent  *reportBufferLevelWarningEvent
	ReportBufferOverflowErrorEvent *reportBufferOverflowErrorEvent
	ReaderExceptionEvent           *readerExceptionEvent
	RFSurveyEvent                  *rfSurveyEvent
	AISpecEvent                    *aiSpecEvent
	AntennaEvent                   *antennaEvent
	ConnectionAttemptEvent         *connectionAttemptEvent
	ConnectionCloseEvent           *connectionCloseEvent
	SpecLoopEvent                  *specLoopEvent
	Custom                         []custom
}

// UnmarshalBinary Parameter 246, ReaderEventNotificationData.
func (p *readerEventNotificationData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationData, 12, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUptime says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			p.Uptime = uptime(binary.BigEndian.Uint64(data[4:]))
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamReaderEventNotificationData", pt)
		}
	}
	data = data[12:]
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamHoppingEvent:
			p.HoppingEvent = new(hoppingEvent)
			*p.HoppingEvent = hoppingEvent(binary.BigEndian.Uint16(data[4:]))
		case ParamGPIEvent:
			p.GPIEvent = new(gpiEvent)
			if err := p.GPIEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROSpecEvent:
			p.ROSpecEvent = new(roSpecEvent)
			if err := p.ROSpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReportBufferLevelWarningEvent:
			p.ReportBufferLevelWarningEvent = new(reportBufferLevelWarningEvent)
			*p.ReportBufferLevelWarningEvent = reportBufferLevelWarningEvent(data[4])
		case ParamReportBufferOverflowErrorEvent:
			p.ReportBufferOverflowErrorEvent = new(reportBufferOverflowErrorEvent)
			if err := p.ReportBufferOverflowErrorEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReaderExceptionEvent:
			p.ReaderExceptionEvent = new(readerExceptionEvent)
			if err := p.ReaderExceptionEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRFSurveyEvent:
			p.RFSurveyEvent = new(rfSurveyEvent)
			if err := p.RFSurveyEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAISpecEvent:
			p.AISpecEvent = new(aiSpecEvent)
			if err := p.AISpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAntennaEvent:
			p.AntennaEvent = new(antennaEvent)
			if err := p.AntennaEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamConnectionAttemptEvent:
			p.ConnectionAttemptEvent = new(connectionAttemptEvent)
			*p.ConnectionAttemptEvent = connectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data[4:])))
		case ParamConnectionCloseEvent:
			p.ConnectionCloseEvent = new(connectionCloseEvent)
			if err := p.ConnectionCloseEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamSpecLoopEvent:
			p.SpecLoopEvent = new(specLoopEvent)
			if err := p.SpecLoopEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotificationData, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// hoppingEvent is Parameter 247, HoppingEvent.
type hoppingEvent uint16

// UnmarshalBinary Parameter 247, HoppingEvent.
func (p *hoppingEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamHoppingEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = hoppingEvent(binary.BigEndian.Uint16(data))
	return nil
}

// gpiEvent is Parameter 248, GPIEvent.
type gpiEvent struct {
	GPIPort  uint16
	GPIEvent bool
}

// UnmarshalBinary Parameter 248, GPIEvent.
func (p *gpiEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIEvent, 3, len(data), true); err != nil {
		return err
	}
	p.GPIPort = binary.BigEndian.Uint16(data)
	p.GPIEvent = data[2]&0x80 != 0
	return nil
}

// roSpecEvent is Parameter 249, ROSpecEvent.
type roSpecEvent struct {
	ROSpecEventType    ROSpecEventType
	ROSpecID           uint32
	PreemptingROSpecID uint32
}

// UnmarshalBinary Parameter 249, ROSpecEvent.
func (p *roSpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecEvent, 9, len(data), true); err != nil {
		return err
	}
	p.ROSpecEventType = ROSpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.PreemptingROSpecID = binary.BigEndian.Uint32(data[5:])
	return nil
}

// reportBufferLevelWarningEvent is Parameter 250,
// ReportBufferLevelWarningEvent.
type reportBufferLevelWarningEvent uint8

// UnmarshalBinary Parameter 250, ReportBufferLevelWarningEvent.
func (p *reportBufferLevelWarningEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferLevelWarningEvent, 1, len(data), true); err != nil {
		return err
	}
	*p = reportBufferLevelWarningEvent(data[0])
	return nil
}

// reportBufferOverflowErrorEvent is Parameter 251,
// ReportBufferOverflowErrorEvent.
type reportBufferOverflowErrorEvent struct{}

// UnmarshalBinary Parameter 251, ReportBufferOverflowErrorEvent.
func (p *reportBufferOverflowErrorEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferOverflowErrorEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// readerExceptionEvent is Parameter 252, ReaderExceptionEvent.
type readerExceptionEvent struct {
	Message                  string
	ROSpecID                 *roSpecID
	SpecIndex                *specIndex
	InventoryParameterSpecID *inventoryParameterSpecID
	AntennaID                *antennaID
	AccessSpecID             *accessSpecID
	OpSpecID                 *opSpecID
	Custom                   []custom
}

// UnmarshalBinary Parameter 252, ReaderExceptionEvent.
func (p *readerExceptionEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderExceptionEvent, 2, len(data), false); err != nil {
		return err
	}
	if strLen := int(binary.BigEndian.Uint16(data)); strLen > len(data[2:]) {
		return errors.Errorf("Message (string) declares it has %d bytes, but "+
			"only %d bytes are available", strLen, len(data[2:]))
	} else if strLen != 0 {
		p.Message = string(data[2 : strLen+2])
		data = data[strLen+2:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			*p.ROSpecID = roSpecID(binary.BigEndian.Uint32(data[1:]))
		case ParamSpecIndex:
			*p.SpecIndex = specIndex(binary.BigEndian.Uint16(data[1:]))
		case ParamInventoryParameterSpecID:
			*p.InventoryParameterSpecID = inventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
		case ParamAntennaID:
			*p.AntennaID = antennaID(binary.BigEndian.Uint16(data[1:]))
		case ParamAccessSpecID:
			*p.AccessSpecID = accessSpecID(binary.BigEndian.Uint32(data[1:]))
		case ParamOpSpecID:
			*p.OpSpecID = opSpecID(binary.BigEndian.Uint16(data[1:]))
		default:
			break paramGroup0
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderExceptionEvent, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// rfSurveyEvent is Parameter 253, RFSurveyEvent.
type rfSurveyEvent struct {
	RFSurveyEventType RFSurveyEventType
	ROSpecID          uint32
}

// UnmarshalBinary Parameter 253, RFSurveyEvent.
func (p *rfSurveyEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyEvent, 5, len(data), true); err != nil {
		return err
	}
	p.RFSurveyEventType = RFSurveyEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	return nil
}

// aiSpecEvent is Parameter 254, AISpecEvent.
type aiSpecEvent struct {
	AISpecEventType        AISpecEventType
	ROSpecID               uint32
	SpecIndex              uint16
	C1G2SingulationDetails *c1G2SingulationDetails
}

// UnmarshalBinary Parameter 254, AISpecEvent.
func (p *aiSpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecEvent, 7, len(data), false); err != nil {
		return err
	}
	p.AISpecEventType = AISpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.SpecIndex = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(data[0] & 0x7F); subType == ParamC1G2SingulationDetails {
		p.C1G2SingulationDetails = new(c1G2SingulationDetails)
		if err := p.C1G2SingulationDetails.UnmarshalBinary(data[1:5]); err != nil {
			return err
		}
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpecEvent, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// antennaEvent is Parameter 255, AntennaEvent.
type antennaEvent struct {
	AntennaEventType AntennaEventType
	AntennaID        uint16
}

// UnmarshalBinary Parameter 255, AntennaEvent.
func (p *antennaEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaEvent, 3, len(data), true); err != nil {
		return err
	}
	p.AntennaEventType = AntennaEventType(data[0])
	p.AntennaID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// connectionAttemptEvent is Parameter 256, ConnectionAttemptEvent.
type connectionAttemptEvent ConnectionAttemptEventType

// UnmarshalBinary Parameter 256, ConnectionAttemptEvent.
func (p *connectionAttemptEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionAttemptEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = connectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data)))
	return nil
}

// connectionCloseEvent is Parameter 257, ConnectionCloseEvent.
type connectionCloseEvent struct{}

// UnmarshalBinary Parameter 257, ConnectionCloseEvent.
func (p *connectionCloseEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionCloseEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// llrpStatus is Parameter 287, LLRPStatus.
type llrpStatus struct {
	Status           StatusCode
	ErrorDescription string
	FieldError       *fieldError
	ParameterError   *parameterError
}

// UnmarshalBinary Parameter 287, LLRPStatus.
func (p *llrpStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPStatus, 4, len(data), false); err != nil {
		return err
	}
	p.Status = StatusCode(binary.BigEndian.Uint16(data))
	if strLen := int(binary.BigEndian.Uint16(data[2:])); strLen > len(data[4:]) {
		return errors.Errorf("ErrorDescription (string) declares it has %d "+
			"bytes, but only %d bytes are available", strLen, len(data[4:]))
	} else if strLen != 0 {
		p.ErrorDescription = string(data[4 : strLen+4])
		data = data[strLen+4:]
	} else {
		data = data[4:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFieldError:
			p.FieldError = new(fieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamParameterError:
			p.ParameterError = new(parameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading LLRPStatus, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// fieldError is Parameter 288, FieldError.
type fieldError struct {
	FieldIndex uint16
	ErrorCode  StatusCode
}

// UnmarshalBinary Parameter 288, FieldError.
func (p *fieldError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFieldError, 4, len(data), true); err != nil {
		return err
	}
	p.FieldIndex = binary.BigEndian.Uint16(data)
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	return nil
}

// parameterError is Parameter 289, ParameterError.
type parameterError struct {
	ParameterType  ParamType
	ErrorCode      StatusCode
	ParameterError *parameterError
	FieldError     *fieldError
}

// UnmarshalBinary Parameter 289, ParameterError.
func (p *parameterError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamParameterError, 4, len(data), false); err != nil {
		return err
	}
	p.ParameterType = ParamType(binary.BigEndian.Uint16(data))
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamParameterError:
			p.ParameterError = new(parameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamFieldError:
			p.FieldError = new(fieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ParameterError, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2LLRPCapabilities is Parameter 327, C1G2LLRPCapabilities.
type c1G2LLRPCapabilities struct {
	C1G2CapabilitiesFlags       C1G2CapabilitiesFlags
	MaxNumSelectFiltersPerQuery uint16
}

// UnmarshalBinary Parameter 327, C1G2LLRPCapabilities.
func (p *c1G2LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LLRPCapabilities, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2CapabilitiesFlags = C1G2CapabilitiesFlags(data[0])
	p.MaxNumSelectFiltersPerQuery = binary.BigEndian.Uint16(data[1:])
	return nil
}

// uhfc1G2RFModeTable is Parameter 328, UHFC1G2RFModeTable.
type uhfc1G2RFModeTable struct {
	UHFC1G2RFModeTableEntry []uhfc1G2RFModeTableEntry
}

// UnmarshalBinary Parameter 328, UHFC1G2RFModeTable.
func (p *uhfc1G2RFModeTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTable, 32, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamUHFC1G2RFModeTableEntry:
			var tmp uhfc1G2RFModeTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.UHFC1G2RFModeTableEntry = append(p.UHFC1G2RFModeTableEntry, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading UHFC1G2RFModeTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// uhfc1G2RFModeTableEntry is Parameter 329, UHFC1G2RFModeTableEntry.
type uhfc1G2RFModeTableEntry struct {
	ModeID                     uint32
	UHFC1G2RFModeFlags         UHFC1G2RFModeFlags
	BackscatterDataRate        bps
	Modulation                 ModulationType
	ForwardLinkModulation      ForwardLinkModulationType
	PulseIntervalEncodingRatio uint32
	MinTariTime                nanoSecs32
	MaxTariTime                nanoSecs32
	StepTariTime               nanoSecs32
	SpectralMask               SpectralMaskType
}

// UnmarshalBinary Parameter 329, UHFC1G2RFModeTableEntry.
func (p *uhfc1G2RFModeTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTableEntry, 28, len(data), true); err != nil {
		return err
	}
	p.ModeID = binary.BigEndian.Uint32(data)
	p.UHFC1G2RFModeFlags = UHFC1G2RFModeFlags(data[4])
	p.BackscatterDataRate = binary.BigEndian.Uint32(data[5:])
	p.Modulation = ModulationType(data[9])
	p.ForwardLinkModulation = ForwardLinkModulationType(data[10])
	p.PulseIntervalEncodingRatio = binary.BigEndian.Uint32(data[11:])
	p.MinTariTime = binary.BigEndian.Uint32(data[15:])
	p.MaxTariTime = binary.BigEndian.Uint32(data[19:])
	p.StepTariTime = binary.BigEndian.Uint32(data[23:])
	p.SpectralMask = SpectralMaskType(data[27])
	return nil
}

// c1G2InventoryCommand is Parameter 330, C1G2InventoryCommand.
type c1G2InventoryCommand struct {
	C1G2InventoryCommandFlags C1G2InventoryCommandFlags
	C1G2Filter                []c1G2Filter
	C1G2RFControl             *c1G2RFControl
	C1G2SingulationControl    *c1G2SingulationControl
	Custom                    []custom
}

// UnmarshalBinary Parameter 330, C1G2InventoryCommand.
func (p *c1G2InventoryCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2InventoryCommand, 1, len(data), false); err != nil {
		return err
	}
	p.C1G2InventoryCommandFlags = C1G2InventoryCommandFlags(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Filter:
			var tmp c1G2Filter
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2Filter = append(p.C1G2Filter, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2RFControl:
			p.C1G2RFControl = new(c1G2RFControl)
			if err := p.C1G2RFControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2SingulationControl:
			p.C1G2SingulationControl = new(c1G2SingulationControl)
			if err := p.C1G2SingulationControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2InventoryCommand, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2Filter is Parameter 331, C1G2Filter.
type c1G2Filter struct {
	C1G2FilterAction                         C1G2FilterActionType
	C1G2TagInventoryMask                     c1G2TagInventoryMask
	C1G2TagInventoryStateAwareFilterAction   *c1G2TagInventoryStateAwareFilterAction
	C1G2TagInventoryStateUnawareFilterAction *c1G2TagInventoryStateUnawareFilterAction
}

// UnmarshalBinary Parameter 331, C1G2Filter.
func (p *c1G2Filter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Filter, 10, len(data), false); err != nil {
		return err
	}
	p.C1G2FilterAction = C1G2FilterActionType(data[0])
	data = data[1:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagInventoryMask {
		return errors.Errorf("expected ParamC1G2TagInventoryMask, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryMask says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.C1G2TagInventoryMask.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2TagInventoryStateAwareFilterAction:
			p.C1G2TagInventoryStateAwareFilterAction = new(c1G2TagInventoryStateAwareFilterAction)
			if err := p.C1G2TagInventoryStateAwareFilterAction.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2TagInventoryStateUnawareFilterAction:
			*p.C1G2TagInventoryStateUnawareFilterAction = c1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[4]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Filter, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// c1G2TagInventoryMask is Parameter 332, C1G2TagInventoryMask.
type c1G2TagInventoryMask struct {
	C1G2MemoryBank     C1G2MemoryBankType
	MostSignificantBit uint16
	TagMaskNumBits     uint16
	TagMask            []byte
}

// UnmarshalBinary Parameter 332, C1G2TagInventoryMask.
func (p *c1G2TagInventoryMask) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryMask, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2MemoryBank = data[0] >> 6
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return errors.Errorf("TagMask (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagMaskNumBits,
			nBytes, len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, 1+((int(p.TagMaskNumBits)-1)>>3))
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TagInventoryMask, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2TagInventoryStateAwareFilterAction is Parameter 333,
// C1G2TagInventoryStateAwareFilterAction.
type c1G2TagInventoryStateAwareFilterAction struct {
	C1G2TagInventoryTarget                 C1G2TagInventoryTargetType
	C1G2TagInventoryStateAwareFilterAction C1G2TagInventoryStateAwareFilterActionType
}

// UnmarshalBinary Parameter 333,
// C1G2TagInventoryStateAwareFilterAction.
func (p *c1G2TagInventoryStateAwareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareFilterAction, 2, len(data), true); err != nil {
		return err
	}
	p.C1G2TagInventoryTarget = C1G2TagInventoryTargetType(data[0])
	p.C1G2TagInventoryStateAwareFilterAction = C1G2TagInventoryStateAwareFilterActionType(data[1])
	return nil
}

// c1G2TagInventoryStateUnawareFilterAction is Parameter 334,
// C1G2TagInventoryStateUnawareFilterAction.
type c1G2TagInventoryStateUnawareFilterAction C1G2TagInventoryStateUnawareFilterActionType

// UnmarshalBinary Parameter 334,
// C1G2TagInventoryStateUnawareFilterAction.
func (p *c1G2TagInventoryStateUnawareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateUnawareFilterAction, 1, len(data), true); err != nil {
		return err
	}
	*p = c1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[0]))
	return nil
}

// c1G2RFControl is Parameter 335, C1G2RFControl.
type c1G2RFControl struct {
	IndexIntoUHFC1G2RFModeTable uint16
	Tari                        nanoSecs16
}

// UnmarshalBinary Parameter 335, C1G2RFControl.
func (p *c1G2RFControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RFControl, 4, len(data), true); err != nil {
		return err
	}
	p.IndexIntoUHFC1G2RFModeTable = binary.BigEndian.Uint16(data)
	p.Tari = binary.BigEndian.Uint16(data[2:])
	return nil
}

// c1G2SingulationControl is Parameter 336, C1G2SingulationControl.
type c1G2SingulationControl struct {
	C1G2SingulationControlSession               C1G2SingulationControlSessionType
	TagPopulation                               uint16
	TagTransitTime                              milliSecs32
	C1G2TagInventoryStateAwareSingulationAction *c1G2TagInventoryStateAwareSingulationAction
}

// UnmarshalBinary Parameter 336, C1G2SingulationControl.
func (p *c1G2SingulationControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationControl, 7, len(data), false); err != nil {
		return err
	}
	p.C1G2SingulationControlSession = C1G2SingulationControlSessionType(data[0])
	p.TagPopulation = binary.BigEndian.Uint16(data[1:])
	p.TagTransitTime = binary.BigEndian.Uint32(data[3:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateAwareSingulationAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryStateAwareSingulationAction "+
				"says it has %d bytes, but only %d bytes remain", subLen, len(data))
		}
		*p.C1G2TagInventoryStateAwareSingulationAction = c1G2TagInventoryStateAwareSingulationAction(C1G2TagInventoryStateAwareSingulationActionFlags(data[4]))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2SingulationControl, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2TagInventoryStateAwareSingulationAction is Parameter 337,
// C1G2TagInventoryStateAwareSingulationAction.
type c1G2TagInventoryStateAwareSingulationAction C1G2TagInventoryStateAwareSingulationActionFlags

// UnmarshalBinary Parameter 337,
// C1G2TagInventoryStateAwareSingulationAction.
func (p *c1G2TagInventoryStateAwareSingulationAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareSingulationAction, 1, len(data), true); err != nil {
		return err
	}
	*p = c1G2TagInventoryStateAwareSingulationAction(C1G2TagInventoryStateAwareSingulationActionFlags(data[0]))
	return nil
}

// c1G2TagSpec is Parameter 338, C1G2TagSpec.
type c1G2TagSpec struct {
	TagPattern1 c1G2TargetTag
	TagPattern2 *c1G2TargetTag
}

// UnmarshalBinary Parameter 338, C1G2TagSpec.
func (p *c1G2TagSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagSpec, 11, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TargetTag {
		return errors.Errorf("expected ParamC1G2TargetTag, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.TagPattern1.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TargetTag {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.TagPattern2 = new(c1G2TargetTag)
		if err := p.TagPattern2.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TagSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2TargetTag is Parameter 339, C1G2TargetTag.
type c1G2TargetTag struct {
	C1G2MemoryBank     C1G2MemoryBankType
	MatchFlag          bool
	MostSignificantBit uint16
	TagMaskNumBits     uint16
	TagMask            []byte
	TagDataNumBits     uint16
	TagData            []byte
}

// UnmarshalBinary Parameter 339, C1G2TargetTag.
func (p *c1G2TargetTag) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TargetTag, 7, len(data), false); err != nil {
		return err
	}
	p.C1G2MemoryBank = data[0] >> 6
	p.MatchFlag = data[0]&0x20 != 0
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return errors.Errorf("TagMask (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagMaskNumBits,
			nBytes, len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, 1+((int(p.TagMaskNumBits)-1)>>3))
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	}
	p.TagDataNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagDataNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return errors.Errorf("TagData (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagDataNumBits,
			nBytes, len(data[2:]))
	} else if nBytes != 0 {
		p.TagData = make([]byte, 1+((int(p.TagDataNumBits)-1)>>3))
		copy(p.TagData, data[2:])
		data = data[nBytes+2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TargetTag, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2Read is Parameter 341, C1G2Read.
type c1G2Read struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 341, C1G2Read.
func (p *c1G2Read) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Read, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2Write is Parameter 342, C1G2Write.
type c1G2Write struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 342, C1G2Write.
func (p *c1G2Write) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Write, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Write, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// c1G2Kill is Parameter 343, C1G2Kill.
type c1G2Kill struct {
	OpSpecID     uint16
	KillPassword uint32
}

// UnmarshalBinary Parameter 343, C1G2Kill.
func (p *c1G2Kill) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Kill, 6, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	return nil
}

// c1G2Lock is Parameter 344, C1G2Lock.
type c1G2Lock struct {
	OpSpecID        uint16
	AccessPassword  uint32
	C1G2LockPayload []c1G2LockPayload
}

// UnmarshalBinary Parameter 344, C1G2Lock.
func (p *c1G2Lock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Lock, 12, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	data = data[6:]
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2LockPayload:
			var tmp c1G2LockPayload
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2LockPayload = append(p.C1G2LockPayload, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Lock, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// c1G2LockPayload is Parameter 345, C1G2LockPayload.
type c1G2LockPayload struct {
	LockPrivilege LockPrivilegeType
	LockData      LockDataType
}

// UnmarshalBinary Parameter 345, C1G2LockPayload.
func (p *c1G2LockPayload) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockPayload, 2, len(data), true); err != nil {
		return err
	}
	p.LockPrivilege = LockPrivilegeType(data[0])
	p.LockData = LockDataType(data[1])
	return nil
}

// c1G2BlockErase is Parameter 346, C1G2BlockErase.
type c1G2BlockErase struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 346, C1G2BlockErase.
func (p *c1G2BlockErase) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockErase, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2BlockWrite is Parameter 347, C1G2BlockWrite.
type c1G2BlockWrite struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 347, C1G2BlockWrite.
func (p *c1G2BlockWrite) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWrite, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockWrite, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2EPCMemorySelector is Parameter 348, C1G2EPCMemorySelector.
type c1G2EPCMemorySelector C1G2EPCMemorySelectorFlags

// UnmarshalBinary Parameter 348, C1G2EPCMemorySelector.
func (p *c1G2EPCMemorySelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2EPCMemorySelector, 1, len(data), true); err != nil {
		return err
	}
	*p = c1G2EPCMemorySelector(C1G2EPCMemorySelectorFlags(data[0]))
	return nil
}

// c1G2ReadOpSpecResult is Parameter 349, C1G2ReadOpSpecResult.
type c1G2ReadOpSpecResult struct {
	C1G2ReadOpSpecResultType C1G2ReadOpSpecResultType
	OpSpecID                 uint16
	Data                     []uint16
}

// UnmarshalBinary Parameter 349, C1G2ReadOpSpecResult.
func (p *c1G2ReadOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2ReadOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2ReadOpSpecResultType = C1G2ReadOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2ReadOpSpecResult, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2WriteOpSpecResult is Parameter 350, C1G2WriteOpSpecResult.
type c1G2WriteOpSpecResult struct {
	C1G2WriteOpSpecResultType C1G2WriteOpSpecResultType
	OpSpecID                  uint16
	WordsWritten              uint16
}

// UnmarshalBinary Parameter 350, C1G2WriteOpSpecResult.
func (p *c1G2WriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2WriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2WriteOpSpecResultType = C1G2WriteOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// c1G2KillOpSpecResult is Parameter 351, C1G2KillOpSpecResult.
type c1G2KillOpSpecResult struct {
	C1G2KillResult C1G2KillResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 351, C1G2KillOpSpecResult.
func (p *c1G2KillOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2KillOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2KillResult = C1G2KillResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2LockOpSpecResult is Parameter 352, C1G2LockOpSpecResult.
type c1G2LockOpSpecResult struct {
	C1G2LockResult C1G2LockResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 352, C1G2LockOpSpecResult.
func (p *c1G2LockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2LockResult = C1G2LockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockEraseOpSpecResult is Parameter 353,
// C1G2BlockEraseOpSpecResult.
type c1G2BlockEraseOpSpecResult struct {
	C1G2BlockEraseResult C1G2BlockEraseResultType
	OpSpecID             uint16
}

// UnmarshalBinary Parameter 353, C1G2BlockEraseOpSpecResult.
func (p *c1G2BlockEraseOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockEraseOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockEraseResult = C1G2BlockEraseResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockWriteOpSpecResult is Parameter 354,
// C1G2BlockWriteOpSpecResult.
type c1G2BlockWriteOpSpecResult struct {
	C1G2BlockWriteResult C1G2BlockWriteResultType
	OpSpecID             uint16
	WordsWritten         uint16
}

// UnmarshalBinary Parameter 354, C1G2BlockWriteOpSpecResult.
func (p *c1G2BlockWriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockWriteResult = C1G2BlockWriteResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// loopSpec is Parameter 355, LoopSpec.
type loopSpec uint32

// UnmarshalBinary Parameter 355, LoopSpec.
func (p *loopSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLoopSpec, 4, len(data), true); err != nil {
		return err
	}
	*p = loopSpec(binary.BigEndian.Uint32(data))
	return nil
}

// specLoopEvent is Parameter 356, SpecLoopEvent.
type specLoopEvent struct {
	ROSpecID  uint32
	LoopCount uint32
}

// UnmarshalBinary Parameter 356, SpecLoopEvent.
func (p *specLoopEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecLoopEvent, 8, len(data), true); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.LoopCount = binary.BigEndian.Uint32(data[4:])
	return nil
}

// c1G2Recommission is Parameter 357, C1G2Recommission.
type c1G2Recommission struct {
	OpSpecID              uint16
	KillPassword          uint32
	C1G2RecommissionFlags C1G2RecommissionFlags
}

// UnmarshalBinary Parameter 357, C1G2Recommission.
func (p *c1G2Recommission) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Recommission, 7, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2RecommissionFlags = C1G2RecommissionFlags(data[6])
	return nil
}

// c1G2BlockPermalock is Parameter 358, C1G2BlockPermalock.
type c1G2BlockPermalock struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockMask      []uint16
}

// UnmarshalBinary Parameter 358, C1G2BlockPermalock.
func (p *c1G2BlockPermalock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalock, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("BlockMask ([]uint16) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.BlockMask = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.BlockMask[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockPermalock, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// c1G2GetBlockPermalockStatus is Parameter 359,
// C1G2GetBlockPermalockStatus.
type c1G2GetBlockPermalockStatus struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockRange     uint16
}

// UnmarshalBinary Parameter 359, C1G2GetBlockPermalockStatus.
func (p *c1G2GetBlockPermalockStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatus, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	p.BlockRange = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2RecommissionOpSpecResult is Parameter 360,
// C1G2RecommissionOpSpecResult.
type c1G2RecommissionOpSpecResult struct {
	C1G2RecommissionResult C1G2RecommissionResultType
	OpSpecID               uint16
}

// UnmarshalBinary Parameter 360, C1G2RecommissionOpSpecResult.
func (p *c1G2RecommissionOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RecommissionOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2RecommissionResult = C1G2RecommissionResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockPermalockOpSpecResult is Parameter 361,
// C1G2BlockPermalockOpSpecResult.
type c1G2BlockPermalockOpSpecResult struct {
	C1G2BlockPermalockResult C1G2BlockPermalockResultType
	OpSpecID                 uint16
}

// UnmarshalBinary Parameter 361, C1G2BlockPermalockOpSpecResult.
func (p *c1G2BlockPermalockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockPermalockResult = C1G2BlockPermalockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2GetBlockPermalockStatusOpSpecResult is Parameter 362,
// C1G2GetBlockPermalockStatusOpSpecResult.
type c1G2GetBlockPermalockStatusOpSpecResult struct {
	C1G2GetBlockPermalockStatusResult C1G2GetBlockPermalockStatusResultType
	OpSpecID                          uint16
	PermalockStatus                   []uint16
}

// UnmarshalBinary Parameter 362,
// C1G2GetBlockPermalockStatusOpSpecResult.
func (p *c1G2GetBlockPermalockStatusOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatusOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2GetBlockPermalockStatusResult = C1G2GetBlockPermalockStatusResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("PermalockStatus ([]uint16) declares it has "+
			"%d*2 bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.PermalockStatus = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.PermalockStatus[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading "+
			"C1G2GetBlockPermalockStatusOpSpecResult, but an unexpected %d bytes "+
			"remain", len(data))
	}
	return nil
}

// maximumReceiveSensitivity is Parameter 363,
// MaximumReceiveSensitivity.
type maximumReceiveSensitivity dBm16

// UnmarshalBinary Parameter 363, MaximumReceiveSensitivity.
func (p *maximumReceiveSensitivity) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamMaximumReceiveSensitivity, 2, len(data), true); err != nil {
		return err
	}
	*p = maximumReceiveSensitivity(dBm16(binary.BigEndian.Uint16(data)))
	return nil
}

// rfSurveyFrequencyCapabilities is Parameter 365,
// RFSurveyFrequencyCapabilities.
type rfSurveyFrequencyCapabilities struct {
	MinFrequency kHz
	MaxFrequency kHz
}

// UnmarshalBinary Parameter 365, RFSurveyFrequencyCapabilities.
func (p *rfSurveyFrequencyCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyFrequencyCapabilities, 8, len(data), true); err != nil {
		return err
	}
	p.MinFrequency = binary.BigEndian.Uint32(data)
	p.MaxFrequency = binary.BigEndian.Uint32(data[4:])
	return nil
}

// custom is Parameter 1023, Custom.
type custom struct {
	VendorID uint32
	Subtype  uint32
	Data     []byte
}

// UnmarshalBinary Parameter 1023, Custom.
func (p *custom) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamCustom, 8, len(data), false); err != nil {
		return err
	}
	p.VendorID = binary.BigEndian.Uint32(data)
	p.Subtype = binary.BigEndian.Uint32(data[4:])
	if len(data)-8 == 0 {
		return nil
	}
	p.Data = make([]byte, len(data)-8)
	copy(p.Data, data[8:])
	data = data[8:]
	return nil
}
