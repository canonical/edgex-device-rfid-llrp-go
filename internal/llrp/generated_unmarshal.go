//
// Copyright (C) 2020 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by "generate_param_code.py -i messages.yaml -t binary_test.go -m generated_marshal.go -u generated_unmarshal.go -e generated_encoder.go"; DO NOT EDIT.
package llrp

import (
	"encoding/binary"
	"github.com/pkg/errors"
)

// DeciBelMilliWatt16 is a 16-bit DeciBelm value. In LLRP, it's used for maximum receive
// sensitivity.
type DeciBelMilliWatt16 = int16

// DeciBelMilliWatt8 is a 8-bit DeciBelm value. In LLRP, it's used to represent RSSI.
type DeciBelMilliWatt8 = int8

// MilliBelIsotropic is DeciBeli*100, i.e., 0.01DeciBeli (DeciBel relative isotropic). In
// LLRP, it's used for fractional DeciBeli antenna gain values.
type MilliBelIsotropic = uint16

// MilliBelMilliWatt is DeciBelm*100, i.e. 0.01DeciBelm or 1 milliBel milliwatt. In LLRP,
// it's used primarily for fractional DeciBelm transmit power values.
type MilliBelMilliWatt = uint16

// DeciBel is 1/10 of a bel, which is the either the log10 of the ratio of a power
// quantity relative a reference, or 2*log10 of the ratio of an amplitude quantity
// relative a reference field.
//
// In LLRP, it's used primarily for receive sensitivity values relative the device maximum
// sensitivity.
type DeciBel = uint16

// MicroSecs64 is a 64-bit number of microseconds.
//
// It's usually used to represent a time offset since a known reference, Unix Epoch or the
// reader's start.
type MicroSecs64 = uint64

// MilliSecs32 is a 32-bit number of milliseconds.
//
// It's used to represent a time offset since a known reference, usually Unix Epoch or a
// message receipt time. Other times, it's used as a time period or timeout, in which case
// 0 may mean "never timeout".
type MilliSecs32 = uint32

// MilliSecs16 is a 16-bit number of milliseconds.
//
// It's used to represent a timeouts or duration triggers.
type MilliSecs16 = uint16

// NanoSecs32 is a 32-bit number of nanoseconds used for some Tari values.
type NanoSecs32 = uint32

// NanoSecs16 is a 16-bit number of nanoseconds as used for some Tari values.
type NanoSecs16 = uint16

// KiloHertz are 1000 cycles per second.
type KiloHertz = uint32

// BitsPerSec are used to describe backscatter data rates.
type BitsPerSec = uint32

// C1G2MemoryBankType selection.
type C1G2MemoryBankType = uint8

// C1G2ProtoConEPCMemLength indicates number of (valid) EPC bits in the EPC Memory (bank
// 1) of a Gen2 tag.
type C1G2ProtoConEPCMemLength = uint8
type C1G2BlockPermalockResultType uint8

const (
	C1G2BPLockSuccess                = C1G2BlockPermalockResultType(0)
	C1G2BPLockInsufficientPower      = C1G2BlockPermalockResultType(1)
	C1G2BPLockNonSpecificTagError    = C1G2BlockPermalockResultType(2)
	C1G2BPLockNoResponseFromTag      = C1G2BlockPermalockResultType(3)
	C1G2BPLockNonSpecificReaderError = C1G2BlockPermalockResultType(4)
	C1G2BPLockIncorrectPassword      = C1G2BlockPermalockResultType(5)
	C1G2BPLockMemoryOverrun          = C1G2BlockPermalockResultType(6)
)

// AirProtocolIDType defines the air protocols LLRP supports for accessing tags.
//
// The air protocol determines how tags are sigulated and access operations performed,
// affects which parameters are permitted in certain contexts, and in theory can vary per
// antenna. In practice, however, there's only ever been a single one defined, and the
// standard hasn't been updated in ten years.
type AirProtocolIDType uint8

const (
	AirProtoUnspecified         = AirProtocolIDType(0)
	AirProtoEPCGlobalClass1Gen2 = AirProtocolIDType(1)
)

// CountryCodeType is an ISO-3166 country code.
type CountryCodeType uint16

const Unspecified = CountryCodeType(0)

// CommStandardType enumerates communication standards known to LLRP.
type CommStandardType uint16
type ROSpecCurrentStateType uint8

const (
	ROSpecStateDisabled = ROSpecCurrentStateType(0)
	ROSpecStateInactive = ROSpecCurrentStateType(1)
	ROSpecStateActive   = ROSpecCurrentStateType(2)
)

type AccessSpecStopTriggerType uint8

const (
	AccessSpecStopTriggerNone           = AccessSpecStopTriggerType(0)
	AccessSpecStopTriggerOperationCount = AccessSpecStopTriggerType(1)
)

type ReaderEventType uint16

const (
	NotifyChannelHop            = ReaderEventType(0)
	NotifyGPI                   = ReaderEventType(1)
	NotifyROSpec                = ReaderEventType(2)
	NotifyReportBuffFillWarn    = ReaderEventType(3)
	NotifyReaderException       = ReaderEventType(4)
	NotifyRFSurvey              = ReaderEventType(5)
	NotifyAISpec                = ReaderEventType(6)
	NotifyAISpecWithSingulation = ReaderEventType(7)
	NotifyAntenna               = ReaderEventType(8)
	NotifySpecLoop              = ReaderEventType(9)
)

type ROSpecEventType uint8

const (
	ROSpecStarted   = ROSpecEventType(0)
	ROSpecEnded     = ROSpecEventType(1)
	ROSpecPreempted = ROSpecEventType(2)
)

type AISpecEventType uint8

const AISpecEnded = AISpecEventType(0)

type RFSurveyEventType uint8

const (
	RFSurveyStarted = RFSurveyEventType(0)
	RFSurveyEnded   = RFSurveyEventType(1)
)

type AntennaEventType uint8

const (
	AntennaDisconnected = AntennaEventType(0)
	AntennaConnected    = AntennaEventType(1)
)

type AccessReportTriggerType uint8
type ROReportTriggerType uint8

const (
	None            = ROReportTriggerType(0)
	NTagsOrAIEnd    = ROReportTriggerType(1)
	NTagsOrROEnd    = ROReportTriggerType(2)
	NSecondsOrAIEnd = ROReportTriggerType(3)
	NSecondsOrROEnd = ROReportTriggerType(4)
	NMillisOrAIEnd  = ROReportTriggerType(5)
	NMillisOrROEnd  = ROReportTriggerType(6)
)

type ConnectionAttemptEventType uint16

const (
	ConnSuccess               = ConnectionAttemptEventType(0)
	ConnExistsReaderInitiated = ConnectionAttemptEventType(1)
	ConnExistsClientInitiated = ConnectionAttemptEventType(2)
	ConnFailedReasonUnknown   = ConnectionAttemptEventType(3)
	ConnAttemptedAgain        = ConnectionAttemptEventType(4)
)

type KeepAliveTriggerType uint8

const (
	KATriggerNone     = KeepAliveTriggerType(0)
	KATriggerPeriodic = KeepAliveTriggerType(1)
)

type ROSpecStartTriggerType uint8

const (
	ROStartTriggerNone      = ROSpecStartTriggerType(0)
	ROStartTriggerImmediate = ROSpecStartTriggerType(1)
	ROStartTriggerPeriodic  = ROSpecStartTriggerType(2)
	ROStartTriggerGPI       = ROSpecStartTriggerType(3)
)

type ROSpecStopTriggerType uint8

const (
	ROStopTriggerNone     = ROSpecStopTriggerType(0)
	ROStopTriggerDuration = ROSpecStopTriggerType(1)
	ROStopTriggerGPI      = ROSpecStopTriggerType(2)
)

type RFSurveySpecStopTriggerType uint8

const (
	RFSurveyStopTriggerNone       = RFSurveySpecStopTriggerType(0)
	RFSurveyStopTriggerDuration   = RFSurveySpecStopTriggerType(1)
	RFSurveyStopTriggerNIteration = RFSurveySpecStopTriggerType(2)
)

// AISpecStopTriggerType specifies when an Antenna Operation should terminate.
type AISpecStopTriggerType uint8

const (
	AIStopTriggerNone           = AISpecStopTriggerType(0)
	AIStopTriggerDuration       = AISpecStopTriggerType(1)
	AIStopTriggerGPI            = AISpecStopTriggerType(2)
	AIStopTriggerTagObservation = AISpecStopTriggerType(3)
)

type TagObservationTriggerType uint8

const (
	TagObsTriggerNTagObservations    = TagObservationTriggerType(0)
	TagObsTriggerNoNewAfterT         = TagObservationTriggerType(1)
	TagObsTriggerNAttempts           = TagObservationTriggerType(2)
	TagObsTriggerNUniqueObservations = TagObservationTriggerType(3)
	TagObsTriggerNoUniqueAfterT      = TagObservationTriggerType(4)
)

type SpectralMaskType uint8

const (
	SpectralMaskUnknown            = SpectralMaskType(0)
	SpectralMaskSingleInterrogator = SpectralMaskType(1)
	SpectralMaskMultiInterrogator  = SpectralMaskType(2)
	SpectralMaskDenseInterrogator  = SpectralMaskType(3)
)

type IDType uint8

const (
	ID_MAC_EUI64 = IDType(0)
	ID_EPC       = IDType(1)
)

// FwdLinkMod enumerates the RF carrier modulation options for a C1G2 Interrogator.
type FwdLinkMod uint8

const (
	DoubleSidebandASK = FwdLinkMod(0)
	SingleSidebandASK = FwdLinkMod(1)
	PhaseReversalASK  = FwdLinkMod(2)
)

// BackscatterMod enumerates the C1G2 sub-carrier modulation types.
type BackscatterMod uint8

const (
	FM0     = BackscatterMod(0)
	Miller2 = BackscatterMod(1)
	Miller4 = BackscatterMod(2)
	Miller8 = BackscatterMod(3)
)

// DivideRatio is used by a tag to determine BLF in C1G2. See UHFC1G2RFModeTable.
type DivideRatio uint8

const (
	DREightToOne       = DivideRatio(0)
	DRSixtyFourToThree = DivideRatio(1)
)

type GPIStateType uint8

const (
	GPIStateLow     = GPIStateType(0)
	GPIStateHigh    = GPIStateType(1)
	GPIStateUnknown = GPIStateType(2)
)

type LockPrivilegeType uint8

const (
	LockPrivRW          = LockPrivilegeType(0)
	LockPrivPermalock   = LockPrivilegeType(1)
	LockPrivPermaunlock = LockPrivilegeType(2)
	LockPrivUnlock      = LockPrivilegeType(3)
)

type LockDataType uint8

const (
	LockDataKillPwd    = LockDataType(0)
	LockDataAccessPwd  = LockDataType(1)
	LockDataEPCMemory  = LockDataType(2)
	LockDataTIDMemory  = LockDataType(3)
	LockDataUserMemory = LockDataType(4)
)

// VersionNum corresponds to an LLRP version number.
//
// The version number is 3 bits and embedded in each message sent between a Reader and
// Client.
//
// By default, this package will attempt to establish connection with Readers using the
// higher version it knows, but you can explicitly override it when creating a connection.
// In either case, for versions greater than 1.0.1, the Client will negotiate versions
// with the Reader and downgrade if necessary.
type VersionNum uint8

const (
	versionUnknown = VersionNum(0)
	Version1_0_1   = VersionNum(1)
	Version1_1     = VersionNum(2)
)

// StatusCode matches LLRP's Status Codes.
//
// These are described in Section 14 of the Low Level Reader Protocol v1.0.1 and in
// Section 15 of Low Level Reader Protocol v1.1.
type StatusCode uint16

const (
	StatusSuccess               = StatusCode(0)
	StatusMsgParamError         = StatusCode(100)
	StatusMsgFieldError         = StatusCode(101)
	StatusMsgParamUnexpected    = StatusCode(102)
	StatusMsgParamMissing       = StatusCode(103)
	StatusMsgParamDuplicate     = StatusCode(104)
	StatusMsgParamOverflow      = StatusCode(105)
	StatusMsgFieldOverflow      = StatusCode(106)
	StatusMsgParamUnknown       = StatusCode(107)
	StatusMsgFieldUnknown       = StatusCode(108)
	StatusMsgMsgUnsupported     = StatusCode(109)
	StatusMsgVerUnsupported     = StatusCode(110)
	StatusMsgParamUnsupported   = StatusCode(111)
	StatusMsgMsgUnexpected      = StatusCode(112)
	StatusParamParamError       = StatusCode(200)
	StatusParamFieldError       = StatusCode(201)
	StatusParamParamUnexpected  = StatusCode(202)
	StatusParamParamMissing     = StatusCode(203)
	StatusParamParamDuplicate   = StatusCode(204)
	StatusParamParamOverflow    = StatusCode(205)
	StatusParamFieldOverflow    = StatusCode(206)
	StatusParamParamUnknown     = StatusCode(207)
	StatusParamFieldUnknown     = StatusCode(208)
	StatusParamParamUnsupported = StatusCode(209)
	StatusFieldInvalid          = StatusCode(300)
	StatusFieldOutOfRange       = StatusCode(301)
	StatusDeviceError           = StatusCode(401)
)

type ReaderCapability uint8

const (
	ReaderCapAll                         = ReaderCapability(0)
	ReaderCapGeneralDeviceCapabilities   = ReaderCapability(1)
	ReaderCapLLRPCapabilities            = ReaderCapability(2)
	ReaderCapRegulatorCapabilities       = ReaderCapability(3)
	ReaderCapAirProtocolLLRPCapabilities = ReaderCapability(4)
)

type ReaderConfigRequestedDataType uint8

const (
	ReaderConfReqAll                  = ReaderConfigRequestedDataType(0)
	ReaderConfReqIdentification       = ReaderConfigRequestedDataType(1)
	ReaderConfReqAntennaProperties    = ReaderConfigRequestedDataType(2)
	ReaderConfReqAntennaConfig        = ReaderConfigRequestedDataType(3)
	ReaderConfReqROReportSpec         = ReaderConfigRequestedDataType(4)
	ReaderConfReqReaderEventNotifSpec = ReaderConfigRequestedDataType(5)
	ReaderConfReqAccessReportSpec     = ReaderConfigRequestedDataType(6)
	ReaderConfReqLLRPConfStateVal     = ReaderConfigRequestedDataType(7)
	ReaderConfReqKeepAliveSpec        = ReaderConfigRequestedDataType(8)
	ReaderConfReqGPIPortCurState      = ReaderConfigRequestedDataType(9)
	ReaderConfReqGPOWriteData         = ReaderConfigRequestedDataType(10)
	ReaderConfReqEventsAndReports     = ReaderConfigRequestedDataType(11)
)

type C1G2BlockEraseResultType uint8
type C1G2GetBlockPermalockStatusResultType uint8
type C1G2BlockWriteResultType uint8
type C1G2KillResultType uint8
type C1G2LockResultType uint8
type C1G2RecommissionResultType uint8
type C1G2WriteOpSpecResultType uint8
type C1G2ReadOpSpecResultType uint8
type C1G2TagInventoryTargetType uint8

const (
	InvTargetSL            = C1G2TagInventoryTargetType(0)
	InvTargetInventoriedS0 = C1G2TagInventoryTargetType(1)
	InvTargetInventoriedS1 = C1G2TagInventoryTargetType(2)
	InvTargetInventoriedS2 = C1G2TagInventoryTargetType(3)
	InvTargetInventoriedS3 = C1G2TagInventoryTargetType(4)
)

type C1G2FilterTruncateActionType uint8

const (
	FilterActionUnspecified   = C1G2FilterTruncateActionType(0)
	FilterActionDoNotTruncate = C1G2FilterTruncateActionType(1)
	FilterActionTruncate      = C1G2FilterTruncateActionType(2)
)

type C1G2TagInventoryStateAwareFilterActionType uint8
type SingActAwareState uint8

const (
	SingActAwareStateA = SingActAwareState(0)
	SingActAwareStateB = SingActAwareState(1)
)

type C1G2TagInventoryStateUnawareFilterActionType uint8
type C1G2SingulationSession = uint8
type C1G2RecommissionFlags uint8

const (
	MsgGetSupportedVersion           = MessageType(46)
	MsgGetSupportedVersionResponse   = MessageType(56)
	MsgSetProtocolVersion            = MessageType(47)
	MsgSetProtocolVersionResponse    = MessageType(57)
	MsgGetReaderCapabilities         = MessageType(1)
	MsgGetReaderCapabilitiesResponse = MessageType(11)
	MsgAddROSpec                     = MessageType(20)
	MsgAddROSpecResponse             = MessageType(30)
	MsgDeleteROSpec                  = MessageType(21)
	MsgDeleteROSpecResponse          = MessageType(31)
	MsgStartROSpec                   = MessageType(22)
	MsgStartROSpecResponse           = MessageType(32)
	MsgStopROSpec                    = MessageType(23)
	MsgStopROSpecResponse            = MessageType(33)
	MsgEnableROSpec                  = MessageType(24)
	MsgEnableROSpecResponse          = MessageType(34)
	MsgDisableROSpec                 = MessageType(25)
	MsgDisableROSpecResponse         = MessageType(35)
	MsgGetROSpecs                    = MessageType(26)
	MsgGetROSpecsResponse            = MessageType(36)
	MsgAddAccessSpec                 = MessageType(40)
	MsgAddAccessSpecResponse         = MessageType(50)
	MsgDeleteAccessSpec              = MessageType(41)
	MsgDeleteAccessSpecResponse      = MessageType(51)
	MsgEnableAccessSpec              = MessageType(42)
	MsgEnableAccessSpecResponse      = MessageType(52)
	MsgDisableAccessSpec             = MessageType(43)
	MsgDisableAccessSpecResponse     = MessageType(53)
	MsgGetAccessSpecs                = MessageType(44)
	MsgGetAccessSpecsResponse        = MessageType(54)
	MsgClientRequestOp               = MessageType(45)
	MsgClientRequestOpResponse       = MessageType(55)
	MsgGetReport                     = MessageType(60)
	MsgROAccessReport                = MessageType(61)
	MsgKeepAlive                     = MessageType(62)
	MsgKeepAliveAck                  = MessageType(72)
	MsgReaderEventNotification       = MessageType(63)
	MsgEnableEventsAndReports        = MessageType(64)
	MsgErrorMessage                  = MessageType(100)
	MsgGetReaderConfig               = MessageType(2)
	MsgGetReaderConfigResponse       = MessageType(12)
	MsgSetReaderConfig               = MessageType(3)
	MsgSetReaderConfigResponse       = MessageType(13)
	MsgCloseConnection               = MessageType(14)
	MsgCloseConnectionResponse       = MessageType(4)
	MsgCustomMessage                 = MessageType(1023)
)

// hasEnoughBytes returns an error if there aren't enough bytes to read the parameter.
func hasEnoughBytes(pt ParamType, needed, got int, exact bool) error {
	if needed <= got {
		return nil
	}
	if exact && needed == 0 {
		return errors.Errorf("%v must be empty, but received %d byte(s)",
			pt, got)
	} else if exact {
		return errors.Errorf("%v requires exactly %d byte(s), but received "+
			"%d", pt, needed, got)
	}
	return errors.Errorf("%v requires at least %d byte(s), but received "+
		"%d", pt, needed, got)
}

// GetSupportedVersion is Message 46, GetSupportedVersion.
type GetSupportedVersion struct{}

// UnmarshalBinary Message 46, GetSupportedVersion.
func (m *GetSupportedVersion) UnmarshalBinary(data []byte) error {
	// GetSupportedVersion is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetSupportedVersion should be empty, but has "+
			"%d bytes", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetSupportedVersion) Type() MessageType {
	return MsgGetSupportedVersion
}

// GetSupportedVersionResponse is Message 56, GetSupportedVersionResponse.
type GetSupportedVersionResponse struct {
	CurrentVersion      VersionNum
	MaxSupportedVersion VersionNum
	LLRPStatus          LLRPStatus
}

// UnmarshalBinary Message 56, GetSupportedVersionResponse.
func (m *GetSupportedVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("GetSupportedVersionResponse length should be "+
			"at least 10, but is %d", len(data))
	}
	m.CurrentVersion = VersionNum(data[0] >> 5)
	m.MaxSupportedVersion = VersionNum(data[1] >> 5)
	data = data[2:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetSupportedVersionResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetSupportedVersionResponse) Type() MessageType {
	return MsgGetSupportedVersionResponse
}

// Status returns this message's LLRPStatus
func (m *GetSupportedVersionResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// SetProtocolVersion is Message 47, SetProtocolVersion.
type SetProtocolVersion struct {
	TargetVersion VersionNum
}

// UnmarshalBinary Message 47, SetProtocolVersion.
func (m *SetProtocolVersion) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("SetProtocolVersion should length should be "+
			"exactly 1, but is %d", len(data))
	}
	m.TargetVersion = VersionNum(data[0] >> 5)
	return nil
}

// Type returns this message's MessageType
func (*SetProtocolVersion) Type() MessageType {
	return MsgSetProtocolVersion
}

// SetProtocolVersionResponse is Message 57, SetProtocolVersionResponse.
type SetProtocolVersionResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 57, SetProtocolVersionResponse.
func (m *SetProtocolVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("SetProtocolVersionResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetProtocolVersionResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*SetProtocolVersionResponse) Type() MessageType {
	return MsgSetProtocolVersionResponse
}

// Status returns this message's LLRPStatus
func (m *SetProtocolVersionResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// GetReaderCapabilities is Message 1, GetReaderCapabilities.
type GetReaderCapabilities struct {
	ReaderCapabilitiesRequestedData ReaderCapability
	Custom                          []Custom
}

// UnmarshalBinary Message 1, GetReaderCapabilities.
func (m *GetReaderCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("GetReaderCapabilities length should be at "+
			"least 1, but is %d", len(data))
	}
	m.ReaderCapabilitiesRequestedData = ReaderCapability(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetReaderCapabilities) Type() MessageType {
	return MsgGetReaderCapabilities
}

// GetReaderCapabilitiesResponse is Message 11, GetReaderCapabilitiesResponse.
type GetReaderCapabilitiesResponse struct {
	LLRPStatus                LLRPStatus
	GeneralDeviceCapabilities *GeneralDeviceCapabilities
	LLRPCapabilities          *LLRPCapabilities
	RegulatoryCapabilities    *RegulatoryCapabilities
	C1G2LLRPCapabilities      *C1G2LLRPCapabilities
	Custom                    []Custom
}

// UnmarshalBinary Message 11, GetReaderCapabilitiesResponse.
func (m *GetReaderCapabilitiesResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetReaderCapabilitiesResponse length should be "+
			"at least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGeneralDeviceCapabilities:
			m.GeneralDeviceCapabilities = new(GeneralDeviceCapabilities)
			if err := m.GeneralDeviceCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamLLRPCapabilities:
			m.LLRPCapabilities = new(LLRPCapabilities)
			if err := m.LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRegulatoryCapabilities:
			m.RegulatoryCapabilities = new(RegulatoryCapabilities)
			if err := m.RegulatoryCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2LLRPCapabilities:
			m.C1G2LLRPCapabilities = new(C1G2LLRPCapabilities)
			if err := m.C1G2LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading "+
			"GetReaderCapabilitiesResponse, but an unexpected %d bytes remain",
			len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetReaderCapabilitiesResponse) Type() MessageType {
	return MsgGetReaderCapabilitiesResponse
}

// Status returns this message's LLRPStatus
func (m *GetReaderCapabilitiesResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// AddROSpec is Message 20, AddROSpec.
//
// AddROSpec adds an Reader Operation Specification.
//
// ROSpecs must be added in the Disabled state, and it's up to the client to set the
// ROSpecID. That ID is used to reference the spec in other messages.
type AddROSpec struct {
	ROSpec ROSpec
}

// UnmarshalBinary Message 20, AddROSpec.
func (m *AddROSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 19 {
		return errors.Errorf("AddROSpec length should be at least 19, but is "+
			"%d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpec {
		return errors.Errorf("expected ParamROSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpec says it has %d bytes, but only %d "+
				"bytes remain", subLen, len(data))
		}
		if err := m.ROSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddROSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*AddROSpec) Type() MessageType {
	return MsgAddROSpec
}

// AddROSpecResponse is Message 30, AddROSpecResponse.
type AddROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 30, AddROSpecResponse.
func (m *AddROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("AddROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*AddROSpecResponse) Type() MessageType {
	return MsgAddROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *AddROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// DeleteROSpec is Message 21, DeleteROSpec.
type DeleteROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 21, DeleteROSpec.
func (m *DeleteROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DeleteROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*DeleteROSpec) Type() MessageType {
	return MsgDeleteROSpec
}

// DeleteROSpecResponse is Message 31, DeleteROSpecResponse.
type DeleteROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 31, DeleteROSpecResponse.
func (m *DeleteROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DeleteROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*DeleteROSpecResponse) Type() MessageType {
	return MsgDeleteROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *DeleteROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// StartROSpec is Message 22, StartROSpec.
type StartROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 22, StartROSpec.
func (m *StartROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("StartROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*StartROSpec) Type() MessageType {
	return MsgStartROSpec
}

// StartROSpecResponse is Message 32, StartROSpecResponse.
type StartROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 32, StartROSpecResponse.
func (m *StartROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("StartROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading StartROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*StartROSpecResponse) Type() MessageType {
	return MsgStartROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *StartROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// StopROSpec is Message 23, StopROSpec.
//
// StopROSpec stops a spec if it's currently executing, overriding all other priorities
// and moving it to Inactive.
type StopROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 23, StopROSpec.
func (m *StopROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("StopROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*StopROSpec) Type() MessageType {
	return MsgStopROSpec
}

// StopROSpecResponse is Message 33, StopROSpecResponse.
type StopROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 33, StopROSpecResponse.
func (m *StopROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("StopROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading StopROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*StopROSpecResponse) Type() MessageType {
	return MsgStopROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *StopROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// EnableROSpec is Message 24, EnableROSpec.
//
// EnableROSpec moves and ROSpec from Disabled to Inactive.
//
// The SpecID may be 0, in which case all ROSpecs will be enabled. If the ROSpec has an
// Immediate start trigger, enabling it will also activate it, provided no other necessary
// prevent it from starting (e.g., its priority is lower than another enabled spec).
type EnableROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 24, EnableROSpec.
func (m *EnableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("EnableROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*EnableROSpec) Type() MessageType {
	return MsgEnableROSpec
}

// EnableROSpecResponse is Message 34, EnableROSpecResponse.
type EnableROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 34, EnableROSpecResponse.
func (m *EnableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("EnableROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*EnableROSpecResponse) Type() MessageType {
	return MsgEnableROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *EnableROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// DisableROSpec is Message 25, DisableROSpec.
type DisableROSpec struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 25, DisableROSpec.
func (m *DisableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DisableROSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*DisableROSpec) Type() MessageType {
	return MsgDisableROSpec
}

// DisableROSpecResponse is Message 35, DisableROSpecResponse.
type DisableROSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 35, DisableROSpecResponse.
func (m *DisableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DisableROSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*DisableROSpecResponse) Type() MessageType {
	return MsgDisableROSpecResponse
}

// Status returns this message's LLRPStatus
func (m *DisableROSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// GetROSpecs is Message 26, GetROSpecs.
type GetROSpecs struct{}

// UnmarshalBinary Message 26, GetROSpecs.
func (m *GetROSpecs) UnmarshalBinary(data []byte) error {
	// GetROSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetROSpecs should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetROSpecs) Type() MessageType {
	return MsgGetROSpecs
}

// GetROSpecsResponse is Message 36, GetROSpecsResponse.
type GetROSpecsResponse struct {
	LLRPStatus LLRPStatus
	ROSpecs    []ROSpec
}

// UnmarshalBinary Message 36, GetROSpecsResponse.
func (m *GetROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetROSpecsResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROSpec:
			var tmp ROSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.ROSpecs = append(m.ROSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetROSpecsResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetROSpecsResponse) Type() MessageType {
	return MsgGetROSpecsResponse
}

// Status returns this message's LLRPStatus
func (m *GetROSpecsResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// AddAccessSpec is Message 40, AddAccessSpec.
type AddAccessSpec struct {
	AccessSpec AccessSpec
}

// UnmarshalBinary Message 40, AddAccessSpec.
func (m *AddAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 23 {
		return errors.Errorf("AddAccessSpec length should be at least 23, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpec {
		return errors.Errorf("expected ParamAccessSpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.AccessSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddAccessSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*AddAccessSpec) Type() MessageType {
	return MsgAddAccessSpec
}

// AddAccessSpecResponse is Message 50, AddAccessSpecResponse.
type AddAccessSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 50, AddAccessSpecResponse.
func (m *AddAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("AddAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AddAccessSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*AddAccessSpecResponse) Type() MessageType {
	return MsgAddAccessSpecResponse
}

// Status returns this message's LLRPStatus
func (m *AddAccessSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// DeleteAccessSpec is Message 41, DeleteAccessSpec.
type DeleteAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 41, DeleteAccessSpec.
func (m *DeleteAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DeleteAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*DeleteAccessSpec) Type() MessageType {
	return MsgDeleteAccessSpec
}

// DeleteAccessSpecResponse is Message 51, DeleteAccessSpecResponse.
type DeleteAccessSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 51, DeleteAccessSpecResponse.
func (m *DeleteAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DeleteAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteAccessSpecResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*DeleteAccessSpecResponse) Type() MessageType {
	return MsgDeleteAccessSpecResponse
}

// Status returns this message's LLRPStatus
func (m *DeleteAccessSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// EnableAccessSpec is Message 42, EnableAccessSpec.
type EnableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 42, EnableAccessSpec.
func (m *EnableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("EnableAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*EnableAccessSpec) Type() MessageType {
	return MsgEnableAccessSpec
}

// EnableAccessSpecResponse is Message 52, EnableAccessSpecResponse.
type EnableAccessSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 52, EnableAccessSpecResponse.
func (m *EnableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("EnableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableAccessSpecResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*EnableAccessSpecResponse) Type() MessageType {
	return MsgEnableAccessSpecResponse
}

// Status returns this message's LLRPStatus
func (m *EnableAccessSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// DisableAccessSpec is Message 43, DisableAccessSpec.
type DisableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 43, DisableAccessSpec.
func (m *DisableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("DisableAccessSpec should length should be "+
			"exactly 4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// Type returns this message's MessageType
func (*DisableAccessSpec) Type() MessageType {
	return MsgDisableAccessSpec
}

// DisableAccessSpecResponse is Message 53, DisableAccessSpecResponse.
type DisableAccessSpecResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 53, DisableAccessSpecResponse.
func (m *DisableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("DisableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableAccessSpecResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*DisableAccessSpecResponse) Type() MessageType {
	return MsgDisableAccessSpecResponse
}

// Status returns this message's LLRPStatus
func (m *DisableAccessSpecResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// GetAccessSpecs is Message 44, GetAccessSpecs.
type GetAccessSpecs struct{}

// UnmarshalBinary Message 44, GetAccessSpecs.
func (m *GetAccessSpecs) UnmarshalBinary(data []byte) error {
	// GetAccessSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetAccessSpecs should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetAccessSpecs) Type() MessageType {
	return MsgGetAccessSpecs
}

// GetAccessSpecsResponse is Message 54, GetAccessSpecsResponse.
type GetAccessSpecsResponse struct {
	LLRPStatus  LLRPStatus
	AccessSpecs []AccessSpec
}

// UnmarshalBinary Message 54, GetAccessSpecsResponse.
func (m *GetAccessSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetAccessSpecsResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAccessSpec:
			var tmp AccessSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AccessSpecs = append(m.AccessSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetAccessSpecsResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetAccessSpecsResponse) Type() MessageType {
	return MsgGetAccessSpecsResponse
}

// Status returns this message's LLRPStatus
func (m *GetAccessSpecsResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// ClientRequestOp is Message 45, ClientRequestOp.
type ClientRequestOp struct {
	TagReportData TagReportData
}

// UnmarshalBinary Message 45, ClientRequestOp.
func (m *ClientRequestOp) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ClientRequestOp length should be at least 10, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportData {
		return errors.Errorf("expected ParamTagReportData, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportData says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.TagReportData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestOp, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*ClientRequestOp) Type() MessageType {
	return MsgClientRequestOp
}

// ClientRequestOpResponse is Message 55, ClientRequestOpResponse.
type ClientRequestOpResponse struct {
	ClientRequestResponse ClientRequestResponse
}

// UnmarshalBinary Message 55, ClientRequestOpResponse.
func (m *ClientRequestOpResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return errors.Errorf("ClientRequestOpResponse length should be at "+
			"least 14, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamClientRequestResponse {
		return errors.Errorf("expected ParamClientRequestResponse, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamClientRequestResponse says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := m.ClientRequestResponse.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestOpResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*ClientRequestOpResponse) Type() MessageType {
	return MsgClientRequestOpResponse
}

// GetReport is Message 60, GetReport.
type GetReport struct{}

// UnmarshalBinary Message 60, GetReport.
func (m *GetReport) UnmarshalBinary(data []byte) error {
	// GetReport is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetReport should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetReport) Type() MessageType {
	return MsgGetReport
}

// ROAccessReport is Message 61, ROAccessReport.
type ROAccessReport struct {
	TagReportData      []TagReportData
	RFSurveyReportData []RFSurveyReportData
	Custom             []Custom
}

// UnmarshalBinary Message 61, ROAccessReport.
func (m *ROAccessReport) UnmarshalBinary(data []byte) error {
	if len(data) < 0 {
		return errors.Errorf("ROAccessReport length should be at least 0, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTagReportData:
			var tmp TagReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.TagReportData = append(m.TagReportData, tmp)
		case ParamRFSurveyReportData:
			var tmp RFSurveyReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.RFSurveyReportData = append(m.RFSurveyReportData, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROAccessReport, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*ROAccessReport) Type() MessageType {
	return MsgROAccessReport
}

// KeepAlive is Message 62, KeepAlive.
type KeepAlive struct{}

// UnmarshalBinary Message 62, KeepAlive.
func (m *KeepAlive) UnmarshalBinary(data []byte) error {
	// KeepAlive is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAlive should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*KeepAlive) Type() MessageType {
	return MsgKeepAlive
}

// KeepAliveAck is Message 72, KeepAliveAck.
type KeepAliveAck struct{}

// UnmarshalBinary Message 72, KeepAliveAck.
func (m *KeepAliveAck) UnmarshalBinary(data []byte) error {
	// KeepAliveAck is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAliveAck should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*KeepAliveAck) Type() MessageType {
	return MsgKeepAliveAck
}

// ReaderEventNotification is Message 63, ReaderEventNotification.
type ReaderEventNotification struct {
	ReaderEventNotificationData ReaderEventNotificationData
}

// UnmarshalBinary Message 63, ReaderEventNotification.
func (m *ReaderEventNotification) UnmarshalBinary(data []byte) error {
	if len(data) < 16 {
		return errors.Errorf("ReaderEventNotification length should be at "+
			"least 16, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamReaderEventNotificationData {
		return errors.Errorf("expected ParamReaderEventNotificationData, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationData says it has "+
				"%d bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := m.ReaderEventNotificationData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotification, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*ReaderEventNotification) Type() MessageType {
	return MsgReaderEventNotification
}

// EnableEventsAndReports is Message 64, EnableEventsAndReports.
type EnableEventsAndReports struct{}

// UnmarshalBinary Message 64, EnableEventsAndReports.
func (m *EnableEventsAndReports) UnmarshalBinary(data []byte) error {
	// EnableEventsAndReports is a header-only message
	if len(data) > 0 {
		return errors.Errorf("EnableEventsAndReports should be empty, but "+
			"has %d bytes", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*EnableEventsAndReports) Type() MessageType {
	return MsgEnableEventsAndReports
}

// ErrorMessage is Message 100, ErrorMessage.
type ErrorMessage struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 100, ErrorMessage.
func (m *ErrorMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ErrorMessage length should be at least 8, but "+
			"is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ErrorMessage, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*ErrorMessage) Type() MessageType {
	return MsgErrorMessage
}

// Status returns this message's LLRPStatus
func (m *ErrorMessage) Status() LLRPStatus {
	return m.LLRPStatus
}

// GetReaderConfig is Message 2, GetReaderConfig.
type GetReaderConfig struct {
	AntennaID     uint16
	RequestedData ReaderConfigRequestedDataType
	GPIPortNum    uint16
	GPOPortNum    uint16
	Custom        []Custom
}

// UnmarshalBinary Message 2, GetReaderConfig.
func (m *GetReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("GetReaderConfig length should be at least 7, "+
			"but is %d", len(data))
	}
	m.AntennaID = binary.BigEndian.Uint16(data)
	m.RequestedData = ReaderConfigRequestedDataType(data[2])
	m.GPIPortNum = binary.BigEndian.Uint16(data[3:])
	m.GPOPortNum = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetReaderConfig) Type() MessageType {
	return MsgGetReaderConfig
}

// GetReaderConfigResponse is Message 12, GetReaderConfigResponse.
type GetReaderConfigResponse struct {
	LLRPStatus                  LLRPStatus
	Identification              *Identification
	AntennaProperties           []AntennaProperties
	AntennaConfigurations       []AntennaConfiguration
	ReaderEventNotificationSpec *ReaderEventNotificationSpec
	ROReportSpec                *ROReportSpec
	AccessReportSpec            *AccessReportSpec
	LLRPConfigurationStateValue *LLRPConfigurationStateValue
	KeepAliveSpec               *KeepAliveSpec
	GPIPortCurrentStates        []GPIPortCurrentState
	GPOWriteData                []GPOWriteData
	EventsAndReports            *EventsAndReports
	Custom                      []Custom
}

// UnmarshalBinary Message 12, GetReaderConfigResponse.
func (m *GetReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("GetReaderConfigResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamIdentification {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamIdentification says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		m.Identification = new(Identification)
		if err := m.Identification.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp AntennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfigurations = append(m.AntennaConfigurations, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReaderEventNotificationSpec:
			m.ReaderEventNotificationSpec = new(ReaderEventNotificationSpec)
			if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROReportSpec:
			m.ROReportSpec = new(ROReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			m.AccessReportSpec = new(AccessReportSpec)
			*m.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		case ParamLLRPConfigurationStateValue:
			m.LLRPConfigurationStateValue = new(LLRPConfigurationStateValue)
			*m.LLRPConfigurationStateValue = LLRPConfigurationStateValue(binary.BigEndian.Uint32(data[4:]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(KeepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup4:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPIPortCurrentState:
			var tmp GPIPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentStates = append(m.GPIPortCurrentStates, tmp)
		case ParamGPOWriteData:
			var tmp GPOWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		default:
			break paramGroup4
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		m.EventsAndReports = new(EventsAndReports)
		*m.EventsAndReports = EventsAndReports(data[4]>>7 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup6:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup6
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GetReaderConfigResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*GetReaderConfigResponse) Type() MessageType {
	return MsgGetReaderConfigResponse
}

// Status returns this message's LLRPStatus
func (m *GetReaderConfigResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// SetReaderConfig is Message 3, SetReaderConfig.
type SetReaderConfig struct {
	ResetToFactoryDefaults      bool
	ReaderEventNotificationSpec *ReaderEventNotificationSpec
	AntennaProperties           []AntennaProperties
	AntennaConfigurations       []AntennaConfiguration
	ROReportSpec                *ROReportSpec
	AccessReportSpec            *AccessReportSpec
	KeepAliveSpec               *KeepAliveSpec
	GPOWriteData                []GPOWriteData
	GPIPortCurrentStates        []GPIPortCurrentState
	EventsAndReports            *EventsAndReports
	Custom                      []Custom
}

// UnmarshalBinary Message 3, SetReaderConfig.
func (m *SetReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("SetReaderConfig length should be at least 1, "+
			"but is %d", len(data))
	}
	m.ResetToFactoryDefaults = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderEventNotificationSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationSpec says it has "+
				"%d bytes, but only %d bytes remain", subLen, len(data))
		}
		m.ReaderEventNotificationSpec = new(ReaderEventNotificationSpec)
		if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp AntennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfigurations = append(m.AntennaConfigurations, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROReportSpec:
			m.ROReportSpec = new(ROReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			m.AccessReportSpec = new(AccessReportSpec)
			*m.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(KeepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPOWriteData:
			var tmp GPOWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		case ParamGPIPortCurrentState:
			var tmp GPIPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentStates = append(m.GPIPortCurrentStates, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		m.EventsAndReports = new(EventsAndReports)
		*m.EventsAndReports = EventsAndReports(data[4]>>7 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup5:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup5
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*SetReaderConfig) Type() MessageType {
	return MsgSetReaderConfig
}

// SetReaderConfigResponse is Message 13, SetReaderConfigResponse.
type SetReaderConfigResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 13, SetReaderConfigResponse.
func (m *SetReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("SetReaderConfigResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading SetReaderConfigResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*SetReaderConfigResponse) Type() MessageType {
	return MsgSetReaderConfigResponse
}

// Status returns this message's LLRPStatus
func (m *SetReaderConfigResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// CloseConnection is Message 14, CloseConnection.
type CloseConnection struct{}

// UnmarshalBinary Message 14, CloseConnection.
func (m *CloseConnection) UnmarshalBinary(data []byte) error {
	// CloseConnection is a header-only message
	if len(data) > 0 {
		return errors.Errorf("CloseConnection should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*CloseConnection) Type() MessageType {
	return MsgCloseConnection
}

// CloseConnectionResponse is Message 4, CloseConnectionResponse.
type CloseConnectionResponse struct {
	LLRPStatus LLRPStatus
}

// UnmarshalBinary Message 4, CloseConnectionResponse.
func (m *CloseConnectionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("CloseConnectionResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading CloseConnectionResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// Type returns this message's MessageType
func (*CloseConnectionResponse) Type() MessageType {
	return MsgCloseConnectionResponse
}

// Status returns this message's LLRPStatus
func (m *CloseConnectionResponse) Status() LLRPStatus {
	return m.LLRPStatus
}

// CustomMessage is Message 1023, CustomMessage.
type CustomMessage struct {
	VendorID       uint32
	MessageSubtype uint8
	Data           []byte
}

// UnmarshalBinary Message 1023, CustomMessage.
func (m *CustomMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("CustomMessage length should be at least 5, but "+
			"is %d", len(data))
	}
	m.VendorID = binary.BigEndian.Uint32(data)
	m.MessageSubtype = data[4]
	if len(data)-5 == 0 {
		return nil
	}
	m.Data = make([]byte, len(data)-5)
	copy(m.Data, data[5:])
	data = data[5:]
	return nil
}

// Type returns this message's MessageType
func (*CustomMessage) Type() MessageType {
	return MsgCustomMessage
}

// AntennaID is Parameter 1, AntennaID.
type AntennaID uint16

// UnmarshalBinary Parameter 1, AntennaID.
func (p *AntennaID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaID, 2, len(data), true); err != nil {
		return err
	}
	*p = AntennaID(binary.BigEndian.Uint16(data))
	return nil
}

// FirstSeenUTC is Parameter 2, FirstSeenUTC.
type FirstSeenUTC MicroSecs64

// UnmarshalBinary Parameter 2, FirstSeenUTC.
func (p *FirstSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = FirstSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// FirstSeenUptime is Parameter 3, FirstSeenUptime.
type FirstSeenUptime MicroSecs64

// UnmarshalBinary Parameter 3, FirstSeenUptime.
func (p *FirstSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = FirstSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// LastSeenUTC is Parameter 4, LastSeenUTC.
type LastSeenUTC MicroSecs64

// UnmarshalBinary Parameter 4, LastSeenUTC.
func (p *LastSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = LastSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// LastSeenUptime is Parameter 5, LastSeenUptime.
type LastSeenUptime MicroSecs64

// UnmarshalBinary Parameter 5, LastSeenUptime.
func (p *LastSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = LastSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// PeakRSSI is Parameter 6, PeakRSSI.
type PeakRSSI DeciBelMilliWatt8

// UnmarshalBinary Parameter 6, PeakRSSI.
func (p *PeakRSSI) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeakRSSI, 1, len(data), true); err != nil {
		return err
	}
	*p = PeakRSSI(DeciBelMilliWatt8(data[0]))
	return nil
}

// ChannelIndex is Parameter 7, ChannelIndex.
type ChannelIndex uint16

// UnmarshalBinary Parameter 7, ChannelIndex.
func (p *ChannelIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamChannelIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = ChannelIndex(binary.BigEndian.Uint16(data))
	return nil
}

// TagSeenCount is Parameter 8, TagSeenCount.
type TagSeenCount uint16

// UnmarshalBinary Parameter 8, TagSeenCount.
func (p *TagSeenCount) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagSeenCount, 2, len(data), true); err != nil {
		return err
	}
	*p = TagSeenCount(binary.BigEndian.Uint16(data))
	return nil
}

// ROSpecID is Parameter 9, ROSpecID.
type ROSpecID uint32

// UnmarshalBinary Parameter 9, ROSpecID.
func (p *ROSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = ROSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// InventoryParameterSpecID is Parameter 10, InventoryParameterSpecID.
type InventoryParameterSpecID uint16

// UnmarshalBinary Parameter 10, InventoryParameterSpecID.
func (p *InventoryParameterSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = InventoryParameterSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// C1G2CRC is Parameter 11, C1G2CRC.
type C1G2CRC uint16

// UnmarshalBinary Parameter 11, C1G2CRC.
func (p *C1G2CRC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2CRC, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2CRC(binary.BigEndian.Uint16(data))
	return nil
}

// C1G2PC is Parameter 12, C1G2PC.
//
// This is the 16-bit Protocol Control field of the EPC Memory (bank 1). It indicates the
// number of EPC bits a tag returns to a reader, (regardless of the physical memory bank
// size), whether or not the tag has user memory (and contains data), whether or not an
// XPC is present, and whether the EPC memory bank contains a binary encoded EPC or an ISO
// Unique Item Identifier.
type C1G2PC struct {
	EPCMemoryLength C1G2ProtoConEPCMemLength
	HasUserMemory   bool
	// HasXPC is true if the Extended Protocol Control Word 1 exists (word 21 of EPC Memory).
	HasXPC bool
	// IsISO15961 is true if the final 8 bits of the PC are an ISO Application Family
	// Identifier (AFI), as defined in ISO15961. If so, the remainder of the EPC bank
	// contains a Unique Item Identifier (UII) appropriate for that AFI. If false, the final
	// 8 bits of the PC are (or may be) Attribute Bits (applies to Gen2 v1.x tags only), and
	// the remainder of the EPC memory bank is a binary encoded EPC.
	IsISO15961 bool
	// AttributesOrAFI is either the EPC C1G2 Attributes bits, or an ISO15961 AFI, depending
	// on the whether IsISO15961 is true.
	AttributesOrAFI byte
}

// UnmarshalBinary Parameter 12, C1G2PC.
func (p *C1G2PC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2PC, 2, len(data), true); err != nil {
		return err
	}
	p.EPCMemoryLength = data[0] >> 3
	p.HasUserMemory = data[0]>>2&1 != 0
	p.HasXPC = data[0]>>1&1 != 0
	p.IsISO15961 = data[0]&1 != 0
	p.AttributesOrAFI = byte(data[1])
	return nil
}

// EPC96 is Parameter 13, EPC96.
type EPC96 struct {
	EPC []byte
}

// UnmarshalBinary Parameter 13, EPC96.
func (p *EPC96) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPC96, 12, len(data), true); err != nil {
		return err
	}
	p.EPC = make([]byte, 12)
	copy(p.EPC, data)
	return nil
}

// SpecIndex is Parameter 14, SpecIndex.
type SpecIndex uint16

// UnmarshalBinary Parameter 14, SpecIndex.
func (p *SpecIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = SpecIndex(binary.BigEndian.Uint16(data))
	return nil
}

// ClientRequestOpSpecResult is Parameter 15, ClientRequestOpSpecResult.
type ClientRequestOpSpecResult uint16

// UnmarshalBinary Parameter 15, ClientRequestOpSpecResult.
func (p *ClientRequestOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpecResult, 2, len(data), true); err != nil {
		return err
	}
	*p = ClientRequestOpSpecResult(binary.BigEndian.Uint16(data))
	return nil
}

// AccessSpecID is Parameter 16, AccessSpecID.
type AccessSpecID uint32

// UnmarshalBinary Parameter 16, AccessSpecID.
func (p *AccessSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = AccessSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// OpSpecID is Parameter 17, OpSpecID.
type OpSpecID uint16

// UnmarshalBinary Parameter 17, OpSpecID.
func (p *OpSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamOpSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = OpSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// C1G2SingulationDetails is Parameter 18, C1G2SingulationDetails.
type C1G2SingulationDetails struct {
	NumCollisionSlots uint16
	NumEmptySlots     uint16
}

// UnmarshalBinary Parameter 18, C1G2SingulationDetails.
func (p *C1G2SingulationDetails) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationDetails, 4, len(data), true); err != nil {
		return err
	}
	p.NumCollisionSlots = binary.BigEndian.Uint16(data)
	p.NumEmptySlots = binary.BigEndian.Uint16(data[2:])
	return nil
}

// C1G2XPCW1 is Parameter 19, C1G2XPCW1.
type C1G2XPCW1 uint16

// UnmarshalBinary Parameter 19, C1G2XPCW1.
func (p *C1G2XPCW1) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW1, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2XPCW1(binary.BigEndian.Uint16(data))
	return nil
}

// C1G2XPCW2 is Parameter 20, C1G2XPCW2.
type C1G2XPCW2 uint16

// UnmarshalBinary Parameter 20, C1G2XPCW2.
func (p *C1G2XPCW2) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW2, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2XPCW2(binary.BigEndian.Uint16(data))
	return nil
}

// UTCTimestamp is Parameter 128, UTCTimestamp.
//
// Microseconds since the beginning of time, midnight 1970-Jan-1.
type UTCTimestamp MicroSecs64

// UnmarshalBinary Parameter 128, UTCTimestamp.
func (p *UTCTimestamp) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUTCTimestamp, 8, len(data), true); err != nil {
		return err
	}
	*p = UTCTimestamp(binary.BigEndian.Uint64(data))
	return nil
}

// Uptime is Parameter 129, Uptime.
//
// Microseconds since the Reader started.
type Uptime MicroSecs64

// UnmarshalBinary Parameter 129, Uptime.
func (p *Uptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = Uptime(binary.BigEndian.Uint64(data))
	return nil
}

// GeneralDeviceCapabilities is Parameter 137, GeneralDeviceCapabilities.
//
// This parameter specifies what the Reader supports, primarily with respect to antenna
// control. It also gives some identifying information about the device make, model, and
// firmware.
//
// Some LLRP messages permit either a UTC timestamp or Uptime parameter. If HasUTCClock is
// false, the Reader uses Uptime, and reports the number of microseconds since it powered
// on. If it has a UTC clock, then it reports its timestamps as microseconds since the
// beginning of time (1970-Jan-01, midnight).
//
// The most common messages carry a timestamp, so they'll have one or the other of UTC or
// Uptime, but not both. In most cases, this package use pointer struct fields for 0..1
// parameters, allowing nil to signal that the parameter isn't present. For reasons
// related to implementation simplicity and performance, both UTC and Uptime are presented
// as non-pointer struct fields. During unmarshaling, it'll set the correct value and
// leave the other 0 (or report an error if both are present or both are missing). During
// marshaling, if both are set, it will only marshal the UTC value.
//
// If a Reader doesn't support controlling receive sensitivity, it returns a single table
// entry with the value 0. If it supports multiple antennas each with unique
// sensitivities, the table contains an entry for the union of all possible sensitivities,
// and the PerAntennaReceiveSensitivityRanges maps antenna IDs to ranges of indices into
// this table.
type GeneralDeviceCapabilities struct {
	MaxSupportedAntennas    uint16
	CanSetAntennaProperties bool
	HasUTCClock             bool
	// DeviceManufacturer is an IANA Private Enterprise Number (PEN).
	DeviceManufacturer                 uint32
	Model                              uint32
	FirmwareVersion                    string
	ReceiveSensitivities               []ReceiveSensitivityTableEntry
	PerAntennaReceiveSensitivityRanges []PerAntennaReceiveSensitivityRange
	GPIOCapabilities                   GPIOCapabilities
	PerAntennaAirProtocols             []PerAntennaAirProtocol
	MaximumReceiveSensitivity          *MaximumReceiveSensitivity
}

// UnmarshalBinary Parameter 137, GeneralDeviceCapabilities.
func (p *GeneralDeviceCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGeneralDeviceCapabilities, 30, len(data), false); err != nil {
		return err
	}
	p.MaxSupportedAntennas = binary.BigEndian.Uint16(data)
	p.CanSetAntennaProperties = data[2]>>7 != 0
	p.HasUTCClock = data[2]>>6&1 != 0
	p.DeviceManufacturer = binary.BigEndian.Uint32(data[4:])
	p.Model = binary.BigEndian.Uint32(data[8:])
	if strLen := int(binary.BigEndian.Uint16(data[12:])); strLen > len(data[14:]) {
		return errors.Errorf("FirmwareVersion (string) declares it has %d "+
			"bytes, but only %d bytes are available", strLen, len(data[14:]))
	} else if strLen != 0 {
		p.FirmwareVersion = string(data[14 : strLen+14])
		data = data[strLen+14:]
	} else {
		data = data[14:]
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReceiveSensitivityTableEntry:
			var tmp ReceiveSensitivityTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.ReceiveSensitivities = append(p.ReceiveSensitivities, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaReceiveSensitivityRange:
			var tmp PerAntennaReceiveSensitivityRange
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaReceiveSensitivityRanges = append(p.PerAntennaReceiveSensitivityRanges, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamGPIOCapabilities, 8, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamGPIOCapabilities {
		return errors.Errorf("expected ParamGPIOCapabilities, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPIOCapabilities says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.GPIOCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup3:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaAirProtocol:
			var tmp PerAntennaAirProtocol
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaAirProtocols = append(p.PerAntennaAirProtocols, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamMaximumReceiveSensitivity {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamMaximumReceiveSensitivity says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.MaximumReceiveSensitivity = new(MaximumReceiveSensitivity)
		*p.MaximumReceiveSensitivity = MaximumReceiveSensitivity(DeciBelMilliWatt16(binary.BigEndian.Uint16(data[4:])))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading GeneralDeviceCapabilities, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// ReceiveSensitivityTableEntry is Parameter 139, ReceiveSensitivityTableEntry.
type ReceiveSensitivityTableEntry struct {
	Index uint16
	// ReceiveSensitivity is relative the maximum supported by the device, or the maximum
	// reported in the device capabilities, for readers that support changing it (requires
	// LLRP v1.1+).
	ReceiveSensitivity DeciBel
}

// UnmarshalBinary Parameter 139, ReceiveSensitivityTableEntry.
func (p *ReceiveSensitivityTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReceiveSensitivityTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.Index = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivity = binary.BigEndian.Uint16(data[2:])
	return nil
}

// PerAntennaAirProtocol is Parameter 140, PerAntennaAirProtocol.
type PerAntennaAirProtocol struct {
	AntennaID      uint16
	AirProtocolIDs []AirProtocolIDType
}

// UnmarshalBinary Parameter 140, PerAntennaAirProtocol.
func (p *PerAntennaAirProtocol) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaAirProtocol, 4, len(data), false); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); arrLen > len(data[4:]) {
		return errors.Errorf("AirProtocolIDs ([]AirProtocolIDType) declares "+
			"it has %d bytes, but only %d bytes are available", arrLen,
			len(data[4:]))
	} else if arrLen != 0 {
		p.AirProtocolIDs = make([]AirProtocolIDType, arrLen)
		for i := 0; i < arrLen; i++ {
			p.AirProtocolIDs[i] = AirProtocolIDType(data[i+4])
		}
		data = data[arrLen+4:]
	} else {
		data = data[4:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading PerAntennaAirProtocol, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// GPIOCapabilities is Parameter 141, GPIOCapabilities.
type GPIOCapabilities struct {
	NumGPIs uint16
	NumGPOs uint16
}

// UnmarshalBinary Parameter 141, GPIOCapabilities.
func (p *GPIOCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIOCapabilities, 4, len(data), true); err != nil {
		return err
	}
	p.NumGPIs = binary.BigEndian.Uint16(data)
	p.NumGPOs = binary.BigEndian.Uint16(data[2:])
	return nil
}

// LLRPCapabilities is Parameter 142, LLRPCapabilities.
type LLRPCapabilities struct {
	CanDoRFSurvey                          bool
	CanReportBufferFillWarning             bool
	SupportsClientRequestOpSpec            bool
	CanDoTagInventoryStateAwareSingulation bool
	SupportsEventsAndReportHolding         bool
	MaxPriorityLevelSupported              uint8
	ClientRequestedOpSpecTimeout           uint16
	MaxROSpecs                             uint32
	MaxSpecsPerROSpec                      uint32
	MaxInventoryParameterSpecsPerAISpec    uint32
	MaxAccessSpecs                         uint32
	MaxOpSpecsPerAccessSpec                uint32
}

// UnmarshalBinary Parameter 142, LLRPCapabilities.
func (p *LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPCapabilities, 24, len(data), true); err != nil {
		return err
	}
	p.CanDoRFSurvey = data[0]>>7 != 0
	p.CanReportBufferFillWarning = data[0]>>6&1 != 0
	p.SupportsClientRequestOpSpec = data[0]>>5&1 != 0
	p.CanDoTagInventoryStateAwareSingulation = data[0]>>4&1 != 0
	p.SupportsEventsAndReportHolding = data[0]>>3&1 != 0
	p.MaxPriorityLevelSupported = data[1]
	p.ClientRequestedOpSpecTimeout = binary.BigEndian.Uint16(data[2:])
	p.MaxROSpecs = binary.BigEndian.Uint32(data[4:])
	p.MaxSpecsPerROSpec = binary.BigEndian.Uint32(data[8:])
	p.MaxInventoryParameterSpecsPerAISpec = binary.BigEndian.Uint32(data[12:])
	p.MaxAccessSpecs = binary.BigEndian.Uint32(data[16:])
	p.MaxOpSpecsPerAccessSpec = binary.BigEndian.Uint32(data[20:])
	return nil
}

// RegulatoryCapabilities is Parameter 143, RegulatoryCapabilities.
type RegulatoryCapabilities struct {
	CountryCode            CountryCodeType
	CommunicationsStandard uint16
	UHFBandCapabilities    *UHFBandCapabilities
	Custom                 []Custom
}

// UnmarshalBinary Parameter 143, RegulatoryCapabilities.
func (p *RegulatoryCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRegulatoryCapabilities, 4, len(data), false); err != nil {
		return err
	}
	p.CountryCode = CountryCodeType(binary.BigEndian.Uint16(data))
	p.CommunicationsStandard = binary.BigEndian.Uint16(data[2:])
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUHFBandCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUHFBandCapabilities says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.UHFBandCapabilities = new(UHFBandCapabilities)
		if err := p.UHFBandCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RegulatoryCapabilities, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UHFBandCapabilities is Parameter 144, UHFBandCapabilities.
type UHFBandCapabilities struct {
	TransmitPowerLevels           []TransmitPowerLevelTableEntry
	FrequencyInformation          FrequencyInformation
	C1G2RFModes                   UHFC1G2RFModeTable
	RFSurveyFrequencyCapabilities *RFSurveyFrequencyCapabilities
}

// UnmarshalBinary Parameter 144, UHFBandCapabilities.
func (p *UHFBandCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFBandCapabilities, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTransmitPowerLevelTableEntry:
			var tmp TransmitPowerLevelTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.TransmitPowerLevels = append(p.TransmitPowerLevels, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamFrequencyInformation, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamFrequencyInformation {
		return errors.Errorf("expected ParamFrequencyInformation, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFrequencyInformation says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.FrequencyInformation.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTable, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamUHFC1G2RFModeTable {
		return errors.Errorf("expected ParamUHFC1G2RFModeTable, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUHFC1G2RFModeTable says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.C1G2RFModes.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFSurveyFrequencyCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveyFrequencyCapabilities says it "+
				"has %d bytes, but only %d bytes remain", subLen, len(data))
		}
		p.RFSurveyFrequencyCapabilities = new(RFSurveyFrequencyCapabilities)
		if err := p.RFSurveyFrequencyCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading UHFBandCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// TransmitPowerLevelTableEntry is Parameter 145, TransmitPowerLevelTableEntry.
type TransmitPowerLevelTableEntry struct {
	Index              uint16
	TransmitPowerValue MilliBelMilliWatt
}

// UnmarshalBinary Parameter 145, TransmitPowerLevelTableEntry.
func (p *TransmitPowerLevelTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTransmitPowerLevelTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.Index = binary.BigEndian.Uint16(data)
	p.TransmitPowerValue = binary.BigEndian.Uint16(data[2:])
	return nil
}

// FrequencyInformation is Parameter 146, FrequencyInformation.
//
// In hopping regulatory regions, Hopping is true, and the Reader will send zero or more
// FrequencyHopTables, each with a HopTableID and list of frequencies. In fixed frequency
// regulatory regions, Hopping is false, and the Reader sends a fixed frequency table
// instead.
//
// In both cases, the "table" is just a list of available frequencies. The "ChannelIndex"
// is a frequency's 1-based offset in its list, so ChannelIndex 1 is Frequencies[0]. Other
// parameters will reference these values using a ChannelIndex, as well as the HopTableID
// if Hopping is true.
type FrequencyInformation struct {
	Hopping             bool
	FrequencyHopTables  []FrequencyHopTable
	FixedFrequencyTable *FixedFrequencyTable
}

// UnmarshalBinary Parameter 146, FrequencyInformation.
func (p *FrequencyInformation) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyInformation, 1, len(data), false); err != nil {
		return err
	}
	p.Hopping = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyHopTable:
			var tmp FrequencyHopTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyHopTables = append(p.FrequencyHopTables, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFixedFrequencyTable {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFixedFrequencyTable says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.FixedFrequencyTable = new(FixedFrequencyTable)
		if err := p.FixedFrequencyTable.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyInformation, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// FrequencyHopTable is Parameter 147, FrequencyHopTable.
type FrequencyHopTable struct {
	HopTableID  uint8
	Frequencies []KiloHertz
}

// UnmarshalBinary Parameter 147, FrequencyHopTable.
func (p *FrequencyHopTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyHopTable, 4, len(data), false); err != nil {
		return err
	}
	p.HopTableID = data[0]
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen)*4 > int64(len(data[4:])) {
		return errors.Errorf("Frequencies ([]KiloHertz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]KiloHertz, arrLen)
		for i, pos := 0, 4; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+4:]
	} else {
		data = data[4:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyHopTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// FixedFrequencyTable is Parameter 148, FixedFrequencyTable.
type FixedFrequencyTable struct {
	Frequencies []KiloHertz
}

// UnmarshalBinary Parameter 148, FixedFrequencyTable.
func (p *FixedFrequencyTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFixedFrequencyTable, 2, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*4 > int64(len(data[2:])) {
		return errors.Errorf("Frequencies ([]KiloHertz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]KiloHertz, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FixedFrequencyTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// PerAntennaReceiveSensitivityRange is Parameter 149, PerAntennaReceiveSensitivityRange.
type PerAntennaReceiveSensitivityRange struct {
	AntennaID                  uint16
	ReceiveSensitivityIndexMin uint16
	ReceiveSensitivityIndexMax uint16
}

// UnmarshalBinary Parameter 149, PerAntennaReceiveSensitivityRange.
func (p *PerAntennaReceiveSensitivityRange) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaReceiveSensitivityRange, 6, len(data), true); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivityIndexMin = binary.BigEndian.Uint16(data[2:])
	p.ReceiveSensitivityIndexMax = binary.BigEndian.Uint16(data[4:])
	return nil
}

// ROSpec is Parameter 177, ROSpec.
//
// ROSpec is a Reader Operation Specification.
//
// An ROSpec describes the operations executed at one or more antennas, specified one or
// more AISpecs, RFSurveySpecs, or CustomSpecs. Specs are executed in the order in which
// they appear, and reports reference the relevant spec via a 1-indexed SpecIndex. Not all
// devices support RFSurveySpecs. LoopSpecs are only supported with LLRP version 1.1.
//
// The RFID device picks which ROSpec to execute based on a number of conditions
// (described below). When it does so, the ROSpec transitions from Inactive to Active, and
// the device may send an event notification (if configured to do so). While Active, if
// the ROSpec's reporting conditions are satisfied, the device sends ROAccessReports,
// which contain TagReportData matching either the device's configured defaults report
// information, or the TagReportContentSelector if the RO defines an ROReportSpec.
//
// The client defines an ROSpec via the AddROSpec Message. They must define the spec in
// the Disabled state, with an ROSpecID >0, or the device must reject it. Once defined,
// the client uses the ROSpecID to modify its state, and the device may include the
// ROSpecID in reports that reference it. Other relevant messages for controlling ROSpecs:
//
//     - Enable ROSpec
//
//     - Disable ROSpec
//
//     - Start ROSpec
//
//     - Stop ROSpec
//
//     - Delete ROSpec
//
//     - Get ROSpecs
type ROSpec struct {
	ROSpecID           uint32
	Priority           uint8
	ROSpecCurrentState ROSpecCurrentStateType
	ROBoundarySpec     ROBoundarySpec
	AISpecs            []AISpec
	RFSurveySpecs      []RFSurveySpec
	Custom             []Custom
	LoopSpec           *LoopSpec
	ROReportSpec       *ROReportSpec
}

// UnmarshalBinary Parameter 177, ROSpec.
func (p *ROSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpec, 15, len(data), false); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.Priority = data[4]
	p.ROSpecCurrentState = ROSpecCurrentStateType(data[5])
	data = data[6:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROBoundarySpec {
		return errors.Errorf("expected ParamROBoundarySpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROBoundarySpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.ROBoundarySpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAISpec:
			var tmp AISpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AISpecs = append(p.AISpecs, tmp)
		case ParamRFSurveySpec:
			var tmp RFSurveySpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.RFSurveySpecs = append(p.RFSurveySpecs, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamLoopSpec:
			p.LoopSpec = new(LoopSpec)
			*p.LoopSpec = LoopSpec(binary.BigEndian.Uint32(data[4:]))
		case ParamROReportSpec:
			p.ROReportSpec = new(ROReportSpec)
			if err := p.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// ROBoundarySpec is Parameter 178, ROBoundarySpec.
type ROBoundarySpec struct {
	StartTrigger ROSpecStartTrigger
	StopTrigger  ROSpecStopTrigger
}

// UnmarshalBinary Parameter 178, ROBoundarySpec.
func (p *ROBoundarySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROBoundarySpec, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStartTrigger {
		return errors.Errorf("expected ParamROSpecStartTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStartTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.StartTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStopTrigger {
		return errors.Errorf("expected ParamROSpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStopTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.StopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROBoundarySpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// ROSpecStartTrigger is Parameter 179, ROSpecStartTrigger.
type ROSpecStartTrigger struct {
	Trigger         ROSpecStartTriggerType
	PeriodicTrigger *PeriodicTriggerValue
	GPITrigger      *GPITriggerValue
}

// UnmarshalBinary Parameter 179, ROSpecStartTrigger.
func (p *ROSpecStartTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStartTrigger, 1, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROSpecStartTriggerType(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPeriodicTriggerValue:
			p.PeriodicTrigger = new(PeriodicTriggerValue)
			if err := p.PeriodicTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamGPITriggerValue:
			p.GPITrigger = new(GPITriggerValue)
			if err := p.GPITrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpecStartTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// PeriodicTriggerValue is Parameter 180, PeriodicTriggerValue.
type PeriodicTriggerValue struct {
	Offset       MilliSecs32
	Period       MilliSecs32
	UTCTimestamp *UTCTimestamp
}

// UnmarshalBinary Parameter 180, PeriodicTriggerValue.
func (p *PeriodicTriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeriodicTriggerValue, 8, len(data), false); err != nil {
		return err
	}
	p.Offset = binary.BigEndian.Uint32(data)
	p.Period = binary.BigEndian.Uint32(data[4:])
	data = data[8:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUTCTimestamp {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.UTCTimestamp = new(UTCTimestamp)
		*p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading PeriodicTriggerValue, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// GPITriggerValue is Parameter 181, GPITriggerValue.
type GPITriggerValue struct {
	Port    uint16
	Event   bool
	Timeout MilliSecs32
}

// UnmarshalBinary Parameter 181, GPITriggerValue.
func (p *GPITriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPITriggerValue, 7, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Event = data[2]>>7 != 0
	p.Timeout = binary.BigEndian.Uint32(data[3:])
	return nil
}

// ROSpecStopTrigger is Parameter 182, ROSpecStopTrigger.
type ROSpecStopTrigger struct {
	Trigger              ROSpecStopTriggerType
	DurationTriggerValue MilliSecs32
	GPITriggerValue      *GPITriggerValue
}

// UnmarshalBinary Parameter 182, ROSpecStopTrigger.
func (p *ROSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROSpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPITriggerValue says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.GPITriggerValue = new(GPITriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROSpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// AISpec is Parameter 183, AISpec.
//
// AISpec defines antenna inventory operations, which LLRP defines as "the smallest unit
// of interaction between a Reader and tags in the antenna's field-of-view."
//
// An AISpec gives a list of InventoryParameterSpecs, which define how the RFID device
// should singulate tags. It combines this with an stop trigger and list of antennas. Each
// inventory spec is executed for each antenna, and the stop condition applies to the
// aggregate of these AI operations. The device chooses the order in which the operations
// are executed, regardless of the order presented.
type AISpec struct {
	// AntennaIDs tells the device which antennas to use. If any of them are zero, then
	// they're all used, regardless of any other value in the array.
	AntennaIDs              []AntennaID
	StopTrigger             AISpecStopTrigger
	InventoryParameterSpecs []InventoryParameterSpec
	Custom                  []Custom
}

// UnmarshalBinary Parameter 183, AISpec.
func (p *AISpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpec, 9, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*2 > int64(len(data[2:])) {
		return errors.Errorf("AntennaIDs ([]AntennaID) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.AntennaIDs = make([]AntennaID, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+2 {
			p.AntennaIDs[i] = AntennaID(binary.BigEndian.Uint16(data[pos:]))
		}
		data = data[arrLen*2+2:]
	} else {
		data = data[2:]
	}
	// sub-parameters
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAISpecStopTrigger {
		return errors.Errorf("expected ParamAISpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAISpecStopTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.StopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamInventoryParameterSpec:
			var tmp InventoryParameterSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.InventoryParameterSpecs = append(p.InventoryParameterSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// AISpecStopTrigger is Parameter 184, AISpecStopTrigger.
type AISpecStopTrigger struct {
	Trigger               AISpecStopTriggerType
	DurationTriggerValue  MilliSecs32
	GPITrigger            *GPITriggerValue
	TagObservationTrigger *TagObservationTrigger
}

// UnmarshalBinary Parameter 184, AISpecStopTrigger.
func (p *AISpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.Trigger = AISpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPITriggerValue:
			p.GPITrigger = new(GPITriggerValue)
			if err := p.GPITrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamTagObservationTrigger:
			p.TagObservationTrigger = new(TagObservationTrigger)
			if err := p.TagObservationTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// TagObservationTrigger is Parameter 185, TagObservationTrigger.
type TagObservationTrigger struct {
	Trigger          TagObservationTriggerType
	NumberofTags     uint16
	NumberofAttempts uint16
	T                MilliSecs16
	Timeout          MilliSecs32
}

// UnmarshalBinary Parameter 185, TagObservationTrigger.
func (p *TagObservationTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagObservationTrigger, 12, len(data), true); err != nil {
		return err
	}
	p.Trigger = TagObservationTriggerType(data[0])
	p.NumberofTags = binary.BigEndian.Uint16(data[2:])
	p.NumberofAttempts = binary.BigEndian.Uint16(data[4:])
	p.T = binary.BigEndian.Uint16(data[6:])
	p.Timeout = binary.BigEndian.Uint32(data[8:])
	return nil
}

// InventoryParameterSpec is Parameter 186, InventoryParameterSpec.
type InventoryParameterSpec struct {
	InventoryParameterSpecID uint16
	AirProtocolID            AirProtocolIDType
	AntennaConfigurations    []AntennaConfiguration
	Custom                   []Custom
}

// UnmarshalBinary Parameter 186, InventoryParameterSpec.
func (p *InventoryParameterSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpec, 3, len(data), false); err != nil {
		return err
	}
	p.InventoryParameterSpecID = binary.BigEndian.Uint16(data)
	p.AirProtocolID = AirProtocolIDType(data[2])
	data = data[3:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AntennaConfigurations = append(p.AntennaConfigurations, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading InventoryParameterSpec, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// RFSurveySpec is Parameter 187, RFSurveySpec.
type RFSurveySpec struct {
	AntennaID      uint16
	StartFrequency KiloHertz
	EndFrequency   KiloHertz
	Trigger        RFSurveySpecStopTrigger
	Custom         []Custom
}

// UnmarshalBinary Parameter 187, RFSurveySpec.
func (p *RFSurveySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpec, 23, len(data), false); err != nil {
		return err
	}
	p.AntennaID = binary.BigEndian.Uint16(data)
	p.StartFrequency = binary.BigEndian.Uint32(data[2:])
	p.EndFrequency = binary.BigEndian.Uint32(data[6:])
	data = data[10:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamRFSurveySpecStopTrigger {
		return errors.Errorf("expected ParamRFSurveySpecStopTrigger, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveySpecStopTrigger says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.Trigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RFSurveySpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// RFSurveySpecStopTrigger is Parameter 188, RFSurveySpecStopTrigger.
type RFSurveySpecStopTrigger struct {
	Trigger  RFSurveySpecStopTriggerType
	Duration MilliSecs32
	N        MilliSecs32
}

// UnmarshalBinary Parameter 188, RFSurveySpecStopTrigger.
func (p *RFSurveySpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpecStopTrigger, 9, len(data), true); err != nil {
		return err
	}
	p.Trigger = RFSurveySpecStopTriggerType(data[0])
	p.Duration = binary.BigEndian.Uint32(data[1:])
	p.N = binary.BigEndian.Uint32(data[5:])
	return nil
}

// AccessSpec is Parameter 207, AccessSpec.
type AccessSpec struct {
	AccessSpecID     uint32
	AntennaID        uint16
	AirProtocolID    AirProtocolIDType
	IsActive         bool
	ROSpecID         uint32
	Trigger          AccessSpecStopTrigger
	AccessCommand    AccessCommand
	AccessReportSpec *AccessReportSpec
	Custom           []Custom
}

// UnmarshalBinary Parameter 207, AccessSpec.
func (p *AccessSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpec, 19, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	p.AntennaID = binary.BigEndian.Uint16(data[4:])
	p.AirProtocolID = AirProtocolIDType(data[6])
	p.IsActive = data[7]>>7 != 0
	p.ROSpecID = binary.BigEndian.Uint32(data[8:])
	data = data[12:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpecStopTrigger {
		return errors.Errorf("expected ParamAccessSpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpecStopTrigger says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.Trigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamAccessCommand, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessCommand {
		return errors.Errorf("expected ParamAccessCommand, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessCommand says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.AccessCommand.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessReportSpec says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.AccessReportSpec = new(AccessReportSpec)
		*p.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AccessSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// AccessSpecStopTrigger is Parameter 208, AccessSpecStopTrigger.
type AccessSpecStopTrigger struct {
	Trigger             AccessSpecStopTriggerType
	OperationCountValue uint16
}

// UnmarshalBinary Parameter 208, AccessSpecStopTrigger.
func (p *AccessSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecStopTrigger, 3, len(data), true); err != nil {
		return err
	}
	p.Trigger = AccessSpecStopTriggerType(data[0])
	p.OperationCountValue = binary.BigEndian.Uint16(data[1:])
	return nil
}

// AccessCommand is Parameter 209, AccessCommand.
type AccessCommand struct {
	C1G2TagSpec                 C1G2TagSpec
	C1G2Read                    *C1G2Read
	C1G2Write                   *C1G2Write
	C1G2Kill                    *C1G2Kill
	C1G2Recommission            *C1G2Recommission
	C1G2Lock                    *C1G2Lock
	C1G2BlockErase              *C1G2BlockErase
	C1G2BlockWrite              *C1G2BlockWrite
	C1G2BlockPermalock          *C1G2BlockPermalock
	C1G2GetBlockPermalockStatus *C1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *ClientRequestOpSpec
	Custom                      []Custom
}

// UnmarshalBinary Parameter 209, AccessCommand.
func (p *AccessCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessCommand, 15, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagSpec {
		return errors.Errorf("expected ParamC1G2TagSpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagSpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.C1G2TagSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(C1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(C1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(C1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(C1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(C1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(C1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(C1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(C1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(C1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			p.ClientRequestOpSpec = new(ClientRequestOpSpec)
			*p.ClientRequestOpSpec = ClientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AccessCommand, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// ClientRequestOpSpec is Parameter 210, ClientRequestOpSpec.
type ClientRequestOpSpec uint16

// UnmarshalBinary Parameter 210, ClientRequestOpSpec.
func (p *ClientRequestOpSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpec, 2, len(data), true); err != nil {
		return err
	}
	*p = ClientRequestOpSpec(binary.BigEndian.Uint16(data))
	return nil
}

// ClientRequestResponse is Parameter 211, ClientRequestResponse.
type ClientRequestResponse struct {
	AccessSpecID                uint32
	EPCData                     EPCData
	C1G2Read                    *C1G2Read
	C1G2Write                   *C1G2Write
	C1G2Kill                    *C1G2Kill
	C1G2Recommission            *C1G2Recommission
	C1G2Lock                    *C1G2Lock
	C1G2BlockErase              *C1G2BlockErase
	C1G2BlockWrite              *C1G2BlockWrite
	C1G2BlockPermalock          *C1G2BlockPermalock
	C1G2GetBlockPermalockStatus *C1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *ClientRequestOpSpec
	Custom                      *Custom
}

// UnmarshalBinary Parameter 211, ClientRequestResponse.
func (p *ClientRequestResponse) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestResponse, 10, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	data = data[4:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEPCData {
		return errors.Errorf("expected ParamEPCData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEPCData says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(C1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(C1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(C1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(C1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(C1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(C1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(C1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(C1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(C1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			p.ClientRequestOpSpec = new(ClientRequestOpSpec)
			*p.ClientRequestOpSpec = ClientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		case ParamCustom:
			p.Custom = new(Custom)
			if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ClientRequestResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// LLRPConfigurationStateValue is Parameter 217, LLRPConfigurationStateValue.
type LLRPConfigurationStateValue uint32

// UnmarshalBinary Parameter 217, LLRPConfigurationStateValue.
func (p *LLRPConfigurationStateValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPConfigurationStateValue, 4, len(data), true); err != nil {
		return err
	}
	*p = LLRPConfigurationStateValue(binary.BigEndian.Uint32(data))
	return nil
}

// Identification is Parameter 218, Identification.
type Identification struct {
	IDType IDType
	// ReaderID is "unique within the local administration domain", and may be the reader's
	// MAC in EUI-64 format or an EPC.
	ReaderID []byte
}

// UnmarshalBinary Parameter 218, Identification.
func (p *Identification) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamIdentification, 3, len(data), false); err != nil {
		return err
	}
	p.IDType = IDType(data[0])
	if arrLen := int(binary.BigEndian.Uint16(data[1:])); arrLen > len(data[3:]) {
		return errors.Errorf("ReaderID ([]byte) declares it has %d bytes, "+
			"but only %d bytes are available", arrLen, len(data[3:]))
	} else if arrLen != 0 {
		p.ReaderID = make([]byte, arrLen)
		copy(p.ReaderID, data[3:])
		data = data[arrLen+3:]
	} else {
		data = data[3:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading Identification, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// GPOWriteData is Parameter 219, GPOWriteData.
type GPOWriteData struct {
	Port uint16
	Data bool
}

// UnmarshalBinary Parameter 219, GPOWriteData.
func (p *GPOWriteData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPOWriteData, 3, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Data = data[2]>>7 != 0
	return nil
}

// KeepAliveSpec is Parameter 220, KeepAliveSpec.
type KeepAliveSpec struct {
	Trigger  KeepAliveTriggerType
	Interval MilliSecs32
}

// UnmarshalBinary Parameter 220, KeepAliveSpec.
func (p *KeepAliveSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamKeepAliveSpec, 5, len(data), true); err != nil {
		return err
	}
	p.Trigger = KeepAliveTriggerType(data[0])
	p.Interval = binary.BigEndian.Uint32(data[1:])
	return nil
}

// AntennaProperties is Parameter 221, AntennaProperties.
type AntennaProperties struct {
	AntennaConnected bool
	AntennaID        AntennaID
	// AntennaGain is the composite forward gain of the antenna, including cable loss,
	// relative a hypothetical isotropic antenna, expressed in 1/100ths of DeciBeli.
	AntennaGain MilliBelIsotropic
}

// UnmarshalBinary Parameter 221, AntennaProperties.
func (p *AntennaProperties) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaProperties, 5, len(data), true); err != nil {
		return err
	}
	p.AntennaConnected = data[0]>>7 != 0
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
	p.AntennaGain = binary.BigEndian.Uint16(data[3:])
	return nil
}

// AntennaConfiguration is Parameter 222, AntennaConfiguration.
type AntennaConfiguration struct {
	AntennaID            AntennaID
	RFReceiver           *RFReceiver
	RFTransmitter        *RFTransmitter
	C1G2InventoryCommand *C1G2InventoryCommand
	Custom               []Custom
}

// UnmarshalBinary Parameter 222, AntennaConfiguration.
func (p *AntennaConfiguration) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaConfiguration, 2, len(data), false); err != nil {
		return err
	}
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamRFReceiver:
			p.RFReceiver = new(RFReceiver)
			*p.RFReceiver = RFReceiver(binary.BigEndian.Uint16(data[4:]))
		case ParamRFTransmitter:
			p.RFTransmitter = new(RFTransmitter)
			if err := p.RFTransmitter.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2InventoryCommand:
			p.C1G2InventoryCommand = new(C1G2InventoryCommand)
			if err := p.C1G2InventoryCommand.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AntennaConfiguration, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// RFReceiver is Parameter 223, RFReceiver.
type RFReceiver uint16

// UnmarshalBinary Parameter 223, RFReceiver.
func (p *RFReceiver) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFReceiver, 2, len(data), true); err != nil {
		return err
	}
	*p = RFReceiver(binary.BigEndian.Uint16(data))
	return nil
}

// RFTransmitter is Parameter 224, RFTransmitter.
type RFTransmitter struct {
	// HopTableID for jurisdictions that require frequency hopping. Hop tables are presented
	// in the Reader's capabilities, under RegulatorCapabilities -> UHFBandCapabilities ->
	// C1G2RFModes.
	HopTableID uint16
	// ChannelIndex within the Fixed Frequency Table, for jurisdictions that do not permit
	// frequency hopping. The fixed frequency information is presented in the Reader's
	// capabilities, under RegulatorCapabilities -> UHFBandCapabilities ->
	// FrequencyInformation. Unlike other tables, this table does not have entries with IDs;
	// instead, the ChannelIndex is the 1-based offset within the array.
	ChannelIndex uint16
	// TransmitPowerIndex, as from the for jurisdictions that do not permit frequency
	// hopping. The power levels are presented in the Reader's capabilities, under
	// RegulatorCapabilities -> UHFBandCapabilities -> TransmitPowerLevels.
	TransmitPowerIndex uint16
}

// UnmarshalBinary Parameter 224, RFTransmitter.
func (p *RFTransmitter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFTransmitter, 6, len(data), true); err != nil {
		return err
	}
	p.HopTableID = binary.BigEndian.Uint16(data)
	p.ChannelIndex = binary.BigEndian.Uint16(data[2:])
	p.TransmitPowerIndex = binary.BigEndian.Uint16(data[4:])
	return nil
}

// GPIPortCurrentState is Parameter 225, GPIPortCurrentState.
type GPIPortCurrentState struct {
	Port    uint16
	Enabled bool
	State   GPIStateType
}

// UnmarshalBinary Parameter 225, GPIPortCurrentState.
func (p *GPIPortCurrentState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIPortCurrentState, 4, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Enabled = data[2]>>7 != 0
	p.State = GPIStateType(data[3])
	return nil
}

// EventsAndReports is Parameter 226, EventsAndReports.
type EventsAndReports bool

// UnmarshalBinary Parameter 226, EventsAndReports.
func (p *EventsAndReports) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventsAndReports, 1, len(data), true); err != nil {
		return err
	}
	*p = EventsAndReports(data[0]>>7 != 0)
	return nil
}

// ROReportSpec is Parameter 237, ROReportSpec.
type ROReportSpec struct {
	Trigger                  ROReportTriggerType
	N                        uint16
	TagReportContentSelector TagReportContentSelector
	Custom                   []Custom
}

// UnmarshalBinary Parameter 237, ROReportSpec.
func (p *ROReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROReportSpec, 9, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROReportTriggerType(data[0])
	p.N = binary.BigEndian.Uint16(data[1:])
	data = data[3:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportContentSelector {
		return errors.Errorf("expected ParamTagReportContentSelector, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportContentSelector says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.TagReportContentSelector.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ROReportSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// TagReportContentSelector is Parameter 238, TagReportContentSelector.
type TagReportContentSelector struct {
	EnableROSpecID             bool
	EnableSpecIndex            bool
	EnableInventoryParamSpecID bool
	EnableAntennaID            bool
	EnableChannelIndex         bool
	EnablePeakRSSI             bool
	EnableFirstSeenTimestamp   bool
	EnableLastSeenTimestamp    bool
	EnableTagSeenCount         bool
	EnableAccessSpecID         bool
	C1G2EPCMemorySelectors     []C1G2EPCMemorySelector
	Custom                     []Custom
}

// UnmarshalBinary Parameter 238, TagReportContentSelector.
func (p *TagReportContentSelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportContentSelector, 2, len(data), false); err != nil {
		return err
	}
	p.EnableROSpecID = data[0]>>7 != 0
	p.EnableSpecIndex = data[0]>>6&1 != 0
	p.EnableInventoryParamSpecID = data[0]>>5&1 != 0
	p.EnableAntennaID = data[0]>>4&1 != 0
	p.EnableChannelIndex = data[0]>>3&1 != 0
	p.EnablePeakRSSI = data[0]>>2&1 != 0
	p.EnableFirstSeenTimestamp = data[0]>>1&1 != 0
	p.EnableLastSeenTimestamp = data[0]&1 != 0
	p.EnableTagSeenCount = data[1]>>7 != 0
	p.EnableAccessSpecID = data[1]>>6&1 != 0
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2EPCMemorySelector:
			var tmp C1G2EPCMemorySelector
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2EPCMemorySelectors = append(p.C1G2EPCMemorySelectors, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading TagReportContentSelector, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// AccessReportSpec is Parameter 239, AccessReportSpec.
type AccessReportSpec AccessReportTriggerType

// UnmarshalBinary Parameter 239, AccessReportSpec.
func (p *AccessReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessReportSpec, 1, len(data), true); err != nil {
		return err
	}
	*p = AccessReportSpec(AccessReportTriggerType(data[0]))
	return nil
}

// TagReportData is Parameter 240, TagReportData.
type TagReportData struct {
	EPCData                                 EPCData
	EPC96                                   EPC96
	ROSpecID                                *ROSpecID
	SpecIndex                               *SpecIndex
	InventoryParameterSpecID                *InventoryParameterSpecID
	AntennaID                               *AntennaID
	PeakRSSI                                *PeakRSSI
	ChannelIndex                            *ChannelIndex
	FirstSeenUTC                            *FirstSeenUTC
	FirstSeenUptime                         *FirstSeenUptime
	LastSeenUTC                             *LastSeenUTC
	LastSeenUptime                          *LastSeenUptime
	TagSeenCount                            *TagSeenCount
	C1G2PC                                  *C1G2PC
	C1G2XPCW1                               *C1G2XPCW1
	C1G2XPCW2                               *C1G2XPCW2
	C1G2CRC                                 *C1G2CRC
	AccessSpecID                            *AccessSpecID
	C1G2ReadOpSpecResult                    *C1G2ReadOpSpecResult
	C1G2WriteOpSpecResult                   *C1G2WriteOpSpecResult
	C1G2KillOpSpecResult                    *C1G2KillOpSpecResult
	C1G2LockOpSpecResult                    *C1G2LockOpSpecResult
	C1G2BlockEraseOpSpecResult              *C1G2BlockEraseOpSpecResult
	C1G2BlockWriteOpSpecResult              *C1G2BlockWriteOpSpecResult
	C1G2RecommissionOpSpecResult            *C1G2RecommissionOpSpecResult
	C1G2BlockPermalockOpSpecResult          *C1G2BlockPermalockOpSpecResult
	C1G2GetBlockPermalockStatusOpSpecResult *C1G2GetBlockPermalockStatusOpSpecResult
	ClientRequestOpSpecResult               *ClientRequestOpSpecResult
	Custom                                  []Custom
}

// UnmarshalBinary Parameter 240, TagReportData.
func (p *TagReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportData, 6, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		var pt ParamType
		if data[0]&0x80 != 0 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return errors.Errorf("expecting a TLV header, but %d < 4 byte "+
				"remain", len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamEPCData:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamEPCData says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamEPC96:
			if err := p.EPC96.UnmarshalBinary(data[1:13]); err != nil {
				return err
			}
			data = data[13:]
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamTagReportData", pt)
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 1 {
		var pt ParamType
		if data[0]&0x80 != 0 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return errors.Errorf("expecting a TLV header, but %d < 4 byte "+
				"remain", len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamInventoryParameterSpecID:
			p.InventoryParameterSpecID = new(InventoryParameterSpecID)
			*p.InventoryParameterSpecID = InventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAntennaID:
			p.AntennaID = new(AntennaID)
			*p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamPeakRSSI:
			p.PeakRSSI = new(PeakRSSI)
			*p.PeakRSSI = PeakRSSI(DeciBelMilliWatt8(data[1]))
			data = data[2:]
		case ParamChannelIndex:
			p.ChannelIndex = new(ChannelIndex)
			*p.ChannelIndex = ChannelIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamFirstSeenUTC:
			p.FirstSeenUTC = new(FirstSeenUTC)
			*p.FirstSeenUTC = FirstSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamFirstSeenUptime:
			p.FirstSeenUptime = new(FirstSeenUptime)
			*p.FirstSeenUptime = FirstSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUTC:
			p.LastSeenUTC = new(LastSeenUTC)
			*p.LastSeenUTC = LastSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUptime:
			p.LastSeenUptime = new(LastSeenUptime)
			*p.LastSeenUptime = LastSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamTagSeenCount:
			p.TagSeenCount = new(TagSeenCount)
			*p.TagSeenCount = TagSeenCount(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2PC:
			p.C1G2PC = new(C1G2PC)
			if err := p.C1G2PC.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			data = data[3:]
		case ParamC1G2XPCW1:
			p.C1G2XPCW1 = new(C1G2XPCW1)
			*p.C1G2XPCW1 = C1G2XPCW1(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2XPCW2:
			p.C1G2XPCW2 = new(C1G2XPCW2)
			*p.C1G2XPCW2 = C1G2XPCW2(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2CRC:
			p.C1G2CRC = new(C1G2CRC)
			*p.C1G2CRC = C1G2CRC(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAccessSpecID:
			p.AccessSpecID = new(AccessSpecID)
			*p.AccessSpecID = AccessSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamC1G2ReadOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2ReadOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2ReadOpSpecResult = new(C1G2ReadOpSpecResult)
			if err := p.C1G2ReadOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2WriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2WriteOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2WriteOpSpecResult = new(C1G2WriteOpSpecResult)
			if err := p.C1G2WriteOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2KillOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2KillOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2KillOpSpecResult = new(C1G2KillOpSpecResult)
			if err := p.C1G2KillOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2LockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2LockOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2LockOpSpecResult = new(C1G2LockOpSpecResult)
			if err := p.C1G2LockOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockEraseOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockEraseOpSpecResult says it has "+
					"%d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockEraseOpSpecResult = new(C1G2BlockEraseOpSpecResult)
			if err := p.C1G2BlockEraseOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockWriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockWriteOpSpecResult says it has "+
					"%d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockWriteOpSpecResult = new(C1G2BlockWriteOpSpecResult)
			if err := p.C1G2BlockWriteOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2RecommissionOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2RecommissionOpSpecResult says it "+
					"has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2RecommissionOpSpecResult = new(C1G2RecommissionOpSpecResult)
			if err := p.C1G2RecommissionOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockPermalockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockPermalockOpSpecResult says it "+
					"has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockPermalockOpSpecResult = new(C1G2BlockPermalockOpSpecResult)
			if err := p.C1G2BlockPermalockOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2GetBlockPermalockStatusOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2GetBlockPermalockStatusOpSpecResult says "+
					"it has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2GetBlockPermalockStatusOpSpecResult = new(C1G2GetBlockPermalockStatusOpSpecResult)
			if err := p.C1G2GetBlockPermalockStatusOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamClientRequestOpSpecResult:
			p.ClientRequestOpSpecResult = new(ClientRequestOpSpecResult)
			*p.ClientRequestOpSpecResult = ClientRequestOpSpecResult(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup1
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading TagReportData, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// EPCData is Parameter 241, EPCData.
type EPCData struct {
	EPCNumBits uint16
	EPC        []byte
}

// UnmarshalBinary Parameter 241, EPCData.
func (p *EPCData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPCData, 2, len(data), false); err != nil {
		return err
	}
	p.EPCNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.EPCNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return errors.Errorf("EPC (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.EPCNumBits, nBytes,
			len(data[2:]))
	} else if nBytes != 0 {
		p.EPC = make([]byte, nBytes)
		copy(p.EPC, data[2:])
		data = data[nBytes+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading EPCData, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// RFSurveyReportData is Parameter 242, RFSurveyReportData.
type RFSurveyReportData struct {
	ROSpecID                  *ROSpecID
	SpecIndex                 *SpecIndex
	FrequencyRSSILevelEntries []FrequencyRSSILevelEntry
	Custom                    []Custom
}

// UnmarshalBinary Parameter 242, RFSurveyReportData.
func (p *RFSurveyReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyReportData, 26, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup0
		}
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyRSSILevelEntry:
			var tmp FrequencyRSSILevelEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyRSSILevelEntries = append(p.FrequencyRSSILevelEntries, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading RFSurveyReportData, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// FrequencyRSSILevelEntry is Parameter 243, FrequencyRSSILevelEntry.
type FrequencyRSSILevelEntry struct {
	Frequency    KiloHertz
	Bandwidth    KiloHertz
	AverageRSSI  DeciBelMilliWatt8
	PeakRSSI     DeciBelMilliWatt8
	UTCTimestamp UTCTimestamp
	Uptime       Uptime
}

// UnmarshalBinary Parameter 243, FrequencyRSSILevelEntry.
func (p *FrequencyRSSILevelEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyRSSILevelEntry, 22, len(data), false); err != nil {
		return err
	}
	p.Frequency = binary.BigEndian.Uint32(data)
	p.Bandwidth = binary.BigEndian.Uint32(data[4:])
	p.AverageRSSI = DeciBelMilliWatt8(data[8])
	p.PeakRSSI = DeciBelMilliWatt8(data[9])
	data = data[10:]
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUptime says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			p.Uptime = Uptime(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamFrequencyRSSILevelEntry", pt)
		}
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyRSSILevelEntry, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// ReaderEventNotificationSpec is Parameter 244, ReaderEventNotificationSpec.
type ReaderEventNotificationSpec struct {
	EventNotificationStates []EventNotificationState
}

// UnmarshalBinary Parameter 244, ReaderEventNotificationSpec.
func (p *ReaderEventNotificationSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationSpec, 7, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamEventNotificationState:
			var tmp EventNotificationState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.EventNotificationStates = append(p.EventNotificationStates, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotificationSpec, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// EventNotificationState is Parameter 245, EventNotificationState.
type EventNotificationState struct {
	ReaderEventType     ReaderEventType
	NotificationEnabled bool
}

// UnmarshalBinary Parameter 245, EventNotificationState.
func (p *EventNotificationState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventNotificationState, 3, len(data), true); err != nil {
		return err
	}
	p.ReaderEventType = ReaderEventType(binary.BigEndian.Uint16(data))
	p.NotificationEnabled = data[2]>>7 != 0
	return nil
}

// ReaderEventNotificationData is Parameter 246, ReaderEventNotificationData.
type ReaderEventNotificationData struct {
	UTCTimestamp                   UTCTimestamp
	Uptime                         Uptime
	HoppingEvent                   *HoppingEvent
	GPIEvent                       *GPIEvent
	ROSpecEvent                    *ROSpecEvent
	ReportBufferLevelWarningEvent  *ReportBufferLevelWarningEvent
	ReportBufferOverflowErrorEvent *ReportBufferOverflowErrorEvent
	ReaderExceptionEvent           *ReaderExceptionEvent
	RFSurveyEvent                  *RFSurveyEvent
	AISpecEvent                    *AISpecEvent
	AntennaEvent                   *AntennaEvent
	ConnectionAttemptEvent         *ConnectionAttemptEvent
	ConnectionCloseEvent           *ConnectionCloseEvent
	SpecLoopEvent                  *SpecLoopEvent
	Custom                         []Custom
}

// UnmarshalBinary Parameter 246, ReaderEventNotificationData.
func (p *ReaderEventNotificationData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationData, 12, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUptime says it has %d bytes, but only "+
					"%d bytes remain", subLen, len(data))
			}
			p.Uptime = Uptime(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		default:
			return errors.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamReaderEventNotificationData", pt)
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamHoppingEvent:
			p.HoppingEvent = new(HoppingEvent)
			*p.HoppingEvent = HoppingEvent(binary.BigEndian.Uint16(data[4:]))
		case ParamGPIEvent:
			p.GPIEvent = new(GPIEvent)
			if err := p.GPIEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROSpecEvent:
			p.ROSpecEvent = new(ROSpecEvent)
			if err := p.ROSpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReportBufferLevelWarningEvent:
			p.ReportBufferLevelWarningEvent = new(ReportBufferLevelWarningEvent)
			*p.ReportBufferLevelWarningEvent = ReportBufferLevelWarningEvent(data[4])
		case ParamReportBufferOverflowErrorEvent:
			p.ReportBufferOverflowErrorEvent = new(ReportBufferOverflowErrorEvent)
			if err := p.ReportBufferOverflowErrorEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReaderExceptionEvent:
			p.ReaderExceptionEvent = new(ReaderExceptionEvent)
			if err := p.ReaderExceptionEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRFSurveyEvent:
			p.RFSurveyEvent = new(RFSurveyEvent)
			if err := p.RFSurveyEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAISpecEvent:
			p.AISpecEvent = new(AISpecEvent)
			if err := p.AISpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAntennaEvent:
			p.AntennaEvent = new(AntennaEvent)
			if err := p.AntennaEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamConnectionAttemptEvent:
			p.ConnectionAttemptEvent = new(ConnectionAttemptEvent)
			*p.ConnectionAttemptEvent = ConnectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data[4:])))
		case ParamConnectionCloseEvent:
			p.ConnectionCloseEvent = new(ConnectionCloseEvent)
			if err := p.ConnectionCloseEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamSpecLoopEvent:
			p.SpecLoopEvent = new(SpecLoopEvent)
			if err := p.SpecLoopEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderEventNotificationData, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// HoppingEvent is Parameter 247, HoppingEvent.
type HoppingEvent uint16

// UnmarshalBinary Parameter 247, HoppingEvent.
func (p *HoppingEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamHoppingEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = HoppingEvent(binary.BigEndian.Uint16(data))
	return nil
}

// GPIEvent is Parameter 248, GPIEvent.
//
// GPIEvent is sent when a GPI changes state. If it triggers an ROSpec to start or stop,
// it's sent before the ROSpecEvent parameter.
type GPIEvent struct {
	Port uint16
	// Event is the Reader-defined value of GPI that triggered the event.
	Event bool
}

// UnmarshalBinary Parameter 248, GPIEvent.
func (p *GPIEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIEvent, 3, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Event = data[2]>>7 != 0
	return nil
}

// ROSpecEvent is Parameter 249, ROSpecEvent.
type ROSpecEvent struct {
	Event              ROSpecEventType
	ROSpecID           uint32
	PreemptingROSpecID uint32
}

// UnmarshalBinary Parameter 249, ROSpecEvent.
func (p *ROSpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecEvent, 9, len(data), true); err != nil {
		return err
	}
	p.Event = ROSpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.PreemptingROSpecID = binary.BigEndian.Uint32(data[5:])
	return nil
}

// ReportBufferLevelWarningEvent is Parameter 250, ReportBufferLevelWarningEvent.
type ReportBufferLevelWarningEvent uint8

// UnmarshalBinary Parameter 250, ReportBufferLevelWarningEvent.
func (p *ReportBufferLevelWarningEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferLevelWarningEvent, 1, len(data), true); err != nil {
		return err
	}
	*p = ReportBufferLevelWarningEvent(data[0])
	return nil
}

// ReportBufferOverflowErrorEvent is Parameter 251, ReportBufferOverflowErrorEvent.
type ReportBufferOverflowErrorEvent struct{}

// UnmarshalBinary Parameter 251, ReportBufferOverflowErrorEvent.
func (p *ReportBufferOverflowErrorEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferOverflowErrorEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// ReaderExceptionEvent is Parameter 252, ReaderExceptionEvent.
type ReaderExceptionEvent struct {
	Message                  string
	ROSpecID                 *ROSpecID
	SpecIndex                *SpecIndex
	InventoryParameterSpecID *InventoryParameterSpecID
	AntennaID                *AntennaID
	AccessSpecID             *AccessSpecID
	OpSpecID                 *OpSpecID
	Custom                   []Custom
}

// UnmarshalBinary Parameter 252, ReaderExceptionEvent.
func (p *ReaderExceptionEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderExceptionEvent, 2, len(data), false); err != nil {
		return err
	}
	if strLen := int(binary.BigEndian.Uint16(data)); strLen > len(data[2:]) {
		return errors.Errorf("Message (string) declares it has %d bytes, but "+
			"only %d bytes are available", strLen, len(data[2:]))
	} else if strLen != 0 {
		p.Message = string(data[2 : strLen+2])
		data = data[strLen+2:]
	} else {
		data = data[2:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamInventoryParameterSpecID:
			p.InventoryParameterSpecID = new(InventoryParameterSpecID)
			*p.InventoryParameterSpecID = InventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAntennaID:
			p.AntennaID = new(AntennaID)
			*p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAccessSpecID:
			p.AccessSpecID = new(AccessSpecID)
			*p.AccessSpecID = AccessSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamOpSpecID:
			p.OpSpecID = new(OpSpecID)
			*p.OpSpecID = OpSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup0
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ReaderExceptionEvent, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// RFSurveyEvent is Parameter 253, RFSurveyEvent.
type RFSurveyEvent struct {
	Event    RFSurveyEventType
	ROSpecID uint32
}

// UnmarshalBinary Parameter 253, RFSurveyEvent.
func (p *RFSurveyEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyEvent, 5, len(data), true); err != nil {
		return err
	}
	p.Event = RFSurveyEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	return nil
}

// AISpecEvent is Parameter 254, AISpecEvent.
type AISpecEvent struct {
	Event              AISpecEventType
	ROSpecID           uint32
	SpecIndex          uint16
	SingulationDetails *C1G2SingulationDetails
}

// UnmarshalBinary Parameter 254, AISpecEvent.
func (p *AISpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecEvent, 7, len(data), false); err != nil {
		return err
	}
	p.Event = AISpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.SpecIndex = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(data[0] & 0x7F); subType == ParamC1G2SingulationDetails {
		p.SingulationDetails = new(C1G2SingulationDetails)
		if err := p.SingulationDetails.UnmarshalBinary(data[1:5]); err != nil {
			return err
		}
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading AISpecEvent, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// AntennaEvent is Parameter 255, AntennaEvent.
type AntennaEvent struct {
	Event     AntennaEventType
	AntennaID AntennaID
}

// UnmarshalBinary Parameter 255, AntennaEvent.
func (p *AntennaEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaEvent, 3, len(data), true); err != nil {
		return err
	}
	p.Event = AntennaEventType(data[0])
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
	return nil
}

// ConnectionAttemptEvent is Parameter 256, ConnectionAttemptEvent.
type ConnectionAttemptEvent ConnectionAttemptEventType

// UnmarshalBinary Parameter 256, ConnectionAttemptEvent.
func (p *ConnectionAttemptEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionAttemptEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = ConnectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data)))
	return nil
}

// ConnectionCloseEvent is Parameter 257, ConnectionCloseEvent.
type ConnectionCloseEvent struct{}

// UnmarshalBinary Parameter 257, ConnectionCloseEvent.
func (p *ConnectionCloseEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionCloseEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// LLRPStatus is Parameter 287, LLRPStatus.
type LLRPStatus struct {
	Status           StatusCode
	ErrorDescription string
	FieldError       *FieldError
	ParameterError   *ParameterError
}

// UnmarshalBinary Parameter 287, LLRPStatus.
func (p *LLRPStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPStatus, 4, len(data), false); err != nil {
		return err
	}
	p.Status = StatusCode(binary.BigEndian.Uint16(data))
	if strLen := int(binary.BigEndian.Uint16(data[2:])); strLen > len(data[4:]) {
		return errors.Errorf("ErrorDescription (string) declares it has %d "+
			"bytes, but only %d bytes are available", strLen, len(data[4:]))
	} else if strLen != 0 {
		p.ErrorDescription = string(data[4 : strLen+4])
		data = data[strLen+4:]
	} else {
		data = data[4:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFieldError:
			p.FieldError = new(FieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamParameterError:
			p.ParameterError = new(ParameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading LLRPStatus, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// FieldError is Parameter 288, FieldError.
type FieldError struct {
	FieldIndex uint16
	ErrorCode  StatusCode
}

// UnmarshalBinary Parameter 288, FieldError.
func (p *FieldError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFieldError, 4, len(data), true); err != nil {
		return err
	}
	p.FieldIndex = binary.BigEndian.Uint16(data)
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	return nil
}

// ParameterError is Parameter 289, ParameterError.
type ParameterError struct {
	ParameterType  ParamType
	ErrorCode      StatusCode
	ParameterError *ParameterError
	FieldError     *FieldError
}

// UnmarshalBinary Parameter 289, ParameterError.
func (p *ParameterError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamParameterError, 4, len(data), false); err != nil {
		return err
	}
	p.ParameterType = ParamType(binary.BigEndian.Uint16(data))
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamParameterError:
			p.ParameterError = new(ParameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamFieldError:
			p.FieldError = new(FieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading ParameterError, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2LLRPCapabilities is Parameter 327, C1G2LLRPCapabilities.
//
// This parameter reports the C1G2-specific capabilities supported.
type C1G2LLRPCapabilities struct {
	SupportsBlockErase         bool
	SupportsBlockWrite         bool
	SupportsBlockPermalock     bool
	SupportsTagRecommissioning bool
	SupportsUMIMethod2         bool
	SupportsXPC                bool
	// MaxSelectFiltersPerQuery can be 0 to indicate no maximum.
	MaxSelectFiltersPerQuery uint16
}

// UnmarshalBinary Parameter 327, C1G2LLRPCapabilities.
func (p *C1G2LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LLRPCapabilities, 3, len(data), true); err != nil {
		return err
	}
	p.SupportsBlockErase = data[0]>>7 != 0
	p.SupportsBlockWrite = data[0]>>6&1 != 0
	p.SupportsBlockPermalock = data[0]>>5&1 != 0
	p.SupportsTagRecommissioning = data[0]>>4&1 != 0
	p.SupportsUMIMethod2 = data[0]>>3&1 != 0
	p.SupportsXPC = data[0]>>2&1 != 0
	p.MaxSelectFiltersPerQuery = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UHFC1G2RFModeTable is Parameter 328, UHFC1G2RFModeTable.
//
// This carries the set of C1G2 RF modes the Reader can operate.
//
// The specific details of each parameter are defined in the EPC Gen-2 UHF RFID Standard,
// though small portions are of that information are given here for clarity.
//
// These settings dictate aspects of the physical communication between the reader and
// tags, and therefore directly impact the performance of their interaction. The best
// choices of parameters depends heavily on the physical environment in which the reader
// and tags are present.
//
// Each table entry has a ModeID which the client must reference to set the relevant
// operating parameters.
//
// "Tari" values used in these parameters is the "Type A Reference Interval", and while
// the details are more complicated, it can be thought of as how long it takes to transmit
// a 0-bit. The time it takes to transmit a 1-bit is somewhere between 1.5 and 2 Tari,
// depending on other parameters.
//
// In the broadest case, valid Tari values are 6.25-25 microseconds (i.e., 6250 to 25000
// nanoseconds), though it may be limited by the reader; in many cases, a client may pass
// 0 to allow the reader to select a valid in-range value.
//
// The tag uses the DivideRatio to calculate the backscatter link frequency (BLF), which
// itself is ultimately a multiple the of data rate. It may be one of two constants: 64/3
// or 8/1. Having different DivideRatios permits the same BLF with a different Tari value.
//
// The reader instructs the tags what type of subcarrier Modulation to use when encoding
// their backscattered reply. At FM0, the data rate in kBitsPerSec is approximately BLF in
// KiloHertz. Essentially, Miller values require 2, 4, or 8 times as many cycles as FM0,
// and so the data rate will be roughly 1/2, 1/4, or 1/8 BLF. Note that this does not
// affect whether the tags use ASK or PSK modulation; that's determined by the tag
// manufacturer.
//
// A vendor may have had these parameters certified by EPCglobal's Hardware Action Group's
// Testing and Conformance group, in which case the IsEPCHagConformant will be true.
type UHFC1G2RFModeTable struct {
	UHFC1G2RFModeTableEntries []UHFC1G2RFModeTableEntry
}

// UnmarshalBinary Parameter 328, UHFC1G2RFModeTable.
func (p *UHFC1G2RFModeTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTable, 32, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamUHFC1G2RFModeTableEntry:
			var tmp UHFC1G2RFModeTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.UHFC1G2RFModeTableEntries = append(p.UHFC1G2RFModeTableEntries, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading UHFC1G2RFModeTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UHFC1G2RFModeTableEntry is Parameter 329, UHFC1G2RFModeTableEntry.
//
// See UHFC1G2RFModelTable for more information.
type UHFC1G2RFModeTableEntry struct {
	// ModeID is used by the client when setting an RF mode parameter.
	ModeID                uint32
	DivideRatio           DivideRatio
	IsEPCHagConformant    bool
	Modulation            BackscatterMod
	ForwardLinkModulation FwdLinkMod
	SpectralMask          SpectralMaskType
	BackscatterDataRate   BitsPerSec
	// PIERatio is 1000x the the data-0 to data-1 symbol lengths ratio.
	PIERatio     uint32
	MinTariTime  NanoSecs32
	MaxTariTime  NanoSecs32
	StepTariTime NanoSecs32
}

// UnmarshalBinary Parameter 329, UHFC1G2RFModeTableEntry.
func (p *UHFC1G2RFModeTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTableEntry, 28, len(data), true); err != nil {
		return err
	}
	p.ModeID = binary.BigEndian.Uint32(data)
	p.DivideRatio = DivideRatio(data[4] >> 7)
	p.IsEPCHagConformant = data[4]>>6&1 != 0
	p.Modulation = BackscatterMod(data[5])
	p.ForwardLinkModulation = FwdLinkMod(data[6])
	p.SpectralMask = SpectralMaskType(data[7])
	p.BackscatterDataRate = binary.BigEndian.Uint32(data[8:])
	p.PIERatio = binary.BigEndian.Uint32(data[12:])
	p.MinTariTime = binary.BigEndian.Uint32(data[16:])
	p.MaxTariTime = binary.BigEndian.Uint32(data[20:])
	p.StepTariTime = binary.BigEndian.Uint32(data[24:])
	return nil
}

// C1G2InventoryCommand is Parameter 330, C1G2InventoryCommand.
type C1G2InventoryCommand struct {
	TagInventoryStateAware bool
	Filters                []C1G2Filter
	RFControl              *C1G2RFControl
	SingulationControl     *C1G2SingulationControl
	Custom                 []Custom
}

// UnmarshalBinary Parameter 330, C1G2InventoryCommand.
func (p *C1G2InventoryCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2InventoryCommand, 1, len(data), false); err != nil {
		return err
	}
	p.TagInventoryStateAware = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Filter:
			var tmp C1G2Filter
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Filters = append(p.Filters, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2RFControl:
			p.RFControl = new(C1G2RFControl)
			if err := p.RFControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2SingulationControl:
			p.SingulationControl = new(C1G2SingulationControl)
			if err := p.SingulationControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2InventoryCommand, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2Filter is Parameter 331, C1G2Filter.
//
// If the Reader supports tag-inventory-aware singulation, you can set the
// AwareFilterAction. If not, you can use the UnawareFilterAction.
type C1G2Filter struct {
	TruncateAction      C1G2FilterTruncateActionType
	TagInventoryMask    C1G2TagInventoryMask
	AwareFilterAction   *C1G2TagInventoryStateAwareFilterAction
	UnawareFilterAction *C1G2TagInventoryStateUnawareFilterAction
}

// UnmarshalBinary Parameter 331, C1G2Filter.
func (p *C1G2Filter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Filter, 10, len(data), false); err != nil {
		return err
	}
	p.TruncateAction = C1G2FilterTruncateActionType(data[0] >> 6)
	data = data[1:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagInventoryMask {
		return errors.Errorf("expected ParamC1G2TagInventoryMask, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryMask says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.TagInventoryMask.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2TagInventoryStateAwareFilterAction:
			p.AwareFilterAction = new(C1G2TagInventoryStateAwareFilterAction)
			if err := p.AwareFilterAction.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2TagInventoryStateUnawareFilterAction:
			p.UnawareFilterAction = new(C1G2TagInventoryStateUnawareFilterAction)
			*p.UnawareFilterAction = C1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[4]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Filter, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// C1G2TagInventoryMask is Parameter 332, C1G2TagInventoryMask.
type C1G2TagInventoryMask struct {
	MemoryBank         C1G2MemoryBankType
	MostSignificantBit uint16
	TagMaskNumBits     uint16
	TagMask            []byte
}

// UnmarshalBinary Parameter 332, C1G2TagInventoryMask.
func (p *C1G2TagInventoryMask) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryMask, 5, len(data), false); err != nil {
		return err
	}
	p.MemoryBank = data[0] >> 6
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return errors.Errorf("TagMask (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagMaskNumBits,
			nBytes, len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, nBytes)
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TagInventoryMask, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2TagInventoryStateAwareFilterAction is Parameter 333,
// C1G2TagInventoryStateAwareFilterAction.
type C1G2TagInventoryStateAwareFilterAction struct {
	Target       C1G2TagInventoryTargetType
	FilterAction C1G2TagInventoryStateAwareFilterActionType
}

// UnmarshalBinary Parameter 333, C1G2TagInventoryStateAwareFilterAction.
func (p *C1G2TagInventoryStateAwareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareFilterAction, 2, len(data), true); err != nil {
		return err
	}
	p.Target = C1G2TagInventoryTargetType(data[0])
	p.FilterAction = C1G2TagInventoryStateAwareFilterActionType(data[1])
	return nil
}

// C1G2TagInventoryStateUnawareFilterAction is Parameter 334,
// C1G2TagInventoryStateUnawareFilterAction.
type C1G2TagInventoryStateUnawareFilterAction C1G2TagInventoryStateUnawareFilterActionType

// UnmarshalBinary Parameter 334, C1G2TagInventoryStateUnawareFilterAction.
func (p *C1G2TagInventoryStateUnawareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateUnawareFilterAction, 1, len(data), true); err != nil {
		return err
	}
	*p = C1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[0]))
	return nil
}

// C1G2RFControl is Parameter 335, C1G2RFControl.
type C1G2RFControl struct {
	// RFModeID must match one of the ModeIDs in the C1G2RFModes table that comes in the
	// UHFBandCapabilities (ParamType 144) section of the RegulatoryCapabilities (ParamType
	// 143) section of the GetReaderCapabilitiesResponse (MessageType 11)
	RFModeID uint16
	// Tari is "Type A Reference Interval", in nanoseconds. Typically, values must be
	// 6250-25000ns, though they may be restricted by the RFModes table. Usually, a client
	// can use 0 to allow the Reader to select a valid value.
	//
	// While the details are more complicated, the Tari duration is a basis for most other
	// protocol durations, so all else equal, a shorter Tari allows a higher bitrate, but
	// that's an gross oversimplification. For more information, see the EPC Class 1 Gen 2
	// standard and consult an RF engineer.
	Tari NanoSecs16
}

// UnmarshalBinary Parameter 335, C1G2RFControl.
func (p *C1G2RFControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RFControl, 4, len(data), true); err != nil {
		return err
	}
	p.RFModeID = binary.BigEndian.Uint16(data)
	p.Tari = binary.BigEndian.Uint16(data[2:])
	return nil
}

// C1G2SingulationControl is Parameter 336, C1G2SingulationControl.
type C1G2SingulationControl struct {
	// Session number for the inventory operation (0-3).
	Session C1G2SingulationSession
	// TagPopulation expected in the antenna's field of view.
	TagPopulation uint16
	// TagTransitTime is a measure of the expected tag mobility.
	TagTransitTime MilliSecs32
	InvAwareAction *C1G2TagInventoryStateAwareSingulationAction
}

// UnmarshalBinary Parameter 336, C1G2SingulationControl.
func (p *C1G2SingulationControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationControl, 7, len(data), false); err != nil {
		return err
	}
	p.Session = data[0] >> 6
	p.TagPopulation = binary.BigEndian.Uint16(data[1:])
	p.TagTransitTime = binary.BigEndian.Uint32(data[3:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateAwareSingulationAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryStateAwareSingulationAction "+
				"says it has %d bytes, but only %d bytes remain", subLen, len(data))
		}
		p.InvAwareAction = new(C1G2TagInventoryStateAwareSingulationAction)
		if err := p.InvAwareAction.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2SingulationControl, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2TagInventoryStateAwareSingulationAction is Parameter 337,
// C1G2TagInventoryStateAwareSingulationAction.
type C1G2TagInventoryStateAwareSingulationAction struct {
	InventoryState SingActAwareState
	Selected       bool
}

// UnmarshalBinary Parameter 337, C1G2TagInventoryStateAwareSingulationAction.
func (p *C1G2TagInventoryStateAwareSingulationAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareSingulationAction, 1, len(data), true); err != nil {
		return err
	}
	p.InventoryState = SingActAwareState(data[0] >> 7)
	p.Selected = data[0]>>6&1 != 0
	return nil
}

// C1G2TagSpec is Parameter 338, C1G2TagSpec.
type C1G2TagSpec struct {
	TagPattern1 C1G2TargetTag
	TagPattern2 *C1G2TargetTag
}

// UnmarshalBinary Parameter 338, C1G2TagSpec.
func (p *C1G2TagSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagSpec, 11, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TargetTag {
		return errors.Errorf("expected ParamC1G2TargetTag, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.TagPattern1.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TargetTag {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.TagPattern2 = new(C1G2TargetTag)
		if err := p.TagPattern2.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TagSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2TargetTag is Parameter 339, C1G2TargetTag.
type C1G2TargetTag struct {
	C1G2MemoryBank     C1G2MemoryBankType
	MatchFlag          bool
	MostSignificantBit uint16
	TagMaskNumBits     uint16
	TagMask            []byte
	TagDataNumBits     uint16
	TagData            []byte
}

// UnmarshalBinary Parameter 339, C1G2TargetTag.
func (p *C1G2TargetTag) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TargetTag, 7, len(data), false); err != nil {
		return err
	}
	p.C1G2MemoryBank = data[0] >> 6
	p.MatchFlag = data[0]>>5&1 != 0
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return errors.Errorf("TagMask (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagMaskNumBits,
			nBytes, len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, nBytes)
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	} else {
		data = data[5:]
	}
	p.TagDataNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagDataNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return errors.Errorf("TagData (bit array) declares it has %d bits "+
			"(%d bytes), but only %d bytes are available", p.TagDataNumBits,
			nBytes, len(data[2:]))
	} else if nBytes != 0 {
		p.TagData = make([]byte, nBytes)
		copy(p.TagData, data[2:])
		data = data[nBytes+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TargetTag, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2Read is Parameter 341, C1G2Read.
type C1G2Read struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 341, C1G2Read.
func (p *C1G2Read) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Read, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// C1G2Write is Parameter 342, C1G2Write.
type C1G2Write struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 342, C1G2Write.
func (p *C1G2Write) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Write, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Write, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// C1G2Kill is Parameter 343, C1G2Kill.
type C1G2Kill struct {
	OpSpecID     uint16
	KillPassword uint32
}

// UnmarshalBinary Parameter 343, C1G2Kill.
func (p *C1G2Kill) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Kill, 6, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	return nil
}

// C1G2Lock is Parameter 344, C1G2Lock.
type C1G2Lock struct {
	OpSpecID         uint16
	AccessPassword   uint32
	C1G2LockPayloads []C1G2LockPayload
}

// UnmarshalBinary Parameter 344, C1G2Lock.
func (p *C1G2Lock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Lock, 12, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	data = data[6:]
	// sub-parameters

paramGroup0:
	for len(data) > 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2LockPayload:
			var tmp C1G2LockPayload
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2LockPayloads = append(p.C1G2LockPayloads, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Lock, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// C1G2LockPayload is Parameter 345, C1G2LockPayload.
type C1G2LockPayload struct {
	LockPrivilege LockPrivilegeType
	LockData      LockDataType
}

// UnmarshalBinary Parameter 345, C1G2LockPayload.
func (p *C1G2LockPayload) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockPayload, 2, len(data), true); err != nil {
		return err
	}
	p.LockPrivilege = LockPrivilegeType(data[0])
	p.LockData = LockDataType(data[1])
	return nil
}

// C1G2BlockErase is Parameter 346, C1G2BlockErase.
type C1G2BlockErase struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 346, C1G2BlockErase.
func (p *C1G2BlockErase) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockErase, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// C1G2BlockWrite is Parameter 347, C1G2BlockWrite.
type C1G2BlockWrite struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 347, C1G2BlockWrite.
func (p *C1G2BlockWrite) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWrite, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockWrite, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2EPCMemorySelector is Parameter 348, C1G2EPCMemorySelector.
type C1G2EPCMemorySelector struct {
	CRCEnabled     bool
	PCBitsEnabled  bool
	XPCBitsEnabled bool
}

// UnmarshalBinary Parameter 348, C1G2EPCMemorySelector.
func (p *C1G2EPCMemorySelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2EPCMemorySelector, 1, len(data), true); err != nil {
		return err
	}
	p.CRCEnabled = data[0]>>7 != 0
	p.PCBitsEnabled = data[0]>>6&1 != 0
	p.XPCBitsEnabled = data[0]>>5&1 != 0
	return nil
}

// C1G2ReadOpSpecResult is Parameter 349, C1G2ReadOpSpecResult.
type C1G2ReadOpSpecResult struct {
	C1G2ReadOpSpecResultType C1G2ReadOpSpecResultType
	OpSpecID                 uint16
	Data                     []uint16
}

// UnmarshalBinary Parameter 349, C1G2ReadOpSpecResult.
func (p *C1G2ReadOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2ReadOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2ReadOpSpecResultType = C1G2ReadOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2ReadOpSpecResult, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2WriteOpSpecResult is Parameter 350, C1G2WriteOpSpecResult.
type C1G2WriteOpSpecResult struct {
	C1G2WriteOpSpecResultType C1G2WriteOpSpecResultType
	OpSpecID                  uint16
	WordsWritten              uint16
}

// UnmarshalBinary Parameter 350, C1G2WriteOpSpecResult.
func (p *C1G2WriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2WriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2WriteOpSpecResultType = C1G2WriteOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// C1G2KillOpSpecResult is Parameter 351, C1G2KillOpSpecResult.
type C1G2KillOpSpecResult struct {
	C1G2KillResult C1G2KillResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 351, C1G2KillOpSpecResult.
func (p *C1G2KillOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2KillOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2KillResult = C1G2KillResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// C1G2LockOpSpecResult is Parameter 352, C1G2LockOpSpecResult.
type C1G2LockOpSpecResult struct {
	C1G2LockResult C1G2LockResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 352, C1G2LockOpSpecResult.
func (p *C1G2LockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2LockResult = C1G2LockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// C1G2BlockEraseOpSpecResult is Parameter 353, C1G2BlockEraseOpSpecResult.
type C1G2BlockEraseOpSpecResult struct {
	C1G2BlockEraseResult C1G2BlockEraseResultType
	OpSpecID             uint16
}

// UnmarshalBinary Parameter 353, C1G2BlockEraseOpSpecResult.
func (p *C1G2BlockEraseOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockEraseOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockEraseResult = C1G2BlockEraseResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// C1G2BlockWriteOpSpecResult is Parameter 354, C1G2BlockWriteOpSpecResult.
type C1G2BlockWriteOpSpecResult struct {
	C1G2BlockWriteResult C1G2BlockWriteResultType
	OpSpecID             uint16
	WordsWritten         uint16
}

// UnmarshalBinary Parameter 354, C1G2BlockWriteOpSpecResult.
func (p *C1G2BlockWriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockWriteResult = C1G2BlockWriteResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// LoopSpec is Parameter 355, LoopSpec.
type LoopSpec uint32

// UnmarshalBinary Parameter 355, LoopSpec.
func (p *LoopSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLoopSpec, 4, len(data), true); err != nil {
		return err
	}
	*p = LoopSpec(binary.BigEndian.Uint32(data))
	return nil
}

// SpecLoopEvent is Parameter 356, SpecLoopEvent.
type SpecLoopEvent struct {
	ROSpecID  uint32
	LoopCount uint32
}

// UnmarshalBinary Parameter 356, SpecLoopEvent.
func (p *SpecLoopEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecLoopEvent, 8, len(data), true); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.LoopCount = binary.BigEndian.Uint32(data[4:])
	return nil
}

// C1G2Recommission is Parameter 357, C1G2Recommission.
type C1G2Recommission struct {
	OpSpecID     uint16
	KillPassword uint32
	SB3          bool
	SB2          bool
	LSB          bool
}

// UnmarshalBinary Parameter 357, C1G2Recommission.
func (p *C1G2Recommission) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Recommission, 7, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	p.SB3 = data[6]>>2&1 != 0
	p.SB2 = data[6]>>1&1 != 0
	p.LSB = data[6]&1 != 0
	return nil
}

// C1G2BlockPermalock is Parameter 358, C1G2BlockPermalock.
type C1G2BlockPermalock struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockMask      []uint16
}

// UnmarshalBinary Parameter 358, C1G2BlockPermalock.
func (p *C1G2BlockPermalock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalock, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("BlockMask ([]uint16) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.BlockMask = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.BlockMask[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockPermalock, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// C1G2GetBlockPermalockStatus is Parameter 359, C1G2GetBlockPermalockStatus.
type C1G2GetBlockPermalockStatus struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockRange     uint16
}

// UnmarshalBinary Parameter 359, C1G2GetBlockPermalockStatus.
func (p *C1G2GetBlockPermalockStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatus, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	p.BlockRange = binary.BigEndian.Uint16(data[9:])
	return nil
}

// C1G2RecommissionOpSpecResult is Parameter 360, C1G2RecommissionOpSpecResult.
type C1G2RecommissionOpSpecResult struct {
	C1G2RecommissionResult C1G2RecommissionResultType
	OpSpecID               uint16
}

// UnmarshalBinary Parameter 360, C1G2RecommissionOpSpecResult.
func (p *C1G2RecommissionOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RecommissionOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2RecommissionResult = C1G2RecommissionResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// C1G2BlockPermalockOpSpecResult is Parameter 361, C1G2BlockPermalockOpSpecResult.
type C1G2BlockPermalockOpSpecResult struct {
	C1G2BlockPermalockResult C1G2BlockPermalockResultType
	OpSpecID                 uint16
}

// UnmarshalBinary Parameter 361, C1G2BlockPermalockOpSpecResult.
func (p *C1G2BlockPermalockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockPermalockResult = C1G2BlockPermalockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// C1G2GetBlockPermalockStatusOpSpecResult is Parameter 362,
// C1G2GetBlockPermalockStatusOpSpecResult.
type C1G2GetBlockPermalockStatusOpSpecResult struct {
	C1G2GetBlockPermalockStatusResult C1G2GetBlockPermalockStatusResultType
	OpSpecID                          uint16
	// PermalockStatuses of each block requested.
	PermalockStatuses []uint16
}

// UnmarshalBinary Parameter 362, C1G2GetBlockPermalockStatusOpSpecResult.
func (p *C1G2GetBlockPermalockStatusOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatusOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2GetBlockPermalockStatusResult = C1G2GetBlockPermalockStatusResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("PermalockStatuses ([]uint16) declares it has "+
			"%d*2 bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.PermalockStatuses = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.PermalockStatuses[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return errors.Errorf("finished reading "+
			"C1G2GetBlockPermalockStatusOpSpecResult, but an unexpected %d bytes "+
			"remain", len(data))
	}
	return nil
}

// MaximumReceiveSensitivity is Parameter 363, MaximumReceiveSensitivity.
//
// MaximumReceiveSensitivity is the maximum receive sensitivity supported by the Reader.
// It's required if the Reader allows receive sensitivity control, but otherwise optional.
type MaximumReceiveSensitivity DeciBelMilliWatt16

// UnmarshalBinary Parameter 363, MaximumReceiveSensitivity.
func (p *MaximumReceiveSensitivity) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamMaximumReceiveSensitivity, 2, len(data), true); err != nil {
		return err
	}
	*p = MaximumReceiveSensitivity(DeciBelMilliWatt16(binary.BigEndian.Uint16(data)))
	return nil
}

// RFSurveyFrequencyCapabilities is Parameter 365, RFSurveyFrequencyCapabilities.
type RFSurveyFrequencyCapabilities struct {
	MinFrequency KiloHertz
	MaxFrequency KiloHertz
}

// UnmarshalBinary Parameter 365, RFSurveyFrequencyCapabilities.
func (p *RFSurveyFrequencyCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyFrequencyCapabilities, 8, len(data), true); err != nil {
		return err
	}
	p.MinFrequency = binary.BigEndian.Uint32(data)
	p.MaxFrequency = binary.BigEndian.Uint32(data[4:])
	return nil
}

// Custom is Parameter 1023, Custom.
type Custom struct {
	VendorID uint32
	Subtype  uint32
	Data     []byte
}

// UnmarshalBinary Parameter 1023, Custom.
func (p *Custom) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamCustom, 8, len(data), false); err != nil {
		return err
	}
	p.VendorID = binary.BigEndian.Uint32(data)
	p.Subtype = binary.BigEndian.Uint32(data[4:])
	if len(data)-8 == 0 {
		return nil
	}
	p.Data = make([]byte, len(data)-8)
	copy(p.Data, data[8:])
	data = data[8:]
	return nil
}
