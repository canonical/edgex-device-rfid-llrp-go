//
// Copyright (C) 2020 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by "generate_param_code.py"; DO NOT EDIT.

package llrp

import (
	"encoding/binary"
	"github.com/pkg/errors"
)

// dBm16 is a 16-bit dBm value, primarily for absolute max sensitivity.
type dBm16 = int16

// dBm8 is a 8-bit dBm value, usually to represent RSSI.
type dBm8 = int8

// dBiX100 is dBi*100, primarily for fractional dBi antenna gain values.
type dBiX100 = uint16

// dBmX100 is dBm*100, primarily for fractional dBm transmit power values.
type dBmX100 = uint16

// dB relative a reference, primarily for receive sensitivity values.
type dB = uint16

// microSecs64 is a 64-bit number of microseconds.
//
// It's usually used to represent a time offset since a known reference,
// Unix Epoch or the reader's start.
type microSecs64 = uint64

// microSecs64 is a 32-bit number of milliseconds.
//
// It's used to represent a time offset since a known reference,
// usually Unix Epoch or a message receipt time.
// Other times, it's used as a time period or timeout,
// in which case 0 may mean "never timeout".
type milliSecs32 = uint32

// milliSecs16 is a 16-bit number of milliseconds.
//
// It's used to represent a timeouts or duration triggers.
type milliSecs16 = uint16

// nanoSecs32 is a 32-bit number of nanoseconds used for some Tari values.
type nanoSecs32 = uint32

// nanoSecs16 is a 16-bit number of nanoseconds
// used for some Tari values or for RF Control.
type nanoSecs16 = uint16

// kHz is kilo-Hertz, used for frequency values.
type kHz = uint32

// bps is bits per second, used in backscatter data rates.
type bps = uint32

// C1G2MemoryBankType selection.
type C1G2MemoryBankType = uint8

type C1G2BlockPermalockResultType uint8

const (
	C1G2BPLockSuccess                = C1G2BlockPermalockResultType(0)
	C1G2BPLockInsufficientPower      = C1G2BlockPermalockResultType(1)
	C1G2BPLockNonSpecificTagError    = C1G2BlockPermalockResultType(2)
	C1G2BPLockNoResponseFromTag      = C1G2BlockPermalockResultType(3)
	C1G2BPLockNonSpecificReaderError = C1G2BlockPermalockResultType(4)
	C1G2BPLockIncorrectPassword      = C1G2BlockPermalockResultType(5)
	C1G2BPLockMemoryOverrun          = C1G2BlockPermalockResultType(6)
)

type AirProtocolIDType uint8

const (
	AirProtoUnspecified         = AirProtocolIDType(0)
	AirProtoEPCGlobalClass1Gen2 = AirProtocolIDType(1)
)

// CountryCodeType is an ISO-3166 country code.
type CountryCodeType uint16
type C1G2ReadOpSpecResultType uint8
type LockDataType uint8
type C1G2TagInventoryTargetType uint8
type C1G2SingulationControlSessionType uint8
type C1G2TagInventoryStateAwareFilterActionType uint8
type C1G2TagInventoryStateUnawareFilterActionType uint8

type ROSpecCurrentStateType uint8

const (
	ROSpecStateDisabled = ROSpecCurrentStateType(0)
	ROSpecStateInactive = ROSpecCurrentStateType(1)
	ROSpecStateActive   = ROSpecCurrentStateType(2)
)

type AccessSpecStopTriggerType uint8

const (
	AccessSpecStopTriggerNone           = AccessSpecStopTriggerType(0)
	AccessSpecStopTriggerOperationCount = AccessSpecStopTriggerType(1)
)

type ReaderEventType uint16
type AntennaEventType uint8

type ConnectionAttemptEventType uint16

const (
	ConnSuccess               = ConnectionAttemptEventType(0)
	ConnExistsReaderInitiated = ConnectionAttemptEventType(1)
	ConnExistsClientInitiated = ConnectionAttemptEventType(2)
	ConnFailedReasonUnknown   = ConnectionAttemptEventType(3)
	ConnAttemptedAgain        = ConnectionAttemptEventType(4)
)

type ROSpecEventType uint8
type AISpecEventType uint8
type RFSurveyEventType uint8

type KeepAliveTriggerType uint8

const (
	KATriggerNone     = KeepAliveTriggerType(0)
	KATriggerPeriodic = KeepAliveTriggerType(1)
)

type AccessReportTriggerType uint8
type ROReportTriggerType uint8

type ROSpecStartTriggerType uint8

const (
	ROStartTriggerNone      = ROSpecStartTriggerType(0)
	ROStartTriggerImmediate = ROSpecStartTriggerType(1)
	ROStartTriggerPeriodic  = ROSpecStartTriggerType(2)
	ROStartTriggerGPI       = ROSpecStartTriggerType(3)
)

type ROSpecStopTriggerType uint8

const (
	ROStopTriggerNone     = ROSpecStopTriggerType(0)
	ROStopTriggerDuration = ROSpecStopTriggerType(1)
	ROStopTriggerGPI      = ROSpecStopTriggerType(2)
)

type RFSurveySpecStopTriggerType uint8

const (
	RFSurveyStopTriggerNone       = RFSurveySpecStopTriggerType(0)
	RFSurveyStopTriggerDuration   = RFSurveySpecStopTriggerType(1)
	RFSurveyStopTriggerNIteration = RFSurveySpecStopTriggerType(2)
)

type AISpecStopTriggerType uint8

const (
	AIStopTriggerNone           = AISpecStopTriggerType(0)
	AIStopTriggerDuration       = AISpecStopTriggerType(1)
	AIStopTriggerGPI            = AISpecStopTriggerType(2)
	AIStopTriggerTagObservation = AISpecStopTriggerType(3)
)

type TagObservationTriggerType uint8

const (
	TagObsTriggerNTagObservations    = TagObservationTriggerType(0)
	TagObsTriggerNoNewAfterT         = TagObservationTriggerType(1)
	TagObsTriggerNAttempts           = TagObservationTriggerType(2)
	TagObsTriggerNUniqueObservations = TagObservationTriggerType(3)
	TagObsTriggerNoUniqueAfterT      = TagObservationTriggerType(4)
)

type SpectralMaskType uint8
type C1G2RecommissionResultType uint8
type C1G2WriteOpSpecResultType uint8

type IDType uint8

const (
	IDMAC_EUI64 = IDType(0)
	IDEPC       = IDType(1)
)

type C1G2KillResultType uint8
type C1G2LockResultType uint8
type ModulationType uint8
type C1G2BlockEraseResultType uint8
type GPIStateType uint8
type ForwardLinkModulationType uint8
type LockPrivilegeType uint8
type C1G2GetBlockPermalockStatusResultType uint8
type C1G2BlockWriteResultType uint8
type C1G2FilterActionType uint8

// VersionNum corresponds to an LLRP version number.
//
// The version number is 3 bits
// and embedded in each message sent between a Reader and Client.
//
// By default, this package will attempt to establish connection with Readers
// using the higher version it knows,
// but you can explicitly override it when creating a connection.
// In either case, for versions greater than 1.0.1,
// the Client will negotiate versions with the Reader and downgrade if necessary.
type VersionNum uint8

const (
	versionUnknown = VersionNum(0)
	Version1_0_1   = VersionNum(1)
	Version1_1     = VersionNum(2)
)

// StatusCode matches LLRP's Status Codes.
//
// These are described in Section 14 of the Low Level Reader Protocol v1.0.1
// and in Section 15 of Low Level Reader Protocol v1.1.
type StatusCode uint16

const (
	StatusSuccess               = StatusCode(0)
	StatusMsgParamError         = StatusCode(100)
	StatusMsgFieldError         = StatusCode(101)
	StatusMsgParamUnexpected    = StatusCode(102)
	StatusMsgParamMissing       = StatusCode(103)
	StatusMsgParamDuplicate     = StatusCode(104)
	StatusMsgParamOverflow      = StatusCode(105)
	StatusMsgFieldOverflow      = StatusCode(106)
	StatusMsgParamUnknown       = StatusCode(107)
	StatusMsgFieldUnknown       = StatusCode(108)
	StatusMsgMsgUnsupported     = StatusCode(109)
	StatusMsgVerUnsupported     = StatusCode(110)
	StatusMsgParamUnsupported   = StatusCode(111)
	StatusMsgMsgUnexpected      = StatusCode(112)
	StatusParamParamError       = StatusCode(200)
	StatusParamFieldError       = StatusCode(201)
	StatusParamParamUnexpected  = StatusCode(202)
	StatusParamParamMissing     = StatusCode(203)
	StatusParamParamDuplicate   = StatusCode(204)
	StatusParamParamOverflow    = StatusCode(205)
	StatusParamFieldOverflow    = StatusCode(206)
	StatusParamParamUnknown     = StatusCode(207)
	StatusParamFieldUnknown     = StatusCode(208)
	StatusParamParamUnsupported = StatusCode(209)
	StatusFieldInvalid          = StatusCode(300)
	StatusFieldOutOfRange       = StatusCode(301)
	StatusDeviceError           = StatusCode(401)
)

type ReaderCapabilitiesRequestedDataType uint8

const (
	ReaderCapAll                         = ReaderCapabilitiesRequestedDataType(0)
	ReaderCapGeneralDeviceCapabilities   = ReaderCapabilitiesRequestedDataType(1)
	ReaderCapLLRPCapabilities            = ReaderCapabilitiesRequestedDataType(2)
	ReaderCapRegulatorCapabilities       = ReaderCapabilitiesRequestedDataType(3)
	ReaderCapAirProtocolLLRPCapabilities = ReaderCapabilitiesRequestedDataType(4)
)

type ReaderConfigRequestedDataType uint8

const (
	ReaderConfReqAll                  = ReaderConfigRequestedDataType(0)
	ReaderConfReqIdentification       = ReaderConfigRequestedDataType(1)
	ReaderConfReqAntennaProperties    = ReaderConfigRequestedDataType(2)
	ReaderConfReqAntennaConfig        = ReaderConfigRequestedDataType(3)
	ReaderConfReqROReportSpec         = ReaderConfigRequestedDataType(4)
	ReaderConfReqReaderEventNotifSpec = ReaderConfigRequestedDataType(5)
	ReaderConfReqAccessReportSpec     = ReaderConfigRequestedDataType(6)
	ReaderConfReqLLRPConfStateVal     = ReaderConfigRequestedDataType(7)
	ReaderConfReqKeepAliveSpec        = ReaderConfigRequestedDataType(8)
	ReaderConfReqGPIPortCurState      = ReaderConfigRequestedDataType(9)
	ReaderConfReqGPOWriteData         = ReaderConfigRequestedDataType(10)
	ReaderConfReqEventsAndReports     = ReaderConfigRequestedDataType(11)
)

type GPITriggerFlags uint8

const GPIEvent = GPITriggerFlags(1 << 7)

type GPIPortConfigFlags uint8
type GPOWriteFlags uint8

const GPOPinTargetState = GPOWriteFlags(1 << 7)

type C1G2TagInventoryStateAwareSingulationActionFlags uint8
type GPIEventFlags uint8
type AntennaPropertiesFlags uint8

const AntennaConnected = AntennaPropertiesFlags(1 << 7)

type UHFC1G2RFModeFlags uint8
type C1G2EPCMemorySelectorFlags uint8
type EventsandReportsFlags uint8
type AccessSpecFlags uint8
type TagReportContentSelectorFlags uint16
type NotificationStateFlags uint8
type C1G2CapabilitiesFlags uint8
type C1G2RecommissionFlags uint8
type C1G2InventoryCommandFlags uint8

type GeneralCapabilityFlags uint8

const (
	CanSetAntennaProperties = GeneralCapabilityFlags(1 << (7 - iota))
	HasUTCClock
)

type HoppingFlags uint8

const Hopping = HoppingFlags(1 << 7)

type LLRPCapabilitiesFlags uint8

const (
	CanDoRFSurvey = LLRPCapabilitiesFlags(1 << (7 - iota))
	CanReportBufferFillWarning
	SupportsClientRequestOpSpec
	CanDoTagInventoryStateAwareSingulation
	SupportsEventsAndReportHolding
)

// getSupportedVersion is Message 46, GetSupportedVersion.
type getSupportedVersion struct{}

// UnmarshalBinary Message 46, GetSupportedVersion.
func (m *getSupportedVersion) UnmarshalBinary(data []byte) error {
	// GetSupportedVersion is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetSupportedVersion should be empty, but has %d bytes", len(data))
	}

	return nil
}

// getSupportedVersionResponse is Message 56, GetSupportedVersionResponse.
type getSupportedVersionResponse struct {
	CurrentVersion      VersionNum
	MaxSupportedVersion VersionNum
	LLRPStatus          llrpStatus
}

// UnmarshalBinary Message 56, GetSupportedVersionResponse.
func (m *getSupportedVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ParamGetSupportedVersionResponse requires at least 10 bytes "+
			"but only %d are available", len(data))
	}

	m.CurrentVersion = VersionNum(data[0])
	m.MaxSupportedVersion = VersionNum(data[1])
	data = data[2:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamLLRPStatus needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// setProtocolVersion is Message 47, SetProtocolVersion.
type setProtocolVersion struct {
	TargetVersion VersionNum
}

// UnmarshalBinary Message 47, SetProtocolVersion.
func (m *setProtocolVersion) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamSetProtocolVersion requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	m.TargetVersion = VersionNum(data[0])
	if len(data) > 0 {
		return errors.Errorf("finished reading SetProtocolVersion, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// setProtocolVersionResponse is Message 57, SetProtocolVersionResponse.
type setProtocolVersionResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 57, SetProtocolVersionResponse.
func (m *setProtocolVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamSetProtocolVersionResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// getReaderCapabilities is Message 1, GetReaderCapabilities.
type getReaderCapabilities struct {
	ReaderCapabilitiesRequestedData ReaderCapabilitiesRequestedDataType
	Custom                          []custom
}

// UnmarshalBinary Message 1, GetReaderCapabilities.
func (m *getReaderCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamGetReaderCapabilities requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	m.ReaderCapabilitiesRequestedData = ReaderCapabilitiesRequestedDataType(data[0])
	data = data[1:]

	// sub-parameters

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.Custom = append(m.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// getReaderCapabilitiesResponse is Message 11, GetReaderCapabilitiesResponse.
type getReaderCapabilitiesResponse struct {
	LLRPStatus                llrpStatus
	GeneralDeviceCapabilities *generalDeviceCapabilities
	LLRPCapabilities          *llrpCapabilities
	RegulatoryCapabilities    *regulatoryCapabilities
	C1G2LLRPCapabilities      *c1G2LLRPCapabilities
	Custom                    []custom
}

// UnmarshalBinary Message 11, GetReaderCapabilitiesResponse.
func (m *getReaderCapabilitiesResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamGetReaderCapabilitiesResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGeneralDeviceCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGeneralDeviceCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGeneralDeviceCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.GeneralDeviceCapabilities = new(generalDeviceCapabilities)
		if err := m.GeneralDeviceCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamLLRPCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamLLRPCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.LLRPCapabilities = new(llrpCapabilities)
		if err := m.LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRegulatoryCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRegulatoryCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRegulatoryCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.RegulatoryCapabilities = new(regulatoryCapabilities)
		if err := m.RegulatoryCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2LLRPCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2LLRPCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2LLRPCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.C1G2LLRPCapabilities = new(c1G2LLRPCapabilities)
		if err := m.C1G2LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.Custom = append(m.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// addROSpecs is Message 20, AddROSpecs.
type addROSpecs struct {
	ROSpec roSpec
}

// UnmarshalBinary Message 20, AddROSpecs.
func (m *addROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 89 {
		return errors.Errorf("ParamAddROSpecs requires at least 89 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpec {
		return errors.Errorf("expected ParamROSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.ROSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// addROSpecsResponse is Message 30, AddROSpecsResponse.
type addROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 30, AddROSpecsResponse.
func (m *addROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamAddROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// deleteROSpecs is Message 21, DeleteROSpecs.
type deleteROSpecs struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 21, DeleteROSpecs.
func (m *deleteROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamDeleteROSpecs requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.ROSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteROSpecs, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// deleteROSpecsResponse is Message 31, DeleteROSpecsResponse.
type deleteROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 31, DeleteROSpecsResponse.
func (m *deleteROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamDeleteROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// startROSpecs is Message 22, StartROSpecs.
type startROSpecs struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 22, StartROSpecs.
func (m *startROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamStartROSpecs requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.ROSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading StartROSpecs, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// startROSpecsResponse is Message 32, StartROSpecsResponse.
type startROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 32, StartROSpecsResponse.
func (m *startROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamStartROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// stopROSpecs is Message 23, StopROSpecs.
type stopROSpecs struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 23, StopROSpecs.
func (m *stopROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamStopROSpecs requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.ROSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading StopROSpecs, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// stopROSpecsResponse is Message 33, StopROSpecsResponse.
type stopROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 33, StopROSpecsResponse.
func (m *stopROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamStopROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// enableROSpecs is Message 24, EnableROSpecs.
type enableROSpecs struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 24, EnableROSpecs.
func (m *enableROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamEnableROSpecs requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.ROSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableROSpecs, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// enableROSpecsResponse is Message 34, EnableROSpecsResponse.
type enableROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 34, EnableROSpecsResponse.
func (m *enableROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamEnableROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// disableROSpecs is Message 25, DisableROSpecs.
type disableROSpecs struct {
	ROSpecID uint32
}

// UnmarshalBinary Message 25, DisableROSpecs.
func (m *disableROSpecs) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamDisableROSpecs requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.ROSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableROSpecs, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// disableROSpecsResponse is Message 35, DisableROSpecsResponse.
type disableROSpecsResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 35, DisableROSpecsResponse.
func (m *disableROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamDisableROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// getROSpecs is Message 26, GetROSpecs.
type getROSpecs struct{}

// UnmarshalBinary Message 26, GetROSpecs.
func (m *getROSpecs) UnmarshalBinary(data []byte) error {
	// GetROSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetROSpecs should be empty, but has %d bytes", len(data))
	}

	return nil
}

// getROSpecsResponse is Message 36, GetROSpecsResponse.
type getROSpecsResponse struct {
	LLRPStatus llrpStatus
	ROSpec     []roSpec
}

// UnmarshalBinary Message 36, GetROSpecsResponse.
func (m *getROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamGetROSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// ROSpec is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamROSpec {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamROSpec {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamROSpec says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp roSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.ROSpec = append(m.ROSpec, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// addAccessSpec is Message 40, AddAccessSpec.
type addAccessSpec struct {
	AccessSpec accessSpec
}

// UnmarshalBinary Message 40, AddAccessSpec.
func (m *addAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 42 {
		return errors.Errorf("ParamAddAccessSpec requires at least 42 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpec {
		return errors.Errorf("expected ParamAccessSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.AccessSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// addAccessSpecResponse is Message 50, AddAccessSpecResponse.
type addAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 50, AddAccessSpecResponse.
func (m *addAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamAddAccessSpecResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// deleteAccessSpec is Message 41, DeleteAccessSpec.
type deleteAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 41, DeleteAccessSpec.
func (m *deleteAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamDeleteAccessSpec requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.AccessSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading DeleteAccessSpec, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// deleteAccessSpecResponse is Message 51, DeleteAccessSpecResponse.
type deleteAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 51, DeleteAccessSpecResponse.
func (m *deleteAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamDeleteAccessSpecResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// enableAccessSpec is Message 42, EnableAccessSpec.
type enableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 42, EnableAccessSpec.
func (m *enableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamEnableAccessSpec requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.AccessSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading EnableAccessSpec, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// enableAccessSpecResponse is Message 52, EnableAccessSpecResponse.
type enableAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 52, EnableAccessSpecResponse.
func (m *enableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamEnableAccessSpecResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// disableAccessSpec is Message 43, DisableAccessSpec.
type disableAccessSpec struct {
	AccessSpecID uint32
}

// UnmarshalBinary Message 43, DisableAccessSpec.
func (m *disableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamDisableAccessSpec requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	m.AccessSpecID = binary.BigEndian.Uint32(data)
	if len(data) > 0 {
		return errors.Errorf("finished reading DisableAccessSpec, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// disableAccessSpecResponse is Message 53, DisableAccessSpecResponse.
type disableAccessSpecResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 53, DisableAccessSpecResponse.
func (m *disableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamDisableAccessSpecResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// getAccessSpecs is Message 44, GetAccessSpecs.
type getAccessSpecs struct{}

// UnmarshalBinary Message 44, GetAccessSpecs.
func (m *getAccessSpecs) UnmarshalBinary(data []byte) error {
	// GetAccessSpecs is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetAccessSpecs should be empty, but has %d bytes", len(data))
	}

	return nil
}

// getAccessSpecsResponse is Message 54, GetAccessSpecsResponse.
type getAccessSpecsResponse struct {
	LLRPStatus llrpStatus
	AccessSpec []accessSpec
}

// UnmarshalBinary Message 54, GetAccessSpecsResponse.
func (m *getAccessSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamGetAccessSpecsResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// AccessSpec is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessSpec {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAccessSpec {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAccessSpec says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp accessSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.AccessSpec = append(m.AccessSpec, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// clientRequestOp is Message 45, ClientRequestOp.
type clientRequestOp struct {
	TagReportData tagReportData
}

// UnmarshalBinary Message 45, ClientRequestOp.
func (m *clientRequestOp) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ParamClientRequestOp requires at least 10 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportData {
		return errors.Errorf("expected ParamTagReportData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportData says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.TagReportData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// clientRequestOpResponse is Message 55, ClientRequestOpResponse.
type clientRequestOpResponse struct {
	ClientRequestResponse clientRequestResponse
}

// UnmarshalBinary Message 55, ClientRequestOpResponse.
func (m *clientRequestOpResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return errors.Errorf("ParamClientRequestOpResponse requires at least 14 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamClientRequestResponse {
		return errors.Errorf("expected ParamClientRequestResponse, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamClientRequestResponse says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.ClientRequestResponse.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// getReport is Message 60, GetReport.
type getReport struct{}

// UnmarshalBinary Message 60, GetReport.
func (m *getReport) UnmarshalBinary(data []byte) error {
	// GetReport is a header-only message
	if len(data) > 0 {
		return errors.Errorf("GetReport should be empty, but has %d bytes", len(data))
	}

	return nil
}

// roAccessReport is Message 61, ROAccessReport.
type roAccessReport struct {
	TagReportData      []tagReportData
	RFSurveyReportData []rfSurveyReportData
	Custom             []custom
}

// UnmarshalBinary Message 61, ROAccessReport.
func (m *roAccessReport) UnmarshalBinary(data []byte) error {
	// ROAccessReport is a header-only message
	if len(data) > 0 {
		return errors.Errorf("ROAccessReport should be empty, but has %d bytes", len(data))
	}

	return nil
}

// keepAlive is Message 62, KeepAlive.
type keepAlive struct{}

// UnmarshalBinary Message 62, KeepAlive.
func (m *keepAlive) UnmarshalBinary(data []byte) error {
	// KeepAlive is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAlive should be empty, but has %d bytes", len(data))
	}

	return nil
}

// keepAliveACK is Message 72, KeepAliveACK.
type keepAliveACK struct{}

// UnmarshalBinary Message 72, KeepAliveACK.
func (m *keepAliveACK) UnmarshalBinary(data []byte) error {
	// KeepAliveACK is a header-only message
	if len(data) > 0 {
		return errors.Errorf("KeepAliveACK should be empty, but has %d bytes", len(data))
	}

	return nil
}

// readerEventNotification is Message 63, ReaderEventNotification.
type readerEventNotification struct {
	ReaderEventNotificationData readerEventNotificationData
}

// UnmarshalBinary Message 63, ReaderEventNotification.
func (m *readerEventNotification) UnmarshalBinary(data []byte) error {
	if len(data) < 16 {
		return errors.Errorf("ParamReaderEventNotification requires at least 16 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamReaderEventNotificationData {
		return errors.Errorf("expected ParamReaderEventNotificationData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationData says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.ReaderEventNotificationData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// enableEventsAndReports is Message 64, EnableEventsAndReports.
type enableEventsAndReports struct{}

// UnmarshalBinary Message 64, EnableEventsAndReports.
func (m *enableEventsAndReports) UnmarshalBinary(data []byte) error {
	// EnableEventsAndReports is a header-only message
	if len(data) > 0 {
		return errors.Errorf("EnableEventsAndReports should be empty, but has %d bytes", len(data))
	}

	return nil
}

// errorMessage is Message 100, ErrorMessage.
type errorMessage struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 100, ErrorMessage.
func (m *errorMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamErrorMessage requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// getReaderConfig is Message 2, GetReaderConfig.
type getReaderConfig struct {
	AntennaID                 uint16
	ReaderConfigRequestedData ReaderConfigRequestedDataType
	GPIPortNum                uint16
	GPOPortNum                uint16
	Custom                    []custom
}

// UnmarshalBinary Message 2, GetReaderConfig.
func (m *getReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("ParamGetReaderConfig requires at least 7 bytes "+
			"but only %d are available", len(data))
	}

	m.AntennaID = binary.BigEndian.Uint16(data)
	m.ReaderConfigRequestedData = ReaderConfigRequestedDataType(data[2])
	m.GPIPortNum = binary.BigEndian.Uint16(data[3:])
	m.GPOPortNum = binary.BigEndian.Uint16(data[5:])
	data = data[7:]

	// sub-parameters

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.Custom = append(m.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// getReaderConfigResponse is Message 12, GetReaderConfigResponse.
type getReaderConfigResponse struct {
	LLRPStatus                  llrpStatus
	Identification              *identification
	AntennaProperties           []antennaProperties
	AntennaConfiguration        []antennaConfiguration
	ReaderEventNotificationSpec *readerEventNotificationSpec
	ROReportSpec                *roReportSpec
	AccessReportSpec            *accessReportSpec
	LLRPConfigurationStateValue *llrpConfigurationStateValue
	KeepAliveSpec               *keepAliveSpec
	GPIPortCurrentState         []gpiPortCurrentState
	GPOWriteData                []gpoWriteData
	EventsAndReports            *eventsAndReports
	Custom                      []custom
}

// UnmarshalBinary Message 12, GetReaderConfigResponse.
func (m *getReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamGetReaderConfigResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamIdentification needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamIdentification {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamIdentification says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.Identification = new(identification)
		if err := m.Identification.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaProperties needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaProperties {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAntennaProperties {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAntennaProperties says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp antennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.AntennaProperties = append(m.AntennaProperties, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaConfiguration needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaConfiguration {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAntennaConfiguration {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAntennaConfiguration says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.AntennaConfiguration = append(m.AntennaConfiguration, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamReaderEventNotificationSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderEventNotificationSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.ReaderEventNotificationSpec = new(readerEventNotificationSpec)
		if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamROReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.ROReportSpec = new(roReportSpec)
		if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.AccessReportSpec = new(accessReportSpec)
		*m.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamLLRPConfigurationStateValue needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamLLRPConfigurationStateValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPConfigurationStateValue says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.LLRPConfigurationStateValue = new(llrpConfigurationStateValue)
		*m.LLRPConfigurationStateValue = llrpConfigurationStateValue(binary.BigEndian.Uint32(data[4:]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamKeepAliveSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamKeepAliveSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamKeepAliveSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.KeepAliveSpec = new(keepAliveSpec)
		if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPIPortCurrentState needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPIPortCurrentState {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamGPIPortCurrentState {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamGPIPortCurrentState says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp gpiPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.GPIPortCurrentState = append(m.GPIPortCurrentState, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPOWriteData needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPOWriteData {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamGPOWriteData {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamGPOWriteData says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp gpoWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.GPOWriteData = append(m.GPOWriteData, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamEventsAndReports needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.EventsAndReports = new(eventsAndReports)
		*m.EventsAndReports = eventsAndReports(data[4]&0x80 != 0)
		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.Custom = append(m.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// setReaderConfig is Message 3, SetReaderConfig.
type setReaderConfig struct {
	ResetToFactoryDefaults      bool
	ReaderEventNotificationSpec *readerEventNotificationSpec
	AntennaProperties           []antennaProperties
	AntennaConfiguration        []antennaConfiguration
	ROReportSpec                *roReportSpec
	AccessReportSpec            *accessReportSpec
	KeepAliveSpec               *keepAliveSpec
	GPOWriteData                []gpoWriteData
	GPIPortCurrentState         []gpiPortCurrentState
	EventsAndReports            *eventsAndReports
	Custom                      []custom
}

// UnmarshalBinary Message 3, SetReaderConfig.
func (m *setReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamSetReaderConfig requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	m.ResetToFactoryDefaults = data[0]&0x80 != 0
	data = data[1:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamReaderEventNotificationSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderEventNotificationSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderEventNotificationSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.ReaderEventNotificationSpec = new(readerEventNotificationSpec)
		if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaProperties needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaProperties {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAntennaProperties {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAntennaProperties says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp antennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.AntennaProperties = append(m.AntennaProperties, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaConfiguration needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaConfiguration {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAntennaConfiguration {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAntennaConfiguration says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.AntennaConfiguration = append(m.AntennaConfiguration, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamROReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.ROReportSpec = new(roReportSpec)
		if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.AccessReportSpec = new(accessReportSpec)
		*m.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamKeepAliveSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamKeepAliveSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamKeepAliveSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.KeepAliveSpec = new(keepAliveSpec)
		if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPOWriteData needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPOWriteData {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamGPOWriteData {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamGPOWriteData says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp gpoWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.GPOWriteData = append(m.GPOWriteData, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPIPortCurrentState needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPIPortCurrentState {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamGPIPortCurrentState {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamGPIPortCurrentState says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp gpiPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.GPIPortCurrentState = append(m.GPIPortCurrentState, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamEventsAndReports needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEventsAndReports says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		m.EventsAndReports = new(eventsAndReports)
		*m.EventsAndReports = eventsAndReports(data[4]&0x80 != 0)
		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			m.Custom = append(m.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// setReaderConfigResponse is Message 13, SetReaderConfigResponse.
type setReaderConfigResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 13, SetReaderConfigResponse.
func (m *setReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamSetReaderConfigResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// closeConnection is Message 14, CloseConnection.
type closeConnection struct{}

// UnmarshalBinary Message 14, CloseConnection.
func (m *closeConnection) UnmarshalBinary(data []byte) error {
	// CloseConnection is a header-only message
	if len(data) > 0 {
		return errors.Errorf("CloseConnection should be empty, but has %d bytes", len(data))
	}

	return nil
}

// closeConnectionResponse is Message 4, CloseConnectionResponse.
type closeConnectionResponse struct {
	LLRPStatus llrpStatus
}

// UnmarshalBinary Message 4, CloseConnectionResponse.
func (m *closeConnectionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamCloseConnectionResponse requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return errors.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLLRPStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// customMessage is Message 1023, CustomMessage.
type customMessage struct {
	VendorID       uint32
	MessageSubtype uint8
	VendorPayload  []byte
}

// UnmarshalBinary Message 1023, CustomMessage.
func (m *customMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamCustomMessage requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	m.VendorID = binary.BigEndian.Uint32(data)
	m.MessageSubtype = data[4]
	if len(data)-5 == 0 {
		return nil
	}

	m.VendorPayload = make([]byte, len(data)-5)
	copy(m.VendorPayload, data[5:])

	data = data[5:]
	return nil
}

// antennaID is Parameter 1, AntennaID.
type antennaID uint16

// UnmarshalBinary Parameter 1, AntennaID.
func (p *antennaID) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamAntennaID requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = antennaID(binary.BigEndian.Uint16(data))
	return nil
}

// firstSeenUTC is Parameter 2, FirstSeenUTC.
type firstSeenUTC microSecs64

// UnmarshalBinary Parameter 2, FirstSeenUTC.
func (p *firstSeenUTC) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamFirstSeenUTC requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = firstSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// firstSeenUptime is Parameter 3, FirstSeenUptime.
type firstSeenUptime microSecs64

// UnmarshalBinary Parameter 3, FirstSeenUptime.
func (p *firstSeenUptime) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamFirstSeenUptime requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = firstSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// lastSeenUTC is Parameter 4, LastSeenUTC.
type lastSeenUTC microSecs64

// UnmarshalBinary Parameter 4, LastSeenUTC.
func (p *lastSeenUTC) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamLastSeenUTC requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = lastSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// lastSeenUptime is Parameter 5, LastSeenUptime.
type lastSeenUptime microSecs64

// UnmarshalBinary Parameter 5, LastSeenUptime.
func (p *lastSeenUptime) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamLastSeenUptime requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = lastSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// peakRSSI is Parameter 6, PeakRSSI.
type peakRSSI dBm8

// UnmarshalBinary Parameter 6, PeakRSSI.
func (p *peakRSSI) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamPeakRSSI requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = peakRSSI(dBm8(data[0]))
	return nil
}

// channelIndex is Parameter 7, ChannelIndex.
type channelIndex uint16

// UnmarshalBinary Parameter 7, ChannelIndex.
func (p *channelIndex) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamChannelIndex requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = channelIndex(binary.BigEndian.Uint16(data))
	return nil
}

// tagSeenCount is Parameter 8, TagSeenCount.
type tagSeenCount uint16

// UnmarshalBinary Parameter 8, TagSeenCount.
func (p *tagSeenCount) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamTagSeenCount requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = tagSeenCount(binary.BigEndian.Uint16(data))
	return nil
}

// roSpecID is Parameter 9, ROSpecID.
type roSpecID uint32

// UnmarshalBinary Parameter 9, ROSpecID.
func (p *roSpecID) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamROSpecID requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	*p = roSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// inventoryParameterSpecID is Parameter 10, InventoryParameterSpecID.
type inventoryParameterSpecID uint16

// UnmarshalBinary Parameter 10, InventoryParameterSpecID.
func (p *inventoryParameterSpecID) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamInventoryParameterSpecID requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = inventoryParameterSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2CRC is Parameter 11, C1G2CRC.
type c1G2CRC uint16

// UnmarshalBinary Parameter 11, C1G2CRC.
func (p *c1G2CRC) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2CRC requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = c1G2CRC(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2PC is Parameter 12, C1G2PC.
type c1G2PC uint16

// UnmarshalBinary Parameter 12, C1G2PC.
func (p *c1G2PC) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2PC requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = c1G2PC(binary.BigEndian.Uint16(data))
	return nil
}

// epc96 is Parameter 13, EPC96.
type epc96 struct {
	EPC []byte
}

// UnmarshalBinary Parameter 13, EPC96.
func (p *epc96) UnmarshalBinary(data []byte) error {
	if len(data) < 12 {
		return errors.Errorf("ParamEPC96 requires at least 12 bytes "+
			"but only %d are available", len(data))
	}

	p.EPC = make([]byte, 12)
	copy(p.EPC, data)
	if len(data) > 0 {
		return errors.Errorf("finished reading EPC96, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// specIndex is Parameter 14, SpecIndex.
type specIndex uint16

// UnmarshalBinary Parameter 14, SpecIndex.
func (p *specIndex) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamSpecIndex requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = specIndex(binary.BigEndian.Uint16(data))
	return nil
}

// clientRequestOpSpecResult is Parameter 15, ClientRequestOpSpecResult.
type clientRequestOpSpecResult uint16

// UnmarshalBinary Parameter 15, ClientRequestOpSpecResult.
func (p *clientRequestOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamClientRequestOpSpecResult requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = clientRequestOpSpecResult(binary.BigEndian.Uint16(data))
	return nil
}

// accessSpecID is Parameter 16, AccessSpecID.
type accessSpecID uint32

// UnmarshalBinary Parameter 16, AccessSpecID.
func (p *accessSpecID) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamAccessSpecID requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	*p = accessSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// opSpecID is Parameter 17, OpSpecID.
type opSpecID uint16

// UnmarshalBinary Parameter 17, OpSpecID.
func (p *opSpecID) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamOpSpecID requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = opSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2SingulationDetails is Parameter 18, C1G2SingulationDetails.
type c1G2SingulationDetails struct {
	NumCollisionSlots uint16
	NumEmptySlots     uint16
}

// UnmarshalBinary Parameter 18, C1G2SingulationDetails.
func (p *c1G2SingulationDetails) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamC1G2SingulationDetails requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.NumCollisionSlots = binary.BigEndian.Uint16(data)
	p.NumEmptySlots = binary.BigEndian.Uint16(data[2:])
	return nil
}

// c1G2XPCW1 is Parameter 19, C1G2XPCW1.
type c1G2XPCW1 uint16

// UnmarshalBinary Parameter 19, C1G2XPCW1.
func (p *c1G2XPCW1) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2XPCW1 requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = c1G2XPCW1(binary.BigEndian.Uint16(data))
	return nil
}

// c1G2XPCW2 is Parameter 20, C1G2XPCW2.
type c1G2XPCW2 uint16

// UnmarshalBinary Parameter 20, C1G2XPCW2.
func (p *c1G2XPCW2) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2XPCW2 requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = c1G2XPCW2(binary.BigEndian.Uint16(data))
	return nil
}

// utcTimestamp is Parameter 128, UTCTimestamp.
type utcTimestamp microSecs64

// UnmarshalBinary Parameter 128, UTCTimestamp.
func (p *utcTimestamp) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamUTCTimestamp requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = utcTimestamp(binary.BigEndian.Uint64(data))
	return nil
}

// uptime is Parameter 129, Uptime.
type uptime microSecs64

// UnmarshalBinary Parameter 129, Uptime.
func (p *uptime) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamUptime requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	*p = uptime(binary.BigEndian.Uint64(data))
	return nil
}

// generalDeviceCapabilities is Parameter 137, GeneralDeviceCapabilities.
type generalDeviceCapabilities struct {
	MaxSupportedAntennas               uint16
	GeneralCapabilityFlags             GeneralCapabilityFlags
	DeviceManufacturerName             uint32
	ModelName                          uint32
	ReaderFirmwareVersion              string
	ReceiveSensitivityTableEntries     []receiveSensitivityTableEntry
	PerAntennaReceiveSensitivityRanges []perAntennaReceiveSensitivityRange
	GPIOCapabilities                   gpioCapabilities
	PerAntennaAirProtocols             []perAntennaAirProtocol
	MaximumReceiveSensitivity          *maximumReceiveSensitivity
}

// UnmarshalBinary Parameter 137, GeneralDeviceCapabilities.
func (p *generalDeviceCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 37 {
		return errors.Errorf("ParamGeneralDeviceCapabilities requires at least 37 bytes "+
			"but only %d are available", len(data))
	}

	p.MaxSupportedAntennas = binary.BigEndian.Uint16(data)
	p.GeneralCapabilityFlags = GeneralCapabilityFlags(data[2])
	p.DeviceManufacturerName = binary.BigEndian.Uint32(data[3:])
	p.ModelName = binary.BigEndian.Uint32(data[7:])
	if arrLen := int(binary.BigEndian.Uint16(data[11:])); int64(arrLen) > int64(len(data[13:])) {
		return errors.Errorf("ReaderFirmwareVersion (string) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[13:]))
	} else if arrLen != 0 {
		p.ReaderFirmwareVersion = string(data[13 : arrLen+13])
		data = data[arrLen+13:]
	}

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamReceiveSensitivityTableEntry needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamReceiveSensitivityTableEntry {
		return errors.Errorf("expected ParamReceiveSensitivityTableEntry, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamReceiveSensitivityTableEntry {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamReceiveSensitivityTableEntry says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp receiveSensitivityTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.ReceiveSensitivityTableEntries = append(p.ReceiveSensitivityTableEntries, tmp)
			data = data[subLen:]
		}

	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamPerAntennaReceiveSensitivityRange needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamPerAntennaReceiveSensitivityRange {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamPerAntennaReceiveSensitivityRange {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamPerAntennaReceiveSensitivityRange says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp perAntennaReceiveSensitivityRange
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.PerAntennaReceiveSensitivityRanges = append(p.PerAntennaReceiveSensitivityRanges, tmp)
			data = data[subLen:]
		}

	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPIOCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamGPIOCapabilities {
		return errors.Errorf("expected ParamGPIOCapabilities, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPIOCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.GPIOCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamPerAntennaAirProtocol needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamPerAntennaAirProtocol {
		return errors.Errorf("expected ParamPerAntennaAirProtocol, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamPerAntennaAirProtocol {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamPerAntennaAirProtocol says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp perAntennaAirProtocol
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.PerAntennaAirProtocols = append(p.PerAntennaAirProtocols, tmp)
			data = data[subLen:]
		}

	}

	// MaximumReceiveSensitivity is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamMaximumReceiveSensitivity needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamMaximumReceiveSensitivity {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamMaximumReceiveSensitivity says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.MaximumReceiveSensitivity = new(maximumReceiveSensitivity)
		*p.MaximumReceiveSensitivity = maximumReceiveSensitivity(dBm16(binary.BigEndian.Uint16(data[4:])))
		data = data[subLen:]
	}

	return nil
}

// receiveSensitivityTableEntry is Parameter 139, ReceiveSensitivityTableEntry.
type receiveSensitivityTableEntry struct {
	TableIndex uint16
	// ReceiveSensitivity is relative the maximum.
	ReceiveSensitivity dB
}

// UnmarshalBinary Parameter 139, ReceiveSensitivityTableEntry.
func (p *receiveSensitivityTableEntry) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamReceiveSensitivityTableEntry requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.TableIndex = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivity = binary.BigEndian.Uint16(data[2:])
	return nil
}

// perAntennaAirProtocol is Parameter 140, PerAntennaAirProtocol.
type perAntennaAirProtocol struct {
	AntennaID      uint16
	AirProtocolIDs []AirProtocolIDType
}

// UnmarshalBinary Parameter 140, PerAntennaAirProtocol.
func (p *perAntennaAirProtocol) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamPerAntennaAirProtocol requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	p.AntennaID = binary.BigEndian.Uint16(data)
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen) > int64(len(data[4:])) {
		return errors.Errorf("AirProtocolIDs ([]AirProtocolIDType) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.AirProtocolIDs = make([]AirProtocolIDType, arrLen)
		for i := 0; i < arrLen; i++ {
			p.AirProtocolIDs[i] = AirProtocolIDType(data[i])
		}

		data = data[arrLen+4:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading PerAntennaAirProtocol, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// gpioCapabilities is Parameter 141, GPIOCapabilities.
type gpioCapabilities struct {
	NumGPIs uint16
	NumGPOs uint16
}

// UnmarshalBinary Parameter 141, GPIOCapabilities.
func (p *gpioCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamGPIOCapabilities requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.NumGPIs = binary.BigEndian.Uint16(data)
	p.NumGPOs = binary.BigEndian.Uint16(data[2:])
	return nil
}

// llrpCapabilities is Parameter 142, LLRPCapabilities.
type llrpCapabilities struct {
	LLRPCapabilitiesFlags                  LLRPCapabilitiesFlags
	MaxPriorityLevelSupported              uint8
	ClientRequestedOpSpecTimeout           uint16
	MaxNumROSpecs                          uint32
	MaxNumSpecsPerROSpec                   uint32
	MaxNumInventoryParameterSpecsPerAISpec uint32
	MaxNumAccessSpecs                      uint32
	MaxNumOpSpecsPerAccessSpec             uint32
}

// UnmarshalBinary Parameter 142, LLRPCapabilities.
func (p *llrpCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) != 24 {
		return errors.Errorf("ParamLLRPCapabilities requires exactly 24 bytes "+
			"but received %d", len(data))
	}

	p.LLRPCapabilitiesFlags = LLRPCapabilitiesFlags(data[0])
	p.MaxPriorityLevelSupported = data[1]
	p.ClientRequestedOpSpecTimeout = binary.BigEndian.Uint16(data[2:])
	p.MaxNumROSpecs = binary.BigEndian.Uint32(data[4:])
	p.MaxNumSpecsPerROSpec = binary.BigEndian.Uint32(data[8:])
	p.MaxNumInventoryParameterSpecsPerAISpec = binary.BigEndian.Uint32(data[12:])
	p.MaxNumAccessSpecs = binary.BigEndian.Uint32(data[16:])
	p.MaxNumOpSpecsPerAccessSpec = binary.BigEndian.Uint32(data[20:])
	return nil
}

// regulatoryCapabilities is Parameter 143, RegulatoryCapabilities.
type regulatoryCapabilities struct {
	CountryCode            CountryCodeType
	CommunicationsStandard uint16
	UHFBandCapabilities    *uhfBandCapabilities
	Custom                 []custom
}

// UnmarshalBinary Parameter 143, RegulatoryCapabilities.
func (p *regulatoryCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamRegulatoryCapabilities requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	p.CountryCode = CountryCodeType(binary.BigEndian.Uint16(data))
	p.CommunicationsStandard = binary.BigEndian.Uint16(data[2:])
	data = data[4:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUHFBandCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUHFBandCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUHFBandCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.UHFBandCapabilities = new(uhfBandCapabilities)
		if err := p.UHFBandCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// uhfBandCapabilities is Parameter 144, UHFBandCapabilities.
type uhfBandCapabilities struct {
	TransmitPowerLevelTableEntry  []transmitPowerLevelTableEntry
	FrequencyInformation          []frequencyInformation
	UHFC1G2RFModeTable            []uhfc1G2RFModeTable
	RFSurveyFrequencyCapabilities *rfSurveyFrequencyCapabilities
}

// UnmarshalBinary Parameter 144, UHFBandCapabilities.
func (p *uhfBandCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 49 {
		return errors.Errorf("ParamUHFBandCapabilities requires at least 49 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTransmitPowerLevelTableEntry {
		return errors.Errorf("expected ParamTransmitPowerLevelTableEntry, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamTransmitPowerLevelTableEntry {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamTransmitPowerLevelTableEntry says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp transmitPowerLevelTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.TransmitPowerLevelTableEntry = append(p.TransmitPowerLevelTableEntry, tmp)
			data = data[subLen:]
		}

	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFrequencyInformation needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamFrequencyInformation {
		return errors.Errorf("expected ParamFrequencyInformation, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamFrequencyInformation {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamFrequencyInformation says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp frequencyInformation
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.FrequencyInformation = append(p.FrequencyInformation, tmp)
			data = data[subLen:]
		}

	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUHFC1G2RFModeTable needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamUHFC1G2RFModeTable {
		return errors.Errorf("expected ParamUHFC1G2RFModeTable, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamUHFC1G2RFModeTable {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUHFC1G2RFModeTable says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp uhfc1G2RFModeTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.UHFC1G2RFModeTable = append(p.UHFC1G2RFModeTable, tmp)
			data = data[subLen:]
		}

	}

	// RFSurveyFrequencyCapabilities is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFSurveyFrequencyCapabilities needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFSurveyFrequencyCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveyFrequencyCapabilities says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.RFSurveyFrequencyCapabilities = new(rfSurveyFrequencyCapabilities)
		if err := p.RFSurveyFrequencyCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// transmitPowerLevelTableEntry is Parameter 145, TransmitPowerLevelTableEntry.
type transmitPowerLevelTableEntry struct {
	Index              uint16
	TransmitPowerValue dBmX100
}

// UnmarshalBinary Parameter 145, TransmitPowerLevelTableEntry.
func (p *transmitPowerLevelTableEntry) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamTransmitPowerLevelTableEntry requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.Index = binary.BigEndian.Uint16(data)
	p.TransmitPowerValue = binary.BigEndian.Uint16(data[2:])
	return nil
}

// frequencyInformation is Parameter 146, FrequencyInformation.
type frequencyInformation struct {
	HoppingFlags        HoppingFlags
	FrequencyHopTable   []frequencyHopTable
	FixedFrequencyTable *fixedFrequencyTable
}

// UnmarshalBinary Parameter 146, FrequencyInformation.
func (p *frequencyInformation) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamFrequencyInformation requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	p.HoppingFlags = HoppingFlags(data[0])
	data = data[1:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFrequencyHopTable needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFrequencyHopTable {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamFrequencyHopTable {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamFrequencyHopTable says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp frequencyHopTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.FrequencyHopTable = append(p.FrequencyHopTable, tmp)
			data = data[subLen:]
		}

	}

	// FixedFrequencyTable is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFixedFrequencyTable needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFixedFrequencyTable {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFixedFrequencyTable says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.FixedFrequencyTable = new(fixedFrequencyTable)
		if err := p.FixedFrequencyTable.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// frequencyHopTable is Parameter 147, FrequencyHopTable.
type frequencyHopTable struct {
	HopTableID  uint8
	Frequencies []kHz
}

// UnmarshalBinary Parameter 147, FrequencyHopTable.
func (p *frequencyHopTable) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamFrequencyHopTable requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	p.HopTableID = data[0]
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen)*4 > int64(len(data[4:])) {
		return errors.Errorf("Frequencies ([]kHz) declares it has %d*4 bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]kHz, arrLen)
		for i, pos := 0, 4; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}

		data = data[arrLen*4+4:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading FrequencyHopTable, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// fixedFrequencyTable is Parameter 148, FixedFrequencyTable.
type fixedFrequencyTable struct {
	Frequencies []kHz
}

// UnmarshalBinary Parameter 148, FixedFrequencyTable.
func (p *fixedFrequencyTable) UnmarshalBinary(data []byte) error {
	if len(data) < 2 {
		return errors.Errorf("ParamFixedFrequencyTable requires at least 2 bytes "+
			"but only %d are available", len(data))
	}

	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*4 > int64(len(data[2:])) {
		return errors.Errorf("Frequencies ([]kHz) declares it has %d*4 bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]kHz, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}

		data = data[arrLen*4+2:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading FixedFrequencyTable, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// perAntennaReceiveSensitivityRange is Parameter 149, PerAntennaReceiveSensitivityRange.
type perAntennaReceiveSensitivityRange struct {
	AntennaID                  uint16
	ReceiveSensitivityIndexMin uint16
	ReceiveSensitivityIndexMax uint16
}

// UnmarshalBinary Parameter 149, PerAntennaReceiveSensitivityRange.
func (p *perAntennaReceiveSensitivityRange) UnmarshalBinary(data []byte) error {
	if len(data) != 6 {
		return errors.Errorf("ParamPerAntennaReceiveSensitivityRange requires exactly 6 bytes "+
			"but received %d", len(data))
	}

	p.AntennaID = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivityIndexMin = binary.BigEndian.Uint16(data[2:])
	p.ReceiveSensitivityIndexMax = binary.BigEndian.Uint16(data[4:])
	return nil
}

// roSpec is Parameter 177, ROSpec.
type roSpec struct {
	ROSpecID           uint32
	Priority           uint8
	ROSpecCurrentState ROSpecCurrentStateType
	ROBoundarySpec     roBoundarySpec
	AISpec             aiSpec
	RFSurveySpec       rfSurveySpec
	Custom             custom
	LoopSpec           *loopSpec
	ROReportSpec       *roReportSpec
}

// UnmarshalBinary Parameter 177, ROSpec.
func (p *roSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 85 {
		return errors.Errorf("ParamROSpec requires at least 85 bytes "+
			"but only %d are available", len(data))
	}

	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.Priority = data[4]
	p.ROSpecCurrentState = ROSpecCurrentStateType(data[5])
	data = data[6:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamROBoundarySpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROBoundarySpec {
		return errors.Errorf("expected ParamROBoundarySpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROBoundarySpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.ROBoundarySpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAISpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAISpec {
		return errors.Errorf("expected ParamAISpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAISpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.AISpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFSurveySpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamRFSurveySpec {
		return errors.Errorf("expected ParamRFSurveySpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveySpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.RFSurveySpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamCustom {
		return errors.Errorf("expected ParamCustom, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamCustom says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamLoopSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamLoopSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamLoopSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.LoopSpec = new(loopSpec)
		*p.LoopSpec = loopSpec(binary.BigEndian.Uint32(data[4:]))
		data = data[subLen:]
	}

	// ROReportSpec is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamROReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ROReportSpec = new(roReportSpec)
		if err := p.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// roBoundarySpec is Parameter 178, ROBoundarySpec.
type roBoundarySpec struct {
	ROSpecStartTrigger roSpecStartTrigger
	ROSpecStopTrigger  roSpecStopTrigger
}

// UnmarshalBinary Parameter 178, ROBoundarySpec.
func (p *roBoundarySpec) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return errors.Errorf("ParamROBoundarySpec requires at least 14 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStartTrigger {
		return errors.Errorf("expected ParamROSpecStartTrigger, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStartTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.ROSpecStartTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROSpecStopTrigger needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStopTrigger {
		return errors.Errorf("expected ParamROSpecStopTrigger, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecStopTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.ROSpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// roSpecStartTrigger is Parameter 179, ROSpecStartTrigger.
type roSpecStartTrigger struct {
	ROSpecStartTriggerType ROSpecStartTriggerType
	PeriodicTriggerValue   *periodicTriggerValue
	GPITriggerValue        *gpiTriggerValue
}

// UnmarshalBinary Parameter 179, ROSpecStartTrigger.
func (p *roSpecStartTrigger) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamROSpecStartTrigger requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	p.ROSpecStartTriggerType = ROSpecStartTriggerType(data[0])
	data = data[1:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamPeriodicTriggerValue needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamPeriodicTriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamPeriodicTriggerValue says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.PeriodicTriggerValue = new(periodicTriggerValue)
		if err := p.PeriodicTriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// GPITriggerValue is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPITriggerValue needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPITriggerValue says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.GPITriggerValue = new(gpiTriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// periodicTriggerValue is Parameter 180, PeriodicTriggerValue.
type periodicTriggerValue struct {
	Offset       milliSecs32
	Period       milliSecs32
	UTCTimestamp *utcTimestamp
}

// UnmarshalBinary Parameter 180, PeriodicTriggerValue.
func (p *periodicTriggerValue) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamPeriodicTriggerValue requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	p.Offset = binary.BigEndian.Uint32(data)
	p.Period = binary.BigEndian.Uint32(data[4:])
	data = data[8:]

	// sub-parameters

	// UTCTimestamp is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUTCTimestamp needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUTCTimestamp {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUTCTimestamp says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.UTCTimestamp = new(utcTimestamp)
		*p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}

	return nil
}

// gpiTriggerValue is Parameter 181, GPITriggerValue.
type gpiTriggerValue struct {
	GPIPortNum      uint16
	GPITriggerFlags GPITriggerFlags
	Timeout         milliSecs32
}

// UnmarshalBinary Parameter 181, GPITriggerValue.
func (p *gpiTriggerValue) UnmarshalBinary(data []byte) error {
	if len(data) != 7 {
		return errors.Errorf("ParamGPITriggerValue requires exactly 7 bytes "+
			"but received %d", len(data))
	}

	p.GPIPortNum = binary.BigEndian.Uint16(data)
	p.GPITriggerFlags = GPITriggerFlags(data[2])
	p.Timeout = binary.BigEndian.Uint32(data[3:])
	return nil
}

// roSpecStopTrigger is Parameter 182, ROSpecStopTrigger.
type roSpecStopTrigger struct {
	ROSpecStopTriggerType ROSpecStopTriggerType
	DurationTriggerValue  milliSecs32
	GPITriggerValue       *gpiTriggerValue
}

// UnmarshalBinary Parameter 182, ROSpecStopTrigger.
func (p *roSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamROSpecStopTrigger requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	p.ROSpecStopTriggerType = ROSpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]

	// sub-parameters

	// GPITriggerValue is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPITriggerValue needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPITriggerValue says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.GPITriggerValue = new(gpiTriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// aiSpec is Parameter 183, AISpec.
type aiSpec struct {
	AntennaID              []uint16
	AISpecStopTrigger      aiSpecStopTrigger
	InventoryParameterSpec []inventoryParameterSpec
	Custom                 []custom
}

// UnmarshalBinary Parameter 183, AISpec.
func (p *aiSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 18 {
		return errors.Errorf("ParamAISpec requires at least 18 bytes "+
			"but only %d are available", len(data))
	}

	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*2 > int64(len(data[2:])) {
		return errors.Errorf("AntennaID ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.AntennaID = make([]uint16, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+2 {
			p.AntennaID[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+2:]
	}

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamAISpecStopTrigger needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAISpecStopTrigger {
		return errors.Errorf("expected ParamAISpecStopTrigger, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAISpecStopTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.AISpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamInventoryParameterSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamInventoryParameterSpec {
		return errors.Errorf("expected ParamInventoryParameterSpec, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamInventoryParameterSpec {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamInventoryParameterSpec says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp inventoryParameterSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.InventoryParameterSpec = append(p.InventoryParameterSpec, tmp)
			data = data[subLen:]
		}

	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// aiSpecStopTrigger is Parameter 184, AISpecStopTrigger.
type aiSpecStopTrigger struct {
	AISpecStopTriggerType AISpecStopTriggerType
	DurationTriggerValue  milliSecs32
	GPITriggerValue       *gpiTriggerValue
	TagObservationTrigger *tagObservationTrigger
}

// UnmarshalBinary Parameter 184, AISpecStopTrigger.
func (p *aiSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamAISpecStopTrigger requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	p.AISpecStopTriggerType = AISpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPITriggerValue needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPITriggerValue says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.GPITriggerValue = new(gpiTriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// TagObservationTrigger is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamTagObservationTrigger needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamTagObservationTrigger {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagObservationTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.TagObservationTrigger = new(tagObservationTrigger)
		if err := p.TagObservationTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// tagObservationTrigger is Parameter 185, TagObservationTrigger.
type tagObservationTrigger struct {
	TagObservationTriggerType TagObservationTriggerType
	NumberofTags              uint16
	NumberofAttempts          uint16
	T                         milliSecs16
	Timeout                   milliSecs32
}

// UnmarshalBinary Parameter 185, TagObservationTrigger.
func (p *tagObservationTrigger) UnmarshalBinary(data []byte) error {
	if len(data) != 12 {
		return errors.Errorf("ParamTagObservationTrigger requires exactly 12 bytes "+
			"but received %d", len(data))
	}

	p.TagObservationTriggerType = TagObservationTriggerType(data[0])
	p.NumberofTags = binary.BigEndian.Uint16(data[2:])
	p.NumberofAttempts = binary.BigEndian.Uint16(data[4:])
	p.T = binary.BigEndian.Uint16(data[6:])
	p.Timeout = binary.BigEndian.Uint32(data[8:])
	return nil
}

// inventoryParameterSpec is Parameter 186, InventoryParameterSpec.
type inventoryParameterSpec struct {
	InventoryParameterSpecID uint16
	AirProtocolID            AirProtocolIDType
	AntennaConfiguration     []antennaConfiguration
	Custom                   []custom
}

// UnmarshalBinary Parameter 186, InventoryParameterSpec.
func (p *inventoryParameterSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 3 {
		return errors.Errorf("ParamInventoryParameterSpec requires at least 3 bytes "+
			"but only %d are available", len(data))
	}

	p.InventoryParameterSpecID = binary.BigEndian.Uint16(data)
	p.AirProtocolID = AirProtocolIDType(data[2])
	data = data[3:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaConfiguration needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaConfiguration {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamAntennaConfiguration {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamAntennaConfiguration says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp antennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.AntennaConfiguration = append(p.AntennaConfiguration, tmp)
			data = data[subLen:]
		}

	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// rfSurveySpec is Parameter 187, RFSurveySpec.
type rfSurveySpec struct {
	AntennaID               uint16
	StartFrequency          kHz
	EndFrequency            kHz
	RFSurveySpecStopTrigger rfSurveySpecStopTrigger
	Custom                  []custom
}

// UnmarshalBinary Parameter 187, RFSurveySpec.
func (p *rfSurveySpec) UnmarshalBinary(data []byte) error {
	if len(data) < 23 {
		return errors.Errorf("ParamRFSurveySpec requires at least 23 bytes "+
			"but only %d are available", len(data))
	}

	p.AntennaID = binary.BigEndian.Uint16(data)
	p.StartFrequency = binary.BigEndian.Uint32(data[2:])
	p.EndFrequency = binary.BigEndian.Uint32(data[6:])
	data = data[10:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFSurveySpecStopTrigger needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamRFSurveySpecStopTrigger {
		return errors.Errorf("expected ParamRFSurveySpecStopTrigger, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveySpecStopTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.RFSurveySpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// rfSurveySpecStopTrigger is Parameter 188, RFSurveySpecStopTrigger.
type rfSurveySpecStopTrigger struct {
	RFSurveySpecStopTriggerType RFSurveySpecStopTriggerType
	Duration                    milliSecs32
	N                           milliSecs32
}

// UnmarshalBinary Parameter 188, RFSurveySpecStopTrigger.
func (p *rfSurveySpecStopTrigger) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return errors.Errorf("ParamRFSurveySpecStopTrigger requires exactly 9 bytes "+
			"but received %d", len(data))
	}

	p.RFSurveySpecStopTriggerType = RFSurveySpecStopTriggerType(data[0])
	p.Duration = binary.BigEndian.Uint32(data[1:])
	p.N = binary.BigEndian.Uint32(data[5:])
	return nil
}

// accessSpec is Parameter 207, AccessSpec.
type accessSpec struct {
	AccessSpecID          uint32
	AntennaID             uint16
	AirProtocolID         AirProtocolIDType
	AccessSpecFlags       AccessSpecFlags
	ROSpecID              uint32
	AccessSpecStopTrigger accessSpecStopTrigger
	AccessCommand         accessCommand
	AccessReportSpec      *accessReportSpec
	Custom                []custom
}

// UnmarshalBinary Parameter 207, AccessSpec.
func (p *accessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 38 {
		return errors.Errorf("ParamAccessSpec requires at least 38 bytes "+
			"but only %d are available", len(data))
	}

	p.AccessSpecID = binary.BigEndian.Uint32(data)
	p.AntennaID = binary.BigEndian.Uint16(data[4:])
	p.AirProtocolID = AirProtocolIDType(data[6])
	p.AccessSpecFlags = AccessSpecFlags(data[7])
	p.ROSpecID = binary.BigEndian.Uint32(data[8:])
	data = data[12:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessSpecStopTrigger needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpecStopTrigger {
		return errors.Errorf("expected ParamAccessSpecStopTrigger, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessSpecStopTrigger says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.AccessSpecStopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessCommand needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessCommand {
		return errors.Errorf("expected ParamAccessCommand, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessCommand says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.AccessCommand.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAccessReportSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAccessReportSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.AccessReportSpec = new(accessReportSpec)
		*p.AccessReportSpec = accessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// accessSpecStopTrigger is Parameter 208, AccessSpecStopTrigger.
type accessSpecStopTrigger struct {
	AccessSpecStopTriggerType AccessSpecStopTriggerType
	OperationCountValue       uint16
}

// UnmarshalBinary Parameter 208, AccessSpecStopTrigger.
func (p *accessSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamAccessSpecStopTrigger requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.AccessSpecStopTriggerType = AccessSpecStopTriggerType(data[0])
	p.OperationCountValue = binary.BigEndian.Uint16(data[1:])
	return nil
}

// accessCommand is Parameter 209, AccessCommand.
type accessCommand struct {
	C1G2TagSpec                 c1G2TagSpec
	C1G2Read                    *c1G2Read
	C1G2Write                   *c1G2Write
	C1G2Kill                    *c1G2Kill
	C1G2Recommission            *c1G2Recommission
	C1G2Lock                    *c1G2Lock
	C1G2BlockErase              *c1G2BlockErase
	C1G2BlockWrite              *c1G2BlockWrite
	C1G2BlockPermalock          *c1G2BlockPermalock
	C1G2GetBlockPermalockStatus *c1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *clientRequestOpSpec
	Custom                      *custom
}

// UnmarshalBinary Parameter 209, AccessCommand.
func (p *accessCommand) UnmarshalBinary(data []byte) error {
	if len(data) < 15 {
		return errors.Errorf("ParamAccessCommand requires at least 15 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagSpec {
		return errors.Errorf("expected ParamC1G2TagSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.C1G2TagSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Read needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Read {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Read says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Read = new(c1G2Read)
		if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Write needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Write {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Write says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Write = new(c1G2Write)
		if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Kill needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Kill {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Kill says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Kill = new(c1G2Kill)
		if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Recommission needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Recommission {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Recommission says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Recommission = new(c1G2Recommission)
		if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Lock needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Lock {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Lock says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Lock = new(c1G2Lock)
		if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockErase needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockErase {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockErase says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockErase = new(c1G2BlockErase)
		if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockWrite needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockWrite {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockWrite says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockWrite = new(c1G2BlockWrite)
		if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockPermalock needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockPermalock {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockPermalock says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockPermalock = new(c1G2BlockPermalock)
		if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2GetBlockPermalockStatus needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2GetBlockPermalockStatus {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2GetBlockPermalockStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2GetBlockPermalockStatus = new(c1G2GetBlockPermalockStatus)
		if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamClientRequestOpSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamClientRequestOpSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamClientRequestOpSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ClientRequestOpSpec = new(clientRequestOpSpec)
		*p.ClientRequestOpSpec = clientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamCustom says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.Custom = new(custom)
		if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// clientRequestOpSpec is Parameter 210, ClientRequestOpSpec.
type clientRequestOpSpec uint16

// UnmarshalBinary Parameter 210, ClientRequestOpSpec.
func (p *clientRequestOpSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamClientRequestOpSpec requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = clientRequestOpSpec(binary.BigEndian.Uint16(data))
	return nil
}

// clientRequestResponse is Parameter 211, ClientRequestResponse.
type clientRequestResponse struct {
	AccessSpecID                uint32
	EPCData                     epcData
	C1G2Read                    *c1G2Read
	C1G2Write                   *c1G2Write
	C1G2Kill                    *c1G2Kill
	C1G2Recommission            *c1G2Recommission
	C1G2Lock                    *c1G2Lock
	C1G2BlockErase              *c1G2BlockErase
	C1G2BlockWrite              *c1G2BlockWrite
	C1G2BlockPermalock          *c1G2BlockPermalock
	C1G2GetBlockPermalockStatus *c1G2GetBlockPermalockStatus
	ClientRequestOpSpec         *clientRequestOpSpec
	Custom                      *custom
}

// UnmarshalBinary Parameter 211, ClientRequestResponse.
func (p *clientRequestResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ParamClientRequestResponse requires at least 10 bytes "+
			"but only %d are available", len(data))
	}

	p.AccessSpecID = binary.BigEndian.Uint32(data)
	data = data[4:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamEPCData needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEPCData {
		return errors.Errorf("expected ParamEPCData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEPCData says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Read needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Read {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Read says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Read = new(c1G2Read)
		if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Write needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Write {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Write says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Write = new(c1G2Write)
		if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Kill needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Kill {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Kill says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Kill = new(c1G2Kill)
		if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Recommission needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Recommission {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Recommission says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Recommission = new(c1G2Recommission)
		if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Lock needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Lock {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2Lock says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2Lock = new(c1G2Lock)
		if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockErase needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockErase {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockErase says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockErase = new(c1G2BlockErase)
		if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockWrite needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockWrite {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockWrite says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockWrite = new(c1G2BlockWrite)
		if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockPermalock needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockPermalock {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2BlockPermalock says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2BlockPermalock = new(c1G2BlockPermalock)
		if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2GetBlockPermalockStatus needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2GetBlockPermalockStatus {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2GetBlockPermalockStatus says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2GetBlockPermalockStatus = new(c1G2GetBlockPermalockStatus)
		if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamClientRequestOpSpec needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamClientRequestOpSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamClientRequestOpSpec says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ClientRequestOpSpec = new(clientRequestOpSpec)
		*p.ClientRequestOpSpec = clientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamCustom says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.Custom = new(custom)
		if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// llrpConfigurationStateValue is Parameter 217, LLRPConfigurationStateValue.
type llrpConfigurationStateValue uint32

// UnmarshalBinary Parameter 217, LLRPConfigurationStateValue.
func (p *llrpConfigurationStateValue) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamLLRPConfigurationStateValue requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	*p = llrpConfigurationStateValue(binary.BigEndian.Uint32(data))
	return nil
}

// identification is Parameter 218, Identification.
type identification struct {
	IDType   IDType
	ReaderID []byte
}

// UnmarshalBinary Parameter 218, Identification.
func (p *identification) UnmarshalBinary(data []byte) error {
	if len(data) < 3 {
		return errors.Errorf("ParamIdentification requires at least 3 bytes "+
			"but only %d are available", len(data))
	}

	p.IDType = IDType(data[0])
	if arrLen := int(binary.BigEndian.Uint16(data[1:])); int64(arrLen) > int64(len(data[3:])) {
		return errors.Errorf("ReaderID ([]byte) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[3:]))
	} else if arrLen != 0 {
		p.ReaderID = make([]byte, arrLen)
		copy(p.ReaderID, data[3:])
		data = data[arrLen+3:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading Identification, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// gpoWriteData is Parameter 219, GPOWriteData.
type gpoWriteData struct {
	GPOPort uint16
	GPOData bool
}

// UnmarshalBinary Parameter 219, GPOWriteData.
func (p *gpoWriteData) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamGPOWriteData requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.GPOPort = binary.BigEndian.Uint16(data)
	p.GPOData = data[2]&0x80 != 0
	return nil
}

// keepAliveSpec is Parameter 220, KeepAliveSpec.
type keepAliveSpec struct {
	KeepAliveTriggerType KeepAliveTriggerType
	Interval             milliSecs32
}

// UnmarshalBinary Parameter 220, KeepAliveSpec.
func (p *keepAliveSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errors.Errorf("ParamKeepAliveSpec requires exactly 5 bytes "+
			"but received %d", len(data))
	}

	p.KeepAliveTriggerType = KeepAliveTriggerType(data[0])
	p.Interval = binary.BigEndian.Uint32(data[1:])
	return nil
}

// antennaProperties is Parameter 221, AntennaProperties.
type antennaProperties struct {
	AntennaConnected bool
	AntennaID        uint16
	AntennaGain      dBiX100
}

// UnmarshalBinary Parameter 221, AntennaProperties.
func (p *antennaProperties) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errors.Errorf("ParamAntennaProperties requires exactly 5 bytes "+
			"but received %d", len(data))
	}

	p.AntennaConnected = data[0]&0x80 != 0
	p.AntennaID = binary.BigEndian.Uint16(data[1:])
	p.AntennaGain = binary.BigEndian.Uint16(data[3:])
	return nil
}

// antennaConfiguration is Parameter 222, AntennaConfiguration.
type antennaConfiguration struct {
	AntennaID            uint16
	RFReceiver           *rfReceiver
	RFTransmitter        *rfTransmitter
	C1G2InventoryCommand []c1G2InventoryCommand
	Custom               []custom
}

// UnmarshalBinary Parameter 222, AntennaConfiguration.
func (p *antennaConfiguration) UnmarshalBinary(data []byte) error {
	if len(data) < 2 {
		return errors.Errorf("ParamAntennaConfiguration requires at least 2 bytes "+
			"but only %d are available", len(data))
	}

	p.AntennaID = binary.BigEndian.Uint16(data)
	data = data[2:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFReceiver needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFReceiver {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFReceiver says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.RFReceiver = new(rfReceiver)
		*p.RFReceiver = rfReceiver(binary.BigEndian.Uint16(data[4:]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFTransmitter needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFTransmitter {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFTransmitter says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.RFTransmitter = new(rfTransmitter)
		if err := p.RFTransmitter.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2InventoryCommand needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2InventoryCommand {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2InventoryCommand {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2InventoryCommand says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2InventoryCommand
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2InventoryCommand = append(p.C1G2InventoryCommand, tmp)
			data = data[subLen:]
		}

	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// rfReceiver is Parameter 223, RFReceiver.
type rfReceiver uint16

// UnmarshalBinary Parameter 223, RFReceiver.
func (p *rfReceiver) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamRFReceiver requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = rfReceiver(binary.BigEndian.Uint16(data))
	return nil
}

// rfTransmitter is Parameter 224, RFTransmitter.
type rfTransmitter struct {
	HopTableID                        uint16
	ChannelIndexInFixedFrequencyTable uint16
	TransmitPowerTableIndex           uint16
}

// UnmarshalBinary Parameter 224, RFTransmitter.
func (p *rfTransmitter) UnmarshalBinary(data []byte) error {
	if len(data) != 6 {
		return errors.Errorf("ParamRFTransmitter requires exactly 6 bytes "+
			"but received %d", len(data))
	}

	p.HopTableID = binary.BigEndian.Uint16(data)
	p.ChannelIndexInFixedFrequencyTable = binary.BigEndian.Uint16(data[2:])
	p.TransmitPowerTableIndex = binary.BigEndian.Uint16(data[4:])
	return nil
}

// gpiPortCurrentState is Parameter 225, GPIPortCurrentState.
type gpiPortCurrentState struct {
	GPIPort        uint16
	GPIPortEnabled bool
	GPIState       GPIStateType
}

// UnmarshalBinary Parameter 225, GPIPortCurrentState.
func (p *gpiPortCurrentState) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamGPIPortCurrentState requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.GPIPort = binary.BigEndian.Uint16(data)
	p.GPIPortEnabled = data[2]&0x80 != 0
	p.GPIState = GPIStateType(data[3])
	return nil
}

// eventsAndReports is Parameter 226, EventsAndReports.
type eventsAndReports bool

// UnmarshalBinary Parameter 226, EventsAndReports.
func (p *eventsAndReports) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamEventsAndReports requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = eventsAndReports(data[0]&0x80 != 0)
	return nil
}

// roReportSpec is Parameter 237, ROReportSpec.
type roReportSpec struct {
	ROReportTriggerType      ROReportTriggerType
	N                        uint16
	TagReportContentSelector tagReportContentSelector
	Custom                   []custom
}

// UnmarshalBinary Parameter 237, ROReportSpec.
func (p *roReportSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 9 {
		return errors.Errorf("ParamROReportSpec requires at least 9 bytes "+
			"but only %d are available", len(data))
	}

	p.ROReportTriggerType = ROReportTriggerType(data[0])
	p.N = binary.BigEndian.Uint16(data[1:])
	data = data[3:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamTagReportContentSelector needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportContentSelector {
		return errors.Errorf("expected ParamTagReportContentSelector, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamTagReportContentSelector says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.TagReportContentSelector.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// tagReportContentSelector is Parameter 238, TagReportContentSelector.
type tagReportContentSelector struct {
	EnableROSpecID             bool
	EnableSpecIndex            bool
	EnableInventoryParamSpecID bool
	EnableAntennaID            bool
	EnableChannelIndex         bool
	EnablePeakRSSI             bool
	EnableFirstSeenTimestamp   bool
	EnableLastSeenTimestamp    bool
	EnableTagSeenCount         bool
	EnableAccessSpecID         bool
	C1G2EPCMemorySelector      []c1G2EPCMemorySelector
	Custom                     []custom
}

// UnmarshalBinary Parameter 238, TagReportContentSelector.
func (p *tagReportContentSelector) UnmarshalBinary(data []byte) error {
	if len(data) < 2 {
		return errors.Errorf("ParamTagReportContentSelector requires at least 2 bytes "+
			"but only %d are available", len(data))
	}

	p.EnableROSpecID = data[0]&0x80 != 0
	p.EnableSpecIndex = data[0]&0x40 != 0
	p.EnableInventoryParamSpecID = data[0]&0x20 != 0
	p.EnableAntennaID = data[0]&0x10 != 0
	p.EnableChannelIndex = data[0]&0x08 != 0
	p.EnablePeakRSSI = data[0]&0x04 != 0
	p.EnableFirstSeenTimestamp = data[0]&0x02 != 0
	p.EnableLastSeenTimestamp = data[0]&0x01 != 0
	p.EnableTagSeenCount = data[1]&0x80 != 0
	p.EnableAccessSpecID = data[1]&0x40 != 0
	data = data[2:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2EPCMemorySelector needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2EPCMemorySelector {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2EPCMemorySelector {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2EPCMemorySelector says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2EPCMemorySelector
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2EPCMemorySelector = append(p.C1G2EPCMemorySelector, tmp)
			data = data[subLen:]
		}

	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// accessReportSpec is Parameter 239, AccessReportSpec.
type accessReportSpec AccessReportTriggerType

// UnmarshalBinary Parameter 239, AccessReportSpec.
func (p *accessReportSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamAccessReportSpec requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = accessReportSpec(AccessReportTriggerType(data[0]))
	return nil
}

// tagReportData is Parameter 240, TagReportData.
type tagReportData struct {
	EPCData                                 epcData
	EPC96                                   *epc96
	ROSpecID                                *roSpecID
	SpecIndex                               *specIndex
	InventoryParameterSpecID                *inventoryParameterSpecID
	AntennaID                               *antennaID
	PeakRSSI                                *peakRSSI
	ChannelIndex                            *channelIndex
	FirstSeenUTC                            *firstSeenUTC
	FirstSeenUptime                         *firstSeenUptime
	LastSeenUTC                             *lastSeenUTC
	LastSeenUptime                          *lastSeenUptime
	TagSeenCount                            *tagSeenCount
	C1G2PC                                  []c1G2PC
	C1G2XPCW1                               []c1G2XPCW1
	C1G2XPCW2                               []c1G2XPCW2
	C1G2CRC                                 []c1G2CRC
	AccessSpecID                            *accessSpecID
	C1G2ReadOpSpecResult                    []c1G2ReadOpSpecResult
	C1G2WriteOpSpecResult                   []c1G2WriteOpSpecResult
	C1G2KillOpSpecResult                    []c1G2KillOpSpecResult
	C1G2LockOpSpecResult                    []c1G2LockOpSpecResult
	C1G2BlockEraseOpSpecResult              []c1G2BlockEraseOpSpecResult
	C1G2BlockWriteOpSpecResult              []c1G2BlockWriteOpSpecResult
	C1G2RecommissionOpSpecResult            []c1G2RecommissionOpSpecResult
	C1G2BlockPermalockOpSpecResult          []c1G2BlockPermalockOpSpecResult
	C1G2GetBlockPermalockStatusOpSpecResult []c1G2GetBlockPermalockStatusOpSpecResult
	ClientRequestOpSpecResult               []clientRequestOpSpecResult
	Custom                                  []custom
}

// UnmarshalBinary Parameter 240, TagReportData.
func (p *tagReportData) UnmarshalBinary(data []byte) error {
	if len(data) < 6 {
		return errors.Errorf("ParamTagReportData requires at least 6 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEPCData {
		return errors.Errorf("expected ParamEPCData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamEPCData says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamEPC96 {
		return errors.Errorf("expected ParamEPC96, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamROSpecID {
		return errors.Errorf("expected ParamROSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamSpecIndex {
		return errors.Errorf("expected ParamSpecIndex, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamInventoryParameterSpecID {
		return errors.Errorf("expected ParamInventoryParameterSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamAntennaID {
		return errors.Errorf("expected ParamAntennaID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamPeakRSSI {
		return errors.Errorf("expected ParamPeakRSSI, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamChannelIndex {
		return errors.Errorf("expected ParamChannelIndex, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamFirstSeenUTC {
		return errors.Errorf("expected ParamFirstSeenUTC, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamFirstSeenUptime {
		return errors.Errorf("expected ParamFirstSeenUptime, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamLastSeenUTC {
		return errors.Errorf("expected ParamLastSeenUTC, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamLastSeenUptime {
		return errors.Errorf("expected ParamLastSeenUptime, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamTagSeenCount {
		return errors.Errorf("expected ParamTagSeenCount, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamC1G2PC {
		return errors.Errorf("expected ParamC1G2PC, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamC1G2XPCW1 {
		return errors.Errorf("expected ParamC1G2XPCW1, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamC1G2XPCW2 {
		return errors.Errorf("expected ParamC1G2XPCW2, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamC1G2CRC {
		return errors.Errorf("expected ParamC1G2CRC, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamAccessSpecID {
		return errors.Errorf("expected ParamAccessSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2ReadOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2ReadOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2ReadOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2ReadOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2ReadOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2ReadOpSpecResult = append(p.C1G2ReadOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2WriteOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2WriteOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2WriteOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2WriteOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2WriteOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2WriteOpSpecResult = append(p.C1G2WriteOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2KillOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2KillOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2KillOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2KillOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2KillOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2KillOpSpecResult = append(p.C1G2KillOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2LockOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2LockOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2LockOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2LockOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2LockOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2LockOpSpecResult = append(p.C1G2LockOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockEraseOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockEraseOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2BlockEraseOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockEraseOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2BlockEraseOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2BlockEraseOpSpecResult = append(p.C1G2BlockEraseOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockWriteOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockWriteOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2BlockWriteOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockWriteOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2BlockWriteOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2BlockWriteOpSpecResult = append(p.C1G2BlockWriteOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2RecommissionOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2RecommissionOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2RecommissionOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2RecommissionOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2RecommissionOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2RecommissionOpSpecResult = append(p.C1G2RecommissionOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2BlockPermalockOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2BlockPermalockOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2BlockPermalockOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2BlockPermalockOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2BlockPermalockOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2BlockPermalockOpSpecResult = append(p.C1G2BlockPermalockOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2GetBlockPermalockStatusOpSpecResult needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2GetBlockPermalockStatusOpSpecResult {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2GetBlockPermalockStatusOpSpecResult {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2GetBlockPermalockStatusOpSpecResult says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2GetBlockPermalockStatusOpSpecResult
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2GetBlockPermalockStatusOpSpecResult = append(p.C1G2GetBlockPermalockStatusOpSpecResult, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamClientRequestOpSpecResult {
		return errors.Errorf("expected ParamClientRequestOpSpecResult, but found %v", ParamType(data[0]))
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// epcData is Parameter 241, EPCData.
type epcData struct {
	EPC []byte
}

// UnmarshalBinary Parameter 241, EPCData.
func (p *epcData) UnmarshalBinary(data []byte) error {
	if len(data) < 2 {
		return errors.Errorf("ParamEPCData requires at least 2 bytes "+
			"but only %d are available", len(data))
	}

	if arrLen := int(binary.BigEndian.Uint16(data)) & 7; int64(arrLen) > int64(len(data[2:])) {
		return errors.Errorf("EPC (bit array) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.EPC = make([]byte, arrLen)
		for i := 0; i < arrLen; i++ {
			p.EPC[i] = data[i]
		}

		data = data[arrLen+2:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading EPCData, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// rfSurveyReportData is Parameter 242, RFSurveyReportData.
type rfSurveyReportData struct {
	ROSpecID                *roSpecID
	SpecIndex               *specIndex
	FrequencyRSSILevelEntry []frequencyRSSILevelEntry
	Custom                  []custom
}

// UnmarshalBinary Parameter 242, RFSurveyReportData.
func (p *rfSurveyReportData) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return errors.Errorf("ParamRFSurveyReportData requires at least 14 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if ParamType(data[0]) != ParamROSpecID {
		return errors.Errorf("expected ParamROSpecID, but found %v", ParamType(data[0]))
	}

	if ParamType(data[0]) != ParamSpecIndex {
		return errors.Errorf("expected ParamSpecIndex, but found %v", ParamType(data[0]))
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFrequencyRSSILevelEntry needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamFrequencyRSSILevelEntry {
		return errors.Errorf("expected ParamFrequencyRSSILevelEntry, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamFrequencyRSSILevelEntry {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamFrequencyRSSILevelEntry says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp frequencyRSSILevelEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.FrequencyRSSILevelEntry = append(p.FrequencyRSSILevelEntry, tmp)
			data = data[subLen:]
		}

	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// frequencyRSSILevelEntry is Parameter 243, FrequencyRSSILevelEntry.
type frequencyRSSILevelEntry struct {
	Frequency    kHz
	Bandwidth    kHz
	AverageRSSI  dBm8
	PeakRSSI     dBm8
	UTCTimestamp *utcTimestamp
	Uptime       *uptime
}

// UnmarshalBinary Parameter 243, FrequencyRSSILevelEntry.
func (p *frequencyRSSILevelEntry) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ParamFrequencyRSSILevelEntry requires at least 10 bytes "+
			"but only %d are available", len(data))
	}

	p.Frequency = binary.BigEndian.Uint32(data)
	p.Bandwidth = binary.BigEndian.Uint32(data[4:])
	p.AverageRSSI = dBm8(data[8])
	p.PeakRSSI = dBm8(data[9])
	data = data[10:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUTCTimestamp needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUTCTimestamp {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUTCTimestamp says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.UTCTimestamp = new(utcTimestamp)
		*p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}

	// Uptime is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUptime needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUptime {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUptime says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.Uptime = new(uptime)
		*p.Uptime = uptime(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}

	return nil
}

// readerEventNotificationSpec is Parameter 244, ReaderEventNotificationSpec.
type readerEventNotificationSpec struct {
	EventNotificationState []eventNotificationState
}

// UnmarshalBinary Parameter 244, ReaderEventNotificationSpec.
func (p *readerEventNotificationSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("ParamReaderEventNotificationSpec requires at least 7 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEventNotificationState {
		return errors.Errorf("expected ParamEventNotificationState, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamEventNotificationState {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamEventNotificationState says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp eventNotificationState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.EventNotificationState = append(p.EventNotificationState, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// eventNotificationState is Parameter 245, EventNotificationState.
type eventNotificationState struct {
	ReaderEventType        ReaderEventType
	NotificationStateFlags NotificationStateFlags
}

// UnmarshalBinary Parameter 245, EventNotificationState.
func (p *eventNotificationState) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamEventNotificationState requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.ReaderEventType = ReaderEventType(binary.BigEndian.Uint16(data))
	p.NotificationStateFlags = NotificationStateFlags(data[2])
	return nil
}

// readerEventNotificationData is Parameter 246, ReaderEventNotificationData.
type readerEventNotificationData struct {
	UTCTimestamp                   utcTimestamp
	Uptime                         *uptime
	HoppingEvent                   *hoppingEvent
	GPIEvent                       *gpiEvent
	ROSpecEvent                    *roSpecEvent
	ReportBufferLevelWarningEvent  *reportBufferLevelWarningEvent
	ReportBufferOverflowErrorEvent *reportBufferOverflowErrorEvent
	ReaderExceptionEvent           *readerExceptionEvent
	RFSurveyEvent                  *rfSurveyEvent
	AISpecEvent                    *aiSpecEvent
	AntennaEvent                   *antennaEvent
	ConnectionAttemptEvent         *connectionAttemptEvent
	ConnectionCloseEvent           *connectionCloseEvent
	SpecLoopEvent                  *specLoopEvent
	Custom                         []custom
}

// UnmarshalBinary Parameter 246, ReaderEventNotificationData.
func (p *readerEventNotificationData) UnmarshalBinary(data []byte) error {
	if len(data) < 12 {
		return errors.Errorf("ParamReaderEventNotificationData requires at least 12 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamUTCTimestamp {
		return errors.Errorf("expected ParamUTCTimestamp, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUTCTimestamp says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.UTCTimestamp = utcTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamUptime needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUptime {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamUptime says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.Uptime = new(uptime)
		*p.Uptime = uptime(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamHoppingEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamHoppingEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamHoppingEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.HoppingEvent = new(hoppingEvent)
		*p.HoppingEvent = hoppingEvent(binary.BigEndian.Uint16(data[4:]))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamGPIEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPIEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamGPIEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.GPIEvent = new(gpiEvent)
		if err := p.GPIEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamROSpecEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamROSpecEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamROSpecEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ROSpecEvent = new(roSpecEvent)
		if err := p.ROSpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamReportBufferLevelWarningEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReportBufferLevelWarningEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReportBufferLevelWarningEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ReportBufferLevelWarningEvent = new(reportBufferLevelWarningEvent)
		*p.ReportBufferLevelWarningEvent = reportBufferLevelWarningEvent(data[4])
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamReportBufferOverflowErrorEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReportBufferOverflowErrorEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReportBufferOverflowErrorEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ReportBufferOverflowErrorEvent = new(reportBufferOverflowErrorEvent)
		if err := p.ReportBufferOverflowErrorEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamReaderExceptionEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderExceptionEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamReaderExceptionEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ReaderExceptionEvent = new(readerExceptionEvent)
		if err := p.ReaderExceptionEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamRFSurveyEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFSurveyEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamRFSurveyEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.RFSurveyEvent = new(rfSurveyEvent)
		if err := p.RFSurveyEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAISpecEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAISpecEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAISpecEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.AISpecEvent = new(aiSpecEvent)
		if err := p.AISpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamAntennaEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAntennaEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamAntennaEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.AntennaEvent = new(antennaEvent)
		if err := p.AntennaEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamConnectionAttemptEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamConnectionAttemptEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamConnectionAttemptEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ConnectionAttemptEvent = new(connectionAttemptEvent)
		*p.ConnectionAttemptEvent = connectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data[4:])))
		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamConnectionCloseEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamConnectionCloseEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamConnectionCloseEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ConnectionCloseEvent = new(connectionCloseEvent)
		if err := p.ConnectionCloseEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamSpecLoopEvent needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamSpecLoopEvent {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamSpecLoopEvent says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.SpecLoopEvent = new(specLoopEvent)
		if err := p.SpecLoopEvent.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// hoppingEvent is Parameter 247, HoppingEvent.
type hoppingEvent uint16

// UnmarshalBinary Parameter 247, HoppingEvent.
func (p *hoppingEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamHoppingEvent requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = hoppingEvent(binary.BigEndian.Uint16(data))
	return nil
}

// gpiEvent is Parameter 248, GPIEvent.
type gpiEvent struct {
	GPIPort       uint16
	GPIEventFlags GPIEventFlags
}

// UnmarshalBinary Parameter 248, GPIEvent.
func (p *gpiEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamGPIEvent requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.GPIPort = binary.BigEndian.Uint16(data)
	p.GPIEventFlags = GPIEventFlags(data[2])
	return nil
}

// roSpecEvent is Parameter 249, ROSpecEvent.
type roSpecEvent struct {
	ROSpecEventType    ROSpecEventType
	ROSpecID           uint32
	PreemptingROSpecID uint32
}

// UnmarshalBinary Parameter 249, ROSpecEvent.
func (p *roSpecEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 9 {
		return errors.Errorf("ParamROSpecEvent requires exactly 9 bytes "+
			"but received %d", len(data))
	}

	p.ROSpecEventType = ROSpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.PreemptingROSpecID = binary.BigEndian.Uint32(data[5:])
	return nil
}

// reportBufferLevelWarningEvent is Parameter 250, ReportBufferLevelWarningEvent.
type reportBufferLevelWarningEvent uint8

// UnmarshalBinary Parameter 250, ReportBufferLevelWarningEvent.
func (p *reportBufferLevelWarningEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamReportBufferLevelWarningEvent requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = reportBufferLevelWarningEvent(data[0])
	return nil
}

// reportBufferOverflowErrorEvent is Parameter 251, ReportBufferOverflowErrorEvent.
type reportBufferOverflowErrorEvent struct{}

// UnmarshalBinary Parameter 251, ReportBufferOverflowErrorEvent.
func (p *reportBufferOverflowErrorEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 0 {
		return errors.Errorf("ParamReportBufferOverflowErrorEvent requires exactly 0 bytes "+
			"but received %d", len(data))
	}

	return nil
}

// readerExceptionEvent is Parameter 252, ReaderExceptionEvent.
type readerExceptionEvent struct {
	Message                  string
	ROSpecID                 *roSpecID
	SpecIndex                *specIndex
	InventoryParameterSpecID *inventoryParameterSpecID
	AntennaID                *antennaID
	AccessSpecID             *accessSpecID
	OpSpecID                 *opSpecID
	Custom                   []custom
}

// UnmarshalBinary Parameter 252, ReaderExceptionEvent.
func (p *readerExceptionEvent) UnmarshalBinary(data []byte) error {
	if len(data) < 2 {
		return errors.Errorf("ParamReaderExceptionEvent requires at least 2 bytes "+
			"but only %d are available", len(data))
	}

	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen) > int64(len(data[2:])) {
		return errors.Errorf("Message (string) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.Message = string(data[2 : arrLen+2])
		data = data[arrLen+2:]
	}

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamROSpecID {
		return errors.Errorf("expected ParamROSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamSpecIndex {
		return errors.Errorf("expected ParamSpecIndex, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamInventoryParameterSpecID {
		return errors.Errorf("expected ParamInventoryParameterSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamAntennaID {
		return errors.Errorf("expected ParamAntennaID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamAccessSpecID {
		return errors.Errorf("expected ParamAccessSpecID, but found %v", ParamType(data[0]))
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamOpSpecID {
		return errors.Errorf("expected ParamOpSpecID, but found %v", ParamType(data[0]))
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// rfSurveyEvent is Parameter 253, RFSurveyEvent.
type rfSurveyEvent struct {
	RFSurveyEventType RFSurveyEventType
	ROSpecID          uint32
}

// UnmarshalBinary Parameter 253, RFSurveyEvent.
func (p *rfSurveyEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errors.Errorf("ParamRFSurveyEvent requires exactly 5 bytes "+
			"but received %d", len(data))
	}

	p.RFSurveyEventType = RFSurveyEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	return nil
}

// aiSpecEvent is Parameter 254, AISpecEvent.
type aiSpecEvent struct {
	AISpecEventType        AISpecEventType
	ROSpecID               uint32
	SpecIndex              uint16
	C1G2SingulationDetails *c1G2SingulationDetails
}

// UnmarshalBinary Parameter 254, AISpecEvent.
func (p *aiSpecEvent) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("ParamAISpecEvent requires at least 7 bytes "+
			"but only %d are available", len(data))
	}

	p.AISpecEventType = AISpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.SpecIndex = binary.BigEndian.Uint16(data[5:])
	data = data[7:]

	// sub-parameters

	// C1G2SingulationDetails is optional
	if len(data) == 0 {
		return nil
	}

	if ParamType(data[0]) != ParamC1G2SingulationDetails {
		return errors.Errorf("expected ParamC1G2SingulationDetails, but found %v", ParamType(data[0]))
	}

	return nil
}

// antennaEvent is Parameter 255, AntennaEvent.
type antennaEvent struct {
	AntennaEventType AntennaEventType
	AntennaID        uint16
}

// UnmarshalBinary Parameter 255, AntennaEvent.
func (p *antennaEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamAntennaEvent requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.AntennaEventType = AntennaEventType(data[0])
	p.AntennaID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// connectionAttemptEvent is Parameter 256, ConnectionAttemptEvent.
type connectionAttemptEvent ConnectionAttemptEventType

// UnmarshalBinary Parameter 256, ConnectionAttemptEvent.
func (p *connectionAttemptEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamConnectionAttemptEvent requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = connectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data)))
	return nil
}

// connectionCloseEvent is Parameter 257, ConnectionCloseEvent.
type connectionCloseEvent struct{}

// UnmarshalBinary Parameter 257, ConnectionCloseEvent.
func (p *connectionCloseEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 0 {
		return errors.Errorf("ParamConnectionCloseEvent requires exactly 0 bytes "+
			"but received %d", len(data))
	}

	return nil
}

// llrpStatus is Parameter 287, LLRPStatus.
type llrpStatus struct {
	Status           StatusCode
	ErrorDescription string
	FieldError       *fieldError
	ParameterError   *parameterError
}

// UnmarshalBinary Parameter 287, LLRPStatus.
func (p *llrpStatus) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamLLRPStatus requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	p.Status = StatusCode(binary.BigEndian.Uint16(data))
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen) > int64(len(data[4:])) {
		return errors.Errorf("ErrorDescription (string) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.ErrorDescription = string(data[4 : arrLen+4])
		data = data[arrLen+4:]
	}

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFieldError needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFieldError {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFieldError says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.FieldError = new(fieldError)
		if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// ParameterError is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamParameterError needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamParameterError {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamParameterError says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ParameterError = new(parameterError)
		if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// fieldError is Parameter 288, FieldError.
type fieldError struct {
	FieldIndex uint16
	ErrorCode  StatusCode
}

// UnmarshalBinary Parameter 288, FieldError.
func (p *fieldError) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamFieldError requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.FieldIndex = binary.BigEndian.Uint16(data)
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	return nil
}

// parameterError is Parameter 289, ParameterError.
type parameterError struct {
	ParameterType  ParamType
	ErrorCode      StatusCode
	ParameterError *parameterError
	FieldError     *fieldError
}

// UnmarshalBinary Parameter 289, ParameterError.
func (p *parameterError) UnmarshalBinary(data []byte) error {
	if len(data) < 4 {
		return errors.Errorf("ParamParameterError requires at least 4 bytes "+
			"but only %d are available", len(data))
	}

	p.ParameterType = ParamType(binary.BigEndian.Uint16(data))
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	data = data[4:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamParameterError needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamParameterError {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamParameterError says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.ParameterError = new(parameterError)
		if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// FieldError is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamFieldError needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFieldError {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamFieldError says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.FieldError = new(fieldError)
		if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// c1G2LLRPCapabilities is Parameter 327, C1G2LLRPCapabilities.
type c1G2LLRPCapabilities struct {
	C1G2CapabilitiesFlags       C1G2CapabilitiesFlags
	MaxNumSelectFiltersPerQuery uint16
}

// UnmarshalBinary Parameter 327, C1G2LLRPCapabilities.
func (p *c1G2LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2LLRPCapabilities requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2CapabilitiesFlags = C1G2CapabilitiesFlags(data[0])
	p.MaxNumSelectFiltersPerQuery = binary.BigEndian.Uint16(data[1:])
	return nil
}

// uhfc1G2RFModeTable is Parameter 328, UHFC1G2RFModeTable.
type uhfc1G2RFModeTable struct {
	UHFC1G2RFModeTableEntry []uhfc1G2RFModeTableEntry
}

// UnmarshalBinary Parameter 328, UHFC1G2RFModeTable.
func (p *uhfc1G2RFModeTable) UnmarshalBinary(data []byte) error {
	if len(data) < 32 {
		return errors.Errorf("ParamUHFC1G2RFModeTable requires at least 32 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamUHFC1G2RFModeTableEntry {
		return errors.Errorf("expected ParamUHFC1G2RFModeTableEntry, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamUHFC1G2RFModeTableEntry {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamUHFC1G2RFModeTableEntry says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp uhfc1G2RFModeTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.UHFC1G2RFModeTableEntry = append(p.UHFC1G2RFModeTableEntry, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// uhfc1G2RFModeTableEntry is Parameter 329, UHFC1G2RFModeTableEntry.
type uhfc1G2RFModeTableEntry struct {
	ModeID                     uint32
	UHFC1G2RFModeFlags         UHFC1G2RFModeFlags
	BackscatterDataRate        bps
	Modulation                 ModulationType
	ForwardLinkModulation      ForwardLinkModulationType
	PulseIntervalEncodingRatio uint32
	MinTariTime                nanoSecs32
	MaxTariTime                nanoSecs32
	StepTariTime               nanoSecs32
	SpectralMask               SpectralMaskType
}

// UnmarshalBinary Parameter 329, UHFC1G2RFModeTableEntry.
func (p *uhfc1G2RFModeTableEntry) UnmarshalBinary(data []byte) error {
	if len(data) != 28 {
		return errors.Errorf("ParamUHFC1G2RFModeTableEntry requires exactly 28 bytes "+
			"but received %d", len(data))
	}

	p.ModeID = binary.BigEndian.Uint32(data)
	p.UHFC1G2RFModeFlags = UHFC1G2RFModeFlags(data[4])
	p.BackscatterDataRate = binary.BigEndian.Uint32(data[5:])
	p.Modulation = ModulationType(data[9])
	p.ForwardLinkModulation = ForwardLinkModulationType(data[10])
	p.PulseIntervalEncodingRatio = binary.BigEndian.Uint32(data[11:])
	p.MinTariTime = binary.BigEndian.Uint32(data[15:])
	p.MaxTariTime = binary.BigEndian.Uint32(data[19:])
	p.StepTariTime = binary.BigEndian.Uint32(data[23:])
	p.SpectralMask = SpectralMaskType(data[27])
	return nil
}

// c1G2InventoryCommand is Parameter 330, C1G2InventoryCommand.
type c1G2InventoryCommand struct {
	C1G2InventoryCommandFlags C1G2InventoryCommandFlags
	C1G2Filter                []c1G2Filter
	C1G2RFControl             *c1G2RFControl
	C1G2SingulationControl    *c1G2SingulationControl
	Custom                    []custom
}

// UnmarshalBinary Parameter 330, C1G2InventoryCommand.
func (p *c1G2InventoryCommand) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return errors.Errorf("ParamC1G2InventoryCommand requires at least 1 byte "+
			"but only %d are available", len(data))
	}

	p.C1G2InventoryCommandFlags = C1G2InventoryCommandFlags(data[0])
	data = data[1:]

	// sub-parameters

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2Filter needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2Filter {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2Filter {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2Filter says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2Filter
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2Filter = append(p.C1G2Filter, tmp)
			data = data[subLen:]
		}

	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2RFControl needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2RFControl {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2RFControl says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2RFControl = new(c1G2RFControl)
		if err := p.C1G2RFControl.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2SingulationControl needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2SingulationControl {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2SingulationControl says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2SingulationControl = new(c1G2SingulationControl)
		if err := p.C1G2SingulationControl.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// Custom is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamCustom needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamCustom {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamCustom {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamCustom says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.Custom = append(p.Custom, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// c1G2Filter is Parameter 331, C1G2Filter.
type c1G2Filter struct {
	C1G2FilterAction                         C1G2FilterActionType
	C1G2TagInventoryMask                     c1G2TagInventoryMask
	C1G2TagInventoryStateAwareFilterAction   *c1G2TagInventoryStateAwareFilterAction
	C1G2TagInventoryStateUnawareFilterAction *c1G2TagInventoryStateUnawareFilterAction
}

// UnmarshalBinary Parameter 331, C1G2Filter.
func (p *c1G2Filter) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return errors.Errorf("ParamC1G2Filter requires at least 10 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2FilterAction = C1G2FilterActionType(data[0])
	data = data[1:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2TagInventoryMask needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagInventoryMask {
		return errors.Errorf("expected ParamC1G2TagInventoryMask, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryMask says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.C1G2TagInventoryMask.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// only optional parameters remain; return if no more data
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2TagInventoryStateAwareFilterAction needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateAwareFilterAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryStateAwareFilterAction says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2TagInventoryStateAwareFilterAction = new(c1G2TagInventoryStateAwareFilterAction)
		if err := p.C1G2TagInventoryStateAwareFilterAction.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// C1G2TagInventoryStateUnawareFilterAction is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2TagInventoryStateUnawareFilterAction needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateUnawareFilterAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryStateUnawareFilterAction says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2TagInventoryStateUnawareFilterAction = new(c1G2TagInventoryStateUnawareFilterAction)
		*p.C1G2TagInventoryStateUnawareFilterAction = c1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[4]))
		data = data[subLen:]
	}

	return nil
}

// c1G2TagInventoryMask is Parameter 332, C1G2TagInventoryMask.
type c1G2TagInventoryMask struct {
	C1G2MemoryBank     C1G2MemoryBankType
	MostSignificantBit uint16
	TagMask            []byte
}

// UnmarshalBinary Parameter 332, C1G2TagInventoryMask.
func (p *c1G2TagInventoryMask) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamC1G2TagInventoryMask requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2MemoryBank = data[0] >> 6
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	if arrLen := int(binary.BigEndian.Uint16(data[3:])) & 7; int64(arrLen) > int64(len(data[5:])) {
		return errors.Errorf("TagMask (bit array) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.TagMask = make([]byte, arrLen)
		for i := 0; i < arrLen; i++ {
			p.TagMask[i] = data[i]
		}

		data = data[arrLen+5:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TagInventoryMask, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2TagInventoryStateAwareFilterAction is Parameter 333, C1G2TagInventoryStateAwareFilterAction.
type c1G2TagInventoryStateAwareFilterAction struct {
	C1G2TagInventoryTarget                 C1G2TagInventoryTargetType
	C1G2TagInventoryStateAwareFilterAction C1G2TagInventoryStateAwareFilterActionType
}

// UnmarshalBinary Parameter 333, C1G2TagInventoryStateAwareFilterAction.
func (p *c1G2TagInventoryStateAwareFilterAction) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2TagInventoryStateAwareFilterAction requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	p.C1G2TagInventoryTarget = C1G2TagInventoryTargetType(data[0])
	p.C1G2TagInventoryStateAwareFilterAction = C1G2TagInventoryStateAwareFilterActionType(data[1])
	return nil
}

// c1G2TagInventoryStateUnawareFilterAction is Parameter 334, C1G2TagInventoryStateUnawareFilterAction.
type c1G2TagInventoryStateUnawareFilterAction C1G2TagInventoryStateUnawareFilterActionType

// UnmarshalBinary Parameter 334, C1G2TagInventoryStateUnawareFilterAction.
func (p *c1G2TagInventoryStateUnawareFilterAction) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamC1G2TagInventoryStateUnawareFilterAction requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = c1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[0]))
	return nil
}

// c1G2RFControl is Parameter 335, C1G2RFControl.
type c1G2RFControl struct {
	IndexIntoUHFC1G2RFModeTable uint16
	Tari                        nanoSecs16
}

// UnmarshalBinary Parameter 335, C1G2RFControl.
func (p *c1G2RFControl) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamC1G2RFControl requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	p.IndexIntoUHFC1G2RFModeTable = binary.BigEndian.Uint16(data)
	p.Tari = binary.BigEndian.Uint16(data[2:])
	return nil
}

// c1G2SingulationControl is Parameter 336, C1G2SingulationControl.
type c1G2SingulationControl struct {
	C1G2SingulationControlSession               C1G2SingulationControlSessionType
	TagPopulation                               uint16
	TagTransitTime                              milliSecs32
	C1G2TagInventoryStateAwareSingulationAction *c1G2TagInventoryStateAwareSingulationAction
}

// UnmarshalBinary Parameter 336, C1G2SingulationControl.
func (p *c1G2SingulationControl) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("ParamC1G2SingulationControl requires at least 7 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2SingulationControlSession = C1G2SingulationControlSessionType(data[0])
	p.TagPopulation = binary.BigEndian.Uint16(data[1:])
	p.TagTransitTime = binary.BigEndian.Uint32(data[3:])
	data = data[7:]

	// sub-parameters

	// C1G2TagInventoryStateAwareSingulationAction is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2TagInventoryStateAwareSingulationAction needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateAwareSingulationAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TagInventoryStateAwareSingulationAction says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.C1G2TagInventoryStateAwareSingulationAction = new(c1G2TagInventoryStateAwareSingulationAction)
		*p.C1G2TagInventoryStateAwareSingulationAction = c1G2TagInventoryStateAwareSingulationAction(C1G2TagInventoryStateAwareSingulationActionFlags(data[4]))
		data = data[subLen:]
	}

	return nil
}

// c1G2TagInventoryStateAwareSingulationAction is Parameter 337, C1G2TagInventoryStateAwareSingulationAction.
type c1G2TagInventoryStateAwareSingulationAction C1G2TagInventoryStateAwareSingulationActionFlags

// UnmarshalBinary Parameter 337, C1G2TagInventoryStateAwareSingulationAction.
func (p *c1G2TagInventoryStateAwareSingulationAction) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamC1G2TagInventoryStateAwareSingulationAction requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = c1G2TagInventoryStateAwareSingulationAction(C1G2TagInventoryStateAwareSingulationActionFlags(data[0]))
	return nil
}

// c1G2TagSpec is Parameter 338, C1G2TagSpec.
type c1G2TagSpec struct {
	TagPattern1 c1G2TargetTag
	TagPattern2 *c1G2TargetTag
}

// UnmarshalBinary Parameter 338, C1G2TagSpec.
func (p *c1G2TagSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 11 {
		return errors.Errorf("ParamC1G2TagSpec requires at least 11 bytes "+
			"but only %d are available", len(data))
	}

	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TargetTag {
		return errors.Errorf("expected ParamC1G2TargetTag, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		if err := p.TagPattern1.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	// TagPattern2 is optional
	if len(data) == 0 {
		return nil
	}

	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2TargetTag needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TargetTag {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return errors.Errorf("ParamC1G2TargetTag says it has %d bytes,"+
				" but only %d bytes remain", subLen, len(data))
		}

		p.TagPattern2 = new(c1G2TargetTag)
		if err := p.TagPattern2.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}

		data = data[subLen:]
	}

	return nil
}

// c1G2TargetTag is Parameter 339, C1G2TargetTag.
type c1G2TargetTag struct {
	C1G2MemoryBank     C1G2MemoryBankType
	MatchFlag          bool
	MostSignificantBit uint16
	TagMask            []byte
	TagData            []byte
}

// UnmarshalBinary Parameter 339, C1G2TargetTag.
func (p *c1G2TargetTag) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return errors.Errorf("ParamC1G2TargetTag requires at least 7 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2MemoryBank = data[0] >> 6
	p.MatchFlag = data[0]&0x20 != 0
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	if arrLen := int(binary.BigEndian.Uint16(data[3:])) & 7; int64(arrLen) > int64(len(data[5:])) {
		return errors.Errorf("TagMask (bit array) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.TagMask = make([]byte, arrLen)
		for i := 0; i < arrLen; i++ {
			p.TagMask[i] = data[i]
		}

		data = data[arrLen+5:]
	}

	if arrLen := int(binary.BigEndian.Uint16(data)) & 7; int64(arrLen) > int64(len(data[2:])) {
		return errors.Errorf("TagData (bit array) declares it has %d bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.TagData = make([]byte, arrLen)
		for i := 0; i < arrLen; i++ {
			p.TagData[i] = data[i]
		}

		data = data[arrLen+2:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2TargetTag, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2Read is Parameter 341, C1G2Read.
type c1G2Read struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 341, C1G2Read.
func (p *c1G2Read) UnmarshalBinary(data []byte) error {
	if len(data) != 11 {
		return errors.Errorf("ParamC1G2Read requires exactly 11 bytes "+
			"but received %d", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2Write is Parameter 342, C1G2Write.
type c1G2Write struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 342, C1G2Write.
func (p *c1G2Write) UnmarshalBinary(data []byte) error {
	if len(data) < 11 {
		return errors.Errorf("ParamC1G2Write requires at least 11 bytes "+
			"but only %d are available", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+11:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2Write, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2Kill is Parameter 343, C1G2Kill.
type c1G2Kill struct {
	OpSpecID     uint16
	KillPassword uint32
}

// UnmarshalBinary Parameter 343, C1G2Kill.
func (p *c1G2Kill) UnmarshalBinary(data []byte) error {
	if len(data) != 6 {
		return errors.Errorf("ParamC1G2Kill requires exactly 6 bytes "+
			"but received %d", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	return nil
}

// c1G2Lock is Parameter 344, C1G2Lock.
type c1G2Lock struct {
	OpSpecID        uint16
	AccessPassword  uint32
	C1G2LockPayload []c1G2LockPayload
}

// UnmarshalBinary Parameter 344, C1G2Lock.
func (p *c1G2Lock) UnmarshalBinary(data []byte) error {
	if len(data) < 12 {
		return errors.Errorf("ParamC1G2Lock requires at least 12 bytes "+
			"but only %d are available", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	data = data[6:]

	// sub-parameters
	if len(data) < 4 {
		return errors.Errorf("parameter ParamC1G2LockPayload needs 4 bytes for a TLV header, "+
			"but only %d bytes remain", len(data))
	}

	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2LockPayload {
		return errors.Errorf("expected ParamC1G2LockPayload, but found %v", subType)
	} else {
		for len(data) >= 4 {
			subType := ParamType(binary.BigEndian.Uint16(data))
			if subType != ParamC1G2LockPayload {
				break
			}

			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return errors.Errorf("ParamC1G2LockPayload says it has %d bytes,"+
					" but only %d bytes remain", subLen, len(data))
			}

			var tmp c1G2LockPayload
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}

			p.C1G2LockPayload = append(p.C1G2LockPayload, tmp)
			data = data[subLen:]
		}

	}

	return nil
}

// c1G2LockPayload is Parameter 345, C1G2LockPayload.
type c1G2LockPayload struct {
	LockPrivilege LockPrivilegeType
	LockData      LockDataType
}

// UnmarshalBinary Parameter 345, C1G2LockPayload.
func (p *c1G2LockPayload) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamC1G2LockPayload requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	p.LockPrivilege = LockPrivilegeType(data[0])
	p.LockData = LockDataType(data[1])
	return nil
}

// c1G2BlockErase is Parameter 346, C1G2BlockErase.
type c1G2BlockErase struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	WordCount      uint16
}

// UnmarshalBinary Parameter 346, C1G2BlockErase.
func (p *c1G2BlockErase) UnmarshalBinary(data []byte) error {
	if len(data) != 11 {
		return errors.Errorf("ParamC1G2BlockErase requires exactly 11 bytes "+
			"but received %d", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2BlockWrite is Parameter 347, C1G2BlockWrite.
type c1G2BlockWrite struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	WordAddress    uint16
	Data           []uint16
}

// UnmarshalBinary Parameter 347, C1G2BlockWrite.
func (p *c1G2BlockWrite) UnmarshalBinary(data []byte) error {
	if len(data) < 11 {
		return errors.Errorf("ParamC1G2BlockWrite requires at least 11 bytes "+
			"but only %d are available", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+11:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockWrite, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2EPCMemorySelector is Parameter 348, C1G2EPCMemorySelector.
type c1G2EPCMemorySelector C1G2EPCMemorySelectorFlags

// UnmarshalBinary Parameter 348, C1G2EPCMemorySelector.
func (p *c1G2EPCMemorySelector) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return errors.Errorf("ParamC1G2EPCMemorySelector requires exactly 1 byte "+
			"but received %d", len(data))
	}

	*p = c1G2EPCMemorySelector(C1G2EPCMemorySelectorFlags(data[0]))
	return nil
}

// c1G2ReadOpSpecResult is Parameter 349, C1G2ReadOpSpecResult.
type c1G2ReadOpSpecResult struct {
	C1G2ReadOpSpecResultType C1G2ReadOpSpecResultType
	OpSpecID                 uint16
	Data                     []uint16
}

// UnmarshalBinary Parameter 349, C1G2ReadOpSpecResult.
func (p *c1G2ReadOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamC1G2ReadOpSpecResult requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2ReadOpSpecResultType = C1G2ReadOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("Data ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+5:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2ReadOpSpecResult, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2WriteOpSpecResult is Parameter 350, C1G2WriteOpSpecResult.
type c1G2WriteOpSpecResult struct {
	C1G2WriteOpSpecResultType C1G2WriteOpSpecResultType
	OpSpecID                  uint16
	WordsWritten              uint16
}

// UnmarshalBinary Parameter 350, C1G2WriteOpSpecResult.
func (p *c1G2WriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errors.Errorf("ParamC1G2WriteOpSpecResult requires exactly 5 bytes "+
			"but received %d", len(data))
	}

	p.C1G2WriteOpSpecResultType = C1G2WriteOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// c1G2KillOpSpecResult is Parameter 351, C1G2KillOpSpecResult.
type c1G2KillOpSpecResult struct {
	C1G2KillResult C1G2KillResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 351, C1G2KillOpSpecResult.
func (p *c1G2KillOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2KillOpSpecResult requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2KillResult = C1G2KillResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2LockOpSpecResult is Parameter 352, C1G2LockOpSpecResult.
type c1G2LockOpSpecResult struct {
	C1G2LockResult C1G2LockResultType
	OpSpecID       uint16
}

// UnmarshalBinary Parameter 352, C1G2LockOpSpecResult.
func (p *c1G2LockOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2LockOpSpecResult requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2LockResult = C1G2LockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockEraseOpSpecResult is Parameter 353, C1G2BlockEraseOpSpecResult.
type c1G2BlockEraseOpSpecResult struct {
	C1G2BlockEraseResult C1G2BlockEraseResultType
	OpSpecID             uint16
}

// UnmarshalBinary Parameter 353, C1G2BlockEraseOpSpecResult.
func (p *c1G2BlockEraseOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2BlockEraseOpSpecResult requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2BlockEraseResult = C1G2BlockEraseResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockWriteOpSpecResult is Parameter 354, C1G2BlockWriteOpSpecResult.
type c1G2BlockWriteOpSpecResult struct {
	C1G2BlockWriteResult C1G2BlockWriteResultType
	OpSpecID             uint16
	WordsWritten         uint16
}

// UnmarshalBinary Parameter 354, C1G2BlockWriteOpSpecResult.
func (p *c1G2BlockWriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 5 {
		return errors.Errorf("ParamC1G2BlockWriteOpSpecResult requires exactly 5 bytes "+
			"but received %d", len(data))
	}

	p.C1G2BlockWriteResult = C1G2BlockWriteResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// loopSpec is Parameter 355, LoopSpec.
type loopSpec uint32

// UnmarshalBinary Parameter 355, LoopSpec.
func (p *loopSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return errors.Errorf("ParamLoopSpec requires exactly 4 bytes "+
			"but received %d", len(data))
	}

	*p = loopSpec(binary.BigEndian.Uint32(data))
	return nil
}

// specLoopEvent is Parameter 356, SpecLoopEvent.
type specLoopEvent struct {
	ROSpecID  uint32
	LoopCount uint32
}

// UnmarshalBinary Parameter 356, SpecLoopEvent.
func (p *specLoopEvent) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamSpecLoopEvent requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.LoopCount = binary.BigEndian.Uint32(data[4:])
	return nil
}

// c1G2Recommission is Parameter 357, C1G2Recommission.
type c1G2Recommission struct {
	OpSpecID              uint16
	KillPassword          uint32
	C1G2RecommissionFlags C1G2RecommissionFlags
}

// UnmarshalBinary Parameter 357, C1G2Recommission.
func (p *c1G2Recommission) UnmarshalBinary(data []byte) error {
	if len(data) != 7 {
		return errors.Errorf("ParamC1G2Recommission requires exactly 7 bytes "+
			"but received %d", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2RecommissionFlags = C1G2RecommissionFlags(data[6])
	return nil
}

// c1G2BlockPermalock is Parameter 358, C1G2BlockPermalock.
type c1G2BlockPermalock struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockMask      []uint16
}

// UnmarshalBinary Parameter 358, C1G2BlockPermalock.
func (p *c1G2BlockPermalock) UnmarshalBinary(data []byte) error {
	if len(data) < 11 {
		return errors.Errorf("ParamC1G2BlockPermalock requires at least 11 bytes "+
			"but only %d are available", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return errors.Errorf("BlockMask ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.BlockMask = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.BlockMask[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+11:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2BlockPermalock, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// c1G2GetBlockPermalockStatus is Parameter 359, C1G2GetBlockPermalockStatus.
type c1G2GetBlockPermalockStatus struct {
	OpSpecID       uint16
	AccessPassword uint32
	C1G2MemoryBank C1G2MemoryBankType
	BlockAddress   uint16
	BlockRange     uint16
}

// UnmarshalBinary Parameter 359, C1G2GetBlockPermalockStatus.
func (p *c1G2GetBlockPermalockStatus) UnmarshalBinary(data []byte) error {
	if len(data) != 11 {
		return errors.Errorf("ParamC1G2GetBlockPermalockStatus requires exactly 11 bytes "+
			"but received %d", len(data))
	}

	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	p.BlockRange = binary.BigEndian.Uint16(data[9:])
	return nil
}

// c1G2RecommissionOpSpecResult is Parameter 360, C1G2RecommissionOpSpecResult.
type c1G2RecommissionOpSpecResult struct {
	C1G2RecommissionResult C1G2RecommissionResultType
	OpSpecID               uint16
}

// UnmarshalBinary Parameter 360, C1G2RecommissionOpSpecResult.
func (p *c1G2RecommissionOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2RecommissionOpSpecResult requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2RecommissionResult = C1G2RecommissionResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2BlockPermalockOpSpecResult is Parameter 361, C1G2BlockPermalockOpSpecResult.
type c1G2BlockPermalockOpSpecResult struct {
	C1G2BlockPermalockResult C1G2BlockPermalockResultType
	OpSpecID                 uint16
}

// UnmarshalBinary Parameter 361, C1G2BlockPermalockOpSpecResult.
func (p *c1G2BlockPermalockOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) != 3 {
		return errors.Errorf("ParamC1G2BlockPermalockOpSpecResult requires exactly 3 bytes "+
			"but received %d", len(data))
	}

	p.C1G2BlockPermalockResult = C1G2BlockPermalockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// c1G2GetBlockPermalockStatusOpSpecResult is Parameter 362, C1G2GetBlockPermalockStatusOpSpecResult.
type c1G2GetBlockPermalockStatusOpSpecResult struct {
	C1G2GetBlockPermalockStatusResult C1G2GetBlockPermalockStatusResultType
	OpSpecID                          uint16
	PermalockStatus                   []uint16
}

// UnmarshalBinary Parameter 362, C1G2GetBlockPermalockStatusOpSpecResult.
func (p *c1G2GetBlockPermalockStatusOpSpecResult) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return errors.Errorf("ParamC1G2GetBlockPermalockStatusOpSpecResult requires at least 5 bytes "+
			"but only %d are available", len(data))
	}

	p.C1G2GetBlockPermalockStatusResult = C1G2GetBlockPermalockStatusResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return errors.Errorf("PermalockStatus ([]uint16) declares it has %d*2 bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.PermalockStatus = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.PermalockStatus[i] = binary.BigEndian.Uint16(data[pos:])
		}

		data = data[arrLen*2+5:]
	}

	if len(data) > 0 {
		return errors.Errorf("finished reading C1G2GetBlockPermalockStatusOpSpecResult, but an unexpected %d bytes remain", len(data))
	}

	return nil
}

// maximumReceiveSensitivity is Parameter 363, MaximumReceiveSensitivity.
type maximumReceiveSensitivity dBm16

// UnmarshalBinary Parameter 363, MaximumReceiveSensitivity.
func (p *maximumReceiveSensitivity) UnmarshalBinary(data []byte) error {
	if len(data) != 2 {
		return errors.Errorf("ParamMaximumReceiveSensitivity requires exactly 2 bytes "+
			"but received %d", len(data))
	}

	*p = maximumReceiveSensitivity(dBm16(binary.BigEndian.Uint16(data)))
	return nil
}

// rfSurveyFrequencyCapabilities is Parameter 365, RFSurveyFrequencyCapabilities.
type rfSurveyFrequencyCapabilities struct {
	MinFrequency kHz
	MaxFrequency kHz
}

// UnmarshalBinary Parameter 365, RFSurveyFrequencyCapabilities.
func (p *rfSurveyFrequencyCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) != 8 {
		return errors.Errorf("ParamRFSurveyFrequencyCapabilities requires exactly 8 bytes "+
			"but received %d", len(data))
	}

	p.MinFrequency = binary.BigEndian.Uint32(data)
	p.MaxFrequency = binary.BigEndian.Uint32(data[4:])
	return nil
}

// custom is Parameter 1023, Custom.
type custom struct {
	VendorID             uint32
	Subtype              uint32
	VendorParameterValue []byte
}

// UnmarshalBinary Parameter 1023, Custom.
func (p *custom) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return errors.Errorf("ParamCustom requires at least 8 bytes "+
			"but only %d are available", len(data))
	}

	p.VendorID = binary.BigEndian.Uint32(data)
	p.Subtype = binary.BigEndian.Uint32(data[4:])
	if len(data)-8 == 0 {
		return nil
	}

	p.VendorParameterValue = make([]byte, len(data)-8)
	copy(p.VendorParameterValue, data[8:])

	data = data[8:]
	return nil
}
